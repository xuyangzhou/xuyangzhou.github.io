<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>xuyz-blog</title>
  
  <subtitle>鲜衣怒马少年时，一日看尽长安花</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2019-11-10T07:11:53.727Z</updated>
  <id>/</id>
  
  <author>
    <name>xuyangzhou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js 数组方法总结 之 一道面试题引发的血案</title>
    <link href="/2019/11/08/Array-methods/"/>
    <id>/2019/11/08/Array-methods/</id>
    <published>2019-11-08T02:09:31.000Z</published>
    <updated>2019-11-10T07:11:53.727Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Nov 10 2019 15:59:29 GMT+0800 (GMT+08:00) --><p>在前端面试当中高频出现的一道面试题，让我产生了把js数组的方法总结一下的念头，呐，就是下面这道题目引发的血案！看了解析先别撤哦，后面留了几道提升题目，你值得拥有（皮这一下很开心~~）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="built_in">parseInt</span>); </span><br><span class="line"></span><br><span class="line">解析：</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> <span class="built_in">parseInt</span>(item, index));</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">2</span>, <span class="number">1</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line">故：结果为 [<span class="number">1</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>]</span><br><span class="line"></span><br><span class="line">考点分析：</span><br><span class="line"><span class="number">1.</span> map(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>)</span>&#123;&#125;)方法回调函数的参数</span><br><span class="line">   currentValue 当前元素的值</span><br><span class="line">   index 当前元素的索引值</span><br><span class="line">   arr 原数组</span><br><span class="line"><span class="number">2.</span> <span class="built_in">parseInt</span>(string, radix) 函数的参数</span><br><span class="line">   radix该值介于 <span class="number">2</span> ~ <span class="number">36</span> 之间,如果省略该参数或其值为 <span class="number">0</span>，则数字将以 <span class="number">10</span> 为基础来解析</span><br><span class="line">   如果它以 “<span class="number">0</span>x” 或 “<span class="number">0</span>X” 开头，将以 <span class="number">16</span> 为基数</span><br><span class="line">   如果该参数小于 <span class="number">2</span> 或者大于 <span class="number">36</span>，则 <span class="built_in">parseInt</span>() 将返回 <span class="literal">NaN</span></span><br></pre></td></tr></table></figure><h3 id="转化方法"><a href="#转化方法" class="headerlink" title="转化方法"></a>转化方法</h3><blockquote><p>toString() 返回数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="string">'3'</span>].toString();  <span class="comment">// "1,2,3"</span></span><br></pre></td></tr></table></figure><blockquote><p>valueOf() 返回原数组</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="string">'3'</span>].valueOf(); <span class="comment">// [1, 2, "3"]</span></span><br></pre></td></tr></table></figure><blockquote><p>join() 通过指定的分隔符进行分隔的</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="string">'3'</span>].join(); <span class="comment">// "1,2,3"</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="string">'3'</span>].join(<span class="string">''</span>); <span class="comment">// "123"</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="string">'3'</span>].join(<span class="string">'-'</span>); <span class="comment">// "1-2-3"</span></span><br></pre></td></tr></table></figure><h3 id="栈方法-LIFO-Last-In-First-Out-后进先出的数据结构"><a href="#栈方法-LIFO-Last-In-First-Out-后进先出的数据结构" class="headerlink" title="栈方法 LIFO(Last-In-First-Out,后进先出的数据结构)"></a>栈方法 LIFO(Last-In-First-Out,后进先出的数据结构)</h3><blockquote><p>push() 添加到数组末尾，并返回修改后数组的长度</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>].push(<span class="number">3</span>); <span class="comment">// 3,原数组: [1,2,3]</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>].push([<span class="number">3</span>,<span class="number">4</span>]); <span class="comment">// 3, 原数组：[1,2,[3,4]]</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>].push(<span class="number">3</span>,<span class="number">4</span>); <span class="comment">// 4, 原数组：[1,2,3,4]</span></span><br></pre></td></tr></table></figure><blockquote><p>pop() 从数组末尾移除一项，返回移除的项</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>].pop(); <span class="comment">// 2, 原数组： [1]</span></span><br></pre></td></tr></table></figure><h3 id="队列方法-先进先出"><a href="#队列方法-先进先出" class="headerlink" title="队列方法(先进先出)"></a>队列方法(先进先出)</h3><blockquote><p>unshift() 在数组前添加，返回修改后数组的长度</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>].unshift(<span class="number">2</span>); <span class="comment">// 3, 原数组：[2,1,2]</span></span><br></pre></td></tr></table></figure><blockquote><p>shift()</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>].shift(); <span class="comment">// 1, 原数组：[2]</span></span><br></pre></td></tr></table></figure><h3 id="重排方法"><a href="#重排方法" class="headerlink" title="重排方法"></a>重排方法</h3><blockquote><p>reverse() 反转数组项的顺序，返回反转之后的数组</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].reverse(); <span class="comment">// [3,2,1]</span></span><br></pre></td></tr></table></figure><blockquote><p>sort() 排序</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当不带参数调用sort（）时，数组元素以字母表顺序排序（如有必要将临时转化为字符串进行比较）</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">2</span>].sort(); <span class="comment">// [1,11,2,3]</span></span><br><span class="line">[<span class="string">'2'</span>,<span class="string">'1'</span>,<span class="string">'3'</span>,<span class="string">'11'</span>].sort(); <span class="comment">//  ["1", "11", "2", "3"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给sort方法传递一个比较函数，该函数决定了它的两个参数在排好序的数组中的先后顺序：</span></span><br><span class="line"><span class="comment">// 假设第一个参数应该在前，比较函数应该返回一个小于0的数值，反之，</span></span><br><span class="line"><span class="comment">// 假设第一个参数应该在后，函数应该返回一个大于0的数值，</span></span><br><span class="line"><span class="comment">// 并且，假设两个值相等，函数应该返回0</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">3</span>].sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a-b); <span class="comment">// [1, 2, 3, 11, 22, 33]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以指定对象的属性进行排序</span></span><br><span class="line"></span><br><span class="line">[&#123;<span class="attr">name</span>:<span class="string">'zs'</span>,<span class="attr">age</span>:<span class="number">16</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'ls'</span>, <span class="attr">age</span>:<span class="number">25</span>&#125;].sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="string">'name'</span>] &lt; b[<span class="string">'name'</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="string">'name'</span>] &gt; b[<span class="string">'name'</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><blockquote><p>concat() 连接两个或多个数组，不会改变原数组，返回连接的新数组</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>].concat([<span class="number">3</span>,<span class="number">4</span>]); <span class="comment">// [1,2,3,4]</span></span><br></pre></td></tr></table></figure><blockquote><p>slice() 从已有数组中返回选定的元素，不会改变原数组，返回截取之后的新数组</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].slice(<span class="number">1</span>,<span class="number">3</span>); <span class="comment">// [2,3]</span></span><br></pre></td></tr></table></figure><blockquote><p>splice() 向/从数组中添加/删除元素，然后返回被删除的元素</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>].splice(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// [1]</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>].splice(<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>); <span class="comment">// [], 原数组[1,2,3]</span></span><br></pre></td></tr></table></figure><h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><blockquote><p>indexOf() 从数组开头（0）开始查找，返回查找项在数组中的位置，如果没有返回-1</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].indexOf(<span class="number">3</span>); <span class="comment">// 2</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].indexOf(<span class="number">4</span>); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><blockquote><p>lastIndexOf() 从数组末尾开始查找，返回查找项在数组中的位置，如果没有返回-1</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].lastIndexOf(<span class="number">3</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><blockquote><p>every() 对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].every(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">0</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>some() 对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].some(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>filter() 对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的新数组数组，不改变原数组</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].filter(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>); <span class="comment">// [3]</span></span><br></pre></td></tr></table></figure><blockquote><p>forEach() 对数组中的每一项运行给定函数, 没有返回值</p></blockquote><blockquote><p>map() 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的新数组，不改变原数组</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">item</span> =&gt;</span> item * <span class="number">2</span>); <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure><h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><blockquote><p>reduce(callback,[initialValue]) 对数组中的每个元素执行一个由callback提供的reducer函数(升序执行)，将其结果汇总为单个返回值</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].reduce(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> prev + cur); <span class="comment">// 10</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].reduce(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> prev + cur, <span class="number">10</span>); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><blockquote><p>reduceRight(callback,[initialValue]) 和reduce方法相同，执行顺序变为从最后一项开始</p></blockquote><h3 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="built_in">parseInt</span>);    <span class="comment">// [1, NaN, NaN]</span></span><br><span class="line">==&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> <span class="built_in">parseInt</span>(item, index));</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].filter(<span class="built_in">parseInt</span>); <span class="comment">// [1]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].every(<span class="built_in">parseInt</span>);  <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].some(<span class="built_in">parseInt</span>);   <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="built_in">parseInt</span>); <span class="comment">// 1</span></span><br><span class="line">==&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> <span class="built_in">parseInt</span>(prev, cur))</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Nov 10 2019 15:59:29 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;在前端面试当中高频出现的一道面试题，让我产生了把js数组的方法总结一下的念头，呐，就是下面这道题目引发的血案！看了解析先别撤哦，后面留了几道提升
      
    
    </summary>
    
    
      <category term="js" scheme="/categories/js/"/>
    
    
      <category term="js" scheme="/tags/js/"/>
    
      <category term="数组方法" scheme="/tags/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>virtual-dom</title>
    <link href="/2019/03/26/virtual-dom/"/>
    <id>/2019/03/26/virtual-dom/</id>
    <published>2019-03-26T01:52:30.000Z</published>
    <updated>2019-11-10T07:14:45.717Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Nov 10 2019 15:59:29 GMT+0800 (GMT+08:00) --><h3 id="论题：-虚拟DOM和原生谁更快"><a href="#论题：-虚拟DOM和原生谁更快" class="headerlink" title="论题： 虚拟DOM和原生谁更快"></a>论题： 虚拟DOM和原生谁更快</h3><h6 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h6><p><a href="https://www.zhihu.com/question/31809713/answer/53544875">虚拟DOM和原生谁更快？</a></p><p><a href="https://juejin.im/post/5c8e5e4951882545c109ae9c">DOM和DOM-diff</a></p><h4 id="尤大在知乎的回复"><a href="#尤大在知乎的回复" class="headerlink" title="尤大在知乎的回复"></a>尤大在知乎的回复</h4><ul><li><ol><li>原生 DOM 操作 vs. 通过框架封装操作。</li></ol></li></ul><p>这是一个性能 vs. 可维护性的取舍。框架的意义在于为你掩盖底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。针对任何一个 benchmark，我都可以写出比任何框架更快的手动优化，但是那有什么意义呢？在构建一个实际应用的时候，你难道为每一个地方都去做手动优化吗？出于可维护性的考虑，这显然不可能。框架给你的保证是，你在不需要手动优化的情况下，我依然可以给你提供过得去的性能。</p><ul><li><ol start="2"><li>对 React 的 Virtual DOM 的误解。</li></ol></li></ul><p>React 从来没有说过 “React 比原生操作 DOM 快”。React 的基本思维模式是每次有变动就整个重新渲染整个应用。如果没有 Virtual DOM，简单来想就是直接重置 innerHTML。很多人都没有意识到，在一个大型列表所有数据都变了的情况下，重置 innerHTML 其实是一个还算合理的操作… 真正的问题是在 “全部重新渲染” 的思维模式下，即使只有一行数据变了，它也需要重置整个 innerHTML，这时候显然就有大量的浪费。我们可以比较一下 innerHTML vs. Virtual DOM 的重绘性能消耗：innerHTML: render html string O(template size) + 重新创建所有 DOM 元素 O(DOM size)Virtual DOM: render Virtual DOM + diff O(template size) + 必要的 DOM 更新 O(DOM change)Virtual DOM render + diff 显然比渲染 html 字符串要慢，但是！它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。可以看到，innerHTML 的总计算量不管是 js 计算还是 DOM 操作都是和整个界面的大小相关，但 Virtual DOM 的计算量里面，只有 js 计算和界面大小相关，DOM 操作是和数据的变动量相关的。前面说了，和 DOM 操作比起来，js 计算是极其便宜的。这才是为什么要有 Virtual DOM：它保证了 1）不管你的数据变化多少，每次重绘的性能都可以接受；2) 你依然可以用类似 innerHTML 的思路去写你的应用。</p><ul><li><ol start="3"><li>MVVM vs. Virtual DOM</li></ol></li></ul><p>相比起 React，其他 MVVM 系框架比如 Angular, Knockout 以及 Vue、Avalon 采用的都是数据绑定：通过 Directive/Binding 对象，观察数据变化并保留对实际 DOM 元素的引用，当有数据变化时进行对应的操作。MVVM 的变化检查是数据层面的，而 React 的检查是 DOM 结构层面的。MVVM 的性能也根据变动检测的实现原理有所不同：Angular 的脏检查使得任何变动都有固定的 O(watcher count) 的代价；Knockout/Vue/Avalon 都采用了依赖收集，在 js 和 DOM 层面都是 O(change)：脏检查：scope digest O(watcher count) + 必要 DOM 更新 O(DOM change)依赖收集：重新收集依赖 O(data change) + 必要 DOM 更新 O(DOM change)可以看到，Angular 最不效率的地方在于任何小变动都有的和 watcher 数量相关的性能代价。但是！当所有数据都变了的时候，Angular 其实并不吃亏。依赖收集在初始化和数据变化的时候都需要重新收集依赖，这个代价在小量更新的时候几乎可以忽略，但在数据量庞大的时候也会产生一定的消耗。MVVM 渲染列表的时候，由于每一行都有自己的数据作用域，所以通常都是每一行有一个对应的 ViewModel 实例，或者是一个稍微轻量一些的利用原型继承的 “scope” 对象，但也有一定的代价。所以，MVVM 列表渲染的初始化几乎一定比 React 慢，因为创建 ViewModel / scope 实例比起 Virtual DOM 来说要昂贵很多。这里所有 MVVM 实现的一个共同问题就是在列表渲染的数据源变动时，尤其是当数据是全新的对象时，如何有效地复用已经创建的 ViewModel 实例和 DOM 元素。假如没有任何复用方面的优化，由于数据是 “全新” 的，MVVM 实际上需要销毁之前的所有实例，重新创建所有实例，最后再进行一次渲染！这就是为什么题目里链接的 angular/knockout 实现都相对比较慢。相比之下，React 的变动检查由于是 DOM 结构层面的，即使是全新的数据，只要最后渲染结果没变，那么就不需要做无用功。Angular 和 Vue 都提供了列表重绘的优化机制，也就是 “提示” 框架如何有效地复用实例和 DOM 元素。比如数据库里的同一个对象，在两次前端 API 调用里面会成为不同的对象，但是它们依然有一样的 uid。这时候你就可以提示 track by uid 来让 Angular 知道，这两个对象其实是同一份数据。那么原来这份数据对应的实例和 DOM 元素都可以复用，只需要更新变动了的部分。或者，你也可以直接 track by $index 来进行 “原地复用”：直接根据在数组里的位置进行复用。在题目给出的例子里，如果 angular 实现加上 track by $index 的话，后续重绘是不会比 React 慢多少的。甚至在 dbmonster 测试中，Angular 和 Vue 用了 track by $index 以后都比 React 快: dbmon (注意 Angular 默认版本无优化，优化过的在下面）顺道说一句，React 渲染列表的时候也需要提供 key 这个特殊 prop，本质上和 track-by 是一回事。</p><ul><li><ol start="4"><li>性能比较也要看场合</li></ol></li></ul><p>在比较性能的时候，要分清楚初始渲染、小量数据更新、大量数据更新这些不同的场合。Virtual DOM、脏检查 MVVM、数据收集 MVVM 在不同场合各有不同的表现和不同的优化需求。Virtual DOM 为了提升小量数据更新时的性能，也需要针对性的优化，比如 shouldComponentUpdate 或是 immutable data。初始渲染：Virtual DOM &gt; 脏检查 &gt;= 依赖收集小量数据更新：依赖收集 &gt;&gt; Virtual DOM + 优化 &gt; 脏检查（无法优化） &gt; Virtual DOM 无优化大量数据更新：脏检查 + 优化 &gt;= 依赖收集 + 优化 &gt; Virtual DOM（无法/无需优化）&gt;&gt; MVVM 无优化不要天真地以为 Virtual DOM 就是快，diff 不是免费的，batching 么 MVVM 也能做，而且最终 patch 的时候还不是要用原生 API。在我看来 Virtual DOM 真正的价值从来都不是性能，而是它 1) 为函数式的 UI 编程方式打开了大门；2) 可以渲染到 DOM 以外的 backend，比如 ReactNative。</p><ul><li><ol start="5"><li>总结</li></ol></li></ul><p>以上这些比较，更多的是对于框架开发研究者提供一些参考。主流的框架 + 合理的优化，足以应对绝大部分应用的性能需求。如果是对性能有极致需求的特殊情况，其实应该牺牲一些可维护性采取手动优化：比如 Atom 编辑器在文件渲染的实现上放弃了 React 而采用了自己实现的 tile-based rendering；又比如在移动端需要 DOM-pooling 的虚拟滚动，不需要考虑顺序变化，可以绕过框架的内置实现自己搞一个。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Nov 10 2019 15:59:29 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;论题：-虚拟DOM和原生谁更快&quot;&gt;&lt;a href=&quot;#论题：-虚拟DOM和原生谁更快&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="笔记" scheme="/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="virtual-dom" scheme="/tags/virtual-dom/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="/2018/07/13/closure/"/>
    <id>/2018/07/13/closure/</id>
    <published>2018-07-13T06:31:27.000Z</published>
    <updated>2019-11-10T07:14:45.717Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Nov 10 2019 15:59:29 GMT+0800 (GMT+08:00) --><blockquote><ol><li>作用域</li></ol></blockquote><p>js中变量分为全局变量、局部变量</p><pre><code>var a = 1;  // 全局变量function A(){  b = 2;  // 全局变量（严格模式下报错）  var c = 3; // 局部变量};A();console.log(a); // 1console.log(b); // 2console.log(c); // Error：c is not defined</code></pre><blockquote><ol start="2"><li>预解析</li></ol></blockquote><p>js会把带有var和function关键字的事先声明，并在存放在栈区中</p><pre><code>console.log(a); // undefinedvar a = 1;console.log(b); // undefinedvar b = function b(){}; // 本质还是通过var声明console.log(c); // ƒ c(){}function c(){}; </code></pre><p>疑问？</p><pre><code>function out(){  var a = 1;};out();console.log(a); // Error: a is not defined， 为什么这里报错了，没有预解析</code></pre><blockquote><blockquote><p>2.1 解析执行环境</p></blockquote></blockquote><p>在js执行之前是会预解析function 和var 没错，但是在本例中 它们的“解析执行环境”不同.</p><p>function out是在一个全局的环境中，而a是function out中定义的一个局部变量，a的“解析执行环境”是在function out这个函数里面(这里可以理解为function out里的局部环境)，所以当我们在全局这个环境中console.log(a) 的时候，并没有定义a这个变量或者函数，所以就报错了</p><pre><code>function out(){   console.log(a); // undefined   var a = 1;};out();console.log(a); // Error: a is not defined</code></pre><blockquote><ol start="3"><li>垃圾回收机制-GC</li></ol></blockquote><p>原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。<br>不再使用的变量：也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。</p><blockquote><ol start="4"><li>闭包</li></ol></blockquote><p>作用：局部变量常驻内存，读取函数内部的变量<br>构成：函数嵌套，内部函数调用外部函数的变量<br>缺点：造成内存泄漏</p><pre><code>function parent() {    var a = 1;    function son() {        return a++;    }    return son();}console.log(parent()); // 1</code></pre><blockquote><ol start="5"><li>内存泄漏</li></ol></blockquote><p>5-1. 意外的全局变量引起的内存泄漏。</p><p>原因：全局变量，不会被回收。</p><p>解决：使用严格模式避免。</p><p>5-2. <strong>闭包引起的内存泄漏</strong></p><p>原因：闭包可以维持函数内局部变量，使其得不到释放。</p><p><strong>解决：在退出函数之前，将不使用的局部变量全部删除，如在不用parent函数的时候，parent = null</strong></p><p>5-3. 没有清理的DOM元素引用</p><p>原因：虽然别的地方删除了，但是对象中还存在对dom的引用</p><p>解决：手动删除。</p><p>5-4. 被遗忘的定时器或者回调</p><p>原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。</p><p>解决：手动删除定时器和dom。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Nov 10 2019 15:59:29 GMT+0800 (GMT+08:00) --&gt;&lt;blockquote&gt;&lt;ol&gt;&lt;li&gt;作用域&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p&gt;js中变量分为全局变量、局部变量&lt;/p&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
    
      <category term="js" scheme="/categories/js/"/>
    
    
      <category term="js" scheme="/tags/js/"/>
    
      <category term="闭包" scheme="/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>原型、原型链</title>
    <link href="/2018/07/12/prototype/"/>
    <id>/2018/07/12/prototype/</id>
    <published>2018-07-12T07:10:06.000Z</published>
    <updated>2019-11-10T07:58:37.273Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Nov 10 2019 15:59:29 GMT+0800 (GMT+08:00) --><p><img src="/img/prototype.jpg" alt="原型链"></p><blockquote><p>函数声明</p></blockquote><pre><code>1. 字面量        var f1 = function(){};2. 关键词        function f2 = function(){};3. 构造函数      var f3 = new Function();</code></pre><p>归根结底都是通过new Function 的方式来创建的，js中一切皆对象，对象又分函数对象和普通对象，简单来说通过new Function创建的就称之为函数对象，其他的都是普通对象</p><blockquote><p>原型对象</p></blockquote><p>在js中每一个对象（普通对象、函数对象）都有一个__proto__ 属性，函数对象都有一个prototype属性，指向函数的<strong>原型对象</strong></p><pre><code>var obj = {};var fn = function(){};console.log(obj.__proto__); // {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, …}console.log(obj.prototype); // undefined console.log(fn.__proto__); // ƒ () { [native code] }console.log(fn.prototype); // {constructor: ƒ}</code></pre><p>其中 prototype 就是原型对象，当然原型对象也是一个普通对象，它的作用主要是用来实现继承的，举个栗子：</p><pre><code>var Animal = function(){    this.name = &apos;Tom&apos;;}Animal.prototype.say = function(){    console.log(&apos;I am &apos; + this.name)}var cat = new Animal();var dog = new Animal();cat.say();  // I am Tomdog.say();  // I am Tom</code></pre><p>这里原型继承的问题，暂且按下不表（皮这一下，很开心~~）</p><blockquote><p>原型链</p></blockquote><p>上文说到，每一个对象都有一个__proto__ 属性，那么这个属性究竟有什么用呢？先来看几个例子</p><pre><code>var Animal = function(){    this.name = &apos;Tom&apos;;}var cat = new Animal();console.log(cat.__proto__ === Animal.prototype); // trueconsole.log(Animal.prototype.__proto__ === Object.prototype); // trueconsole.log(Object.prototype.__proto__ === null); // true</code></pre><p>从这个例子中可以看出 __proto__ 属性指向构造函数的原型对象prototype，而prototype也是一个普通对象，也有__proto__属性，继续指向其构造函数，直到指向null，这样就形成了一个原型指向的链条，专业术语称之为原型链。<br>至于为什么最终是null，如果非要解释的话，引用道德经中的一句话：有，是万物之所始；无，是万物之所母。<br>此外，Function、Object作为js的内置函数对象，需要清楚一点，他们都是 new Function创建的</p><pre><code>console.log(Function.constructor === Object.constructor); // true</code></pre><blockquote><p>new 的实现过程</p></blockquote><p>通过new 一个构造函数得到一个对象，看一下内部实现过程，有助于帮助理解原型链指向</p><ol><li><p>声明一个对象 var obj = {};</p></li><li><p>obj.__proto__ = 构造函数.prototype;</p></li><li><p>改变this指针，通过call、apply让this指向第一步创建的obj；</p></li><li><p>返回对象obj;</p><pre><code>function Animal(name){   this.name = name;}Animal.prototype.say = function(){    console.log(&apos;I am &apos; + this.name)}function myNew() {    var obj = {}; // 是指还是new，不要纠结，只是模拟new的过程    var Constructor = [].shift.call(arguments); // 构造函数 Animal    //constructor属性是在Animal.prototype对象中用来记录它指向的 构造函数 的属性    console.log(Constructor.prototype); // {say: ƒ, constructor: ƒ} say:ƒ() constructor:ƒ Animal(name)     obj.__proto__ = Constructor.prototype; // 让obj.__proto__ 指向 Animal.prototype    Constructor.apply(obj,arguments); // 让this指向obj    return obj;}var cat= myNew(Animal,&apos;Tom&apos;);console.log(cat.name); // Tomcat.say(); // I am Tomconsole.log(cat.constructor); // ƒ Animal(name){ this.name = name; }</code></pre></li></ol><blockquote><p>大招</p></blockquote><p>如果以上内容还是不太明白，我自己做了张注解图（线条有点多而杂，见谅~~），以及代码案例帮助理解<br><img src="/img/prototype2.jpg" alt="图1.jpg"></p><pre><code>// 几个概念： // 普通对象是new Object而来的，所以 它的构造函数就是Object// 函数对象是new Function而来的，所以 它的构造函数就是Function，Function、Object是new Function而来的// 对象的__proto__ 指向构造函数的prototypefunction Animal(){}var cat = new Animal();cat.constructor == Animal; // truecat.__proto__ === Animal.prototype; // trueAnimal.constructor === Function; // trueAnimal.prototype.__proto__ === Object.prototype; // true 注：prototype是对象Animal.__proto__ === Function.prototype; // trueObject.constructor  === Function; // trueObject.__proto__ === Function.prototype; // trueObject.prototype.__proto__ === null; // trueFunction.constructor === Function; // trueFunction.__proto__ === Function.prototype; // trueFunction.prototype.__proto__ === Object.prototype; // true</code></pre><p>关于面向对象、继承推荐一篇超赞的文章：<a href="http://cherryblog.site/javascript-oop.html">javascript面向对象编程，带你认识封装、继承和多态</a>，深度好文，值得一读！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Nov 10 2019 15:59:29 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;img src=&quot;/img/prototype.jpg&quot; alt=&quot;原型链&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;函数声明&lt;/p&gt;&lt;/blo
      
    
    </summary>
    
    
      <category term="js" scheme="/categories/js/"/>
    
    
      <category term="js" scheme="/tags/js/"/>
    
      <category term="原型" scheme="/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="new的过程" scheme="/tags/new%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>hexo command</title>
    <link href="/2017/07/24/hello-world/"/>
    <id>/2017/07/24/hello-world/</id>
    <published>2017-07-24T02:09:31.000Z</published>
    <updated>2019-11-10T07:14:45.717Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Nov 10 2019 15:59:29 GMT+0800 (GMT+08:00) --><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Nov 10 2019 15:59:29 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first 
      
    
    </summary>
    
    
      <category term="hexo" scheme="/categories/hexo/"/>
    
    
      <category term="hexo" scheme="/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>开博缘由</title>
    <link href="/2017/04/29/begin/"/>
    <id>/2017/04/29/begin/</id>
    <published>2017-04-29T09:02:38.000Z</published>
    <updated>2019-11-08T07:20:02.817Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Nov 10 2019 15:59:29 GMT+0800 (GMT+08:00) --><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>佛曰：一切皆有缘法，缘起缘灭缘自在 情深情浅不由人，总觉得少这么一个起因内心有愧~~<br>对于任何一个有追求(装X)的前端攻城狮来说，拥有一个博客是追求(装X)路上的一把利刃，正所谓念念不忘必有回响，历经千辛万苦，算是给自己搭建了一个属于自己的小窝。<br>当然，如果开博不是为了装X，那将变得毫无意义！搭建这个博客的主要原因是想把自己学习道路上get到的技能做一个梳理，好记性不如烂笔头么！其次是把自己踩得那些坑分享给更多的人，可能您要说就我的这点经验是在没有借鉴的价值。NO NO NO 且听我慢慢道来。往往看一些大神的帖子会有一种感觉就是规避掉了一些你关注的点，当然这个不是说人家考虑的不到位，而是由于我们的技术栈存在差异，可能人家在做第一步的时候就已经为后面做好了一些铺垫，规避掉了一些问题，而并没有体现到教程当中，这样对于初学者来可能就会遇到一些莫名奇妙的问题。好吧！我承认是自己强行解释了一波，来掩盖我要装的本质！</p><p>与hexo结缘要感谢一位许姓小伙伴的极力推荐，看了整个搭建过程的文档之后就按耐不住内心的冲动，义无反顾的qrq送了一血！然后就有了… (不要想歪啊 ~~)</p><h2 id="缘灭"><a href="#缘灭" class="headerlink" title="缘灭"></a>缘灭</h2><p>如若梦起缘生，梦逝缘灭，我愿一梦不起</p><p>最后附上我参考的一片写的很好的博文 <a href="http://www.jianshu.com/p/a52b68794a6b">hexo创建个人博客</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Nov 10 2019 15:59:29 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;佛曰：一切
      
    
    </summary>
    
    
      <category term="心情物语" scheme="/categories/%E5%BF%83%E6%83%85%E7%89%A9%E8%AF%AD/"/>
    
    
      <category term="心情物语" scheme="/tags/%E5%BF%83%E6%83%85%E7%89%A9%E8%AF%AD/"/>
    
  </entry>
  
</feed>
