<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jason</title>
  
  <subtitle>鲜衣怒马少年时，一日看尽长安花</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-05-08T03:01:42.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Jason xu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>10个让你爱不释手的一行Javascript代码</title>
    <link href="http://example.com/2023/05/08/js10/"/>
    <id>http://example.com/2023/05/08/js10/</id>
    <published>2023-05-08T03:01:42.000Z</published>
    <updated>2023-05-08T03:01:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇博客中，我们将分享 10+ 个实用的一行  JavaScript 代码，这些代码可以帮助你提高编码效率和代码简洁度。这些代码片段将涵盖各种用途，从操作数组和字符串，到更高级的概念，如异步编程和面向对象编程。</p><h3 id="获取数组中的随机元素"><a href="#获取数组中的随机元素" class="headerlink" title="获取数组中的随机元素"></a>获取数组中的随机元素</h3><p>使用 Math.random() 函数和数组长度可以轻松获取数组中的随机元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> randomElement = arr[<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * arr.<span class="property">length</span>)];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(randomElement);</span><br></pre></td></tr></table></figure><h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><p>使用 reduce() 函数和 concat() 函数可以轻松实现数组扁平化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line"><span class="keyword">const</span> flattenedArr = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc.<span class="title function_">concat</span>(cur), []);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flattenedArr); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><h3 id="对象数组根据某个属性值进行排序"><a href="#对象数组根据某个属性值进行排序" class="headerlink" title="对象数组根据某个属性值进行排序"></a>对象数组根据某个属性值进行排序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortedArray = array.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (a.<span class="property">property</span> &gt; b.<span class="property">property</span> ? <span class="number">1</span> : -<span class="number">1</span>));</span><br></pre></td></tr></table></figure><h3 id="从数组中删除特定元素"><a href="#从数组中删除特定元素" class="headerlink" title="从数组中删除特定元素"></a>从数组中删除特定元素</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> removedArray = array.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item !== elementToRemove);</span><br></pre></td></tr></table></figure><h3 id="检查数组中是否存在重复项"><a href="#检查数组中是否存在重复项" class="headerlink" title="检查数组中是否存在重复项"></a>检查数组中是否存在重复项</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">hasDuplicates</span> = (<span class="params">array</span>) =&gt; <span class="keyword">new</span> <span class="title class_">Set</span>(array).<span class="property">size</span> !== array.<span class="property">length</span>;</span><br></pre></td></tr></table></figure><h3 id="首字母大写"><a href="#首字母大写" class="headerlink" title="首字母大写"></a>首字母大写</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> capitalized = str.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + str.<span class="title function_">slice</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="获取随机整数"><a href="#获取随机整数" class="headerlink" title="获取随机整数"></a>获取随机整数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> randomInt = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (max - min + <span class="number">1</span>)) + min;</span><br></pre></td></tr></table></figure><h3 id="获取随机字符串"><a href="#获取随机字符串" class="headerlink" title="获取随机字符串"></a>获取随机字符串</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> randomStr = <span class="title class_">Math</span>.<span class="title function_">random</span>().<span class="title function_">toString</span>(<span class="number">36</span>).<span class="title function_">substring</span>(<span class="number">2</span>, length);</span><br></pre></td></tr></table></figure><h3 id="使用解构和-rest-运算符交换变量的值"><a href="#使用解构和-rest-运算符交换变量的值" class="headerlink" title="使用解构和 rest 运算符交换变量的值"></a>使用解构和 rest 运算符交换变量的值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>, b = <span class="number">2</span></span><br><span class="line">[b, a] = [a, b]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b) <span class="comment">// 2, 1</span></span><br></pre></td></tr></table></figure><h3 id="将字符串转换为小驼峰式命名"><a href="#将字符串转换为小驼峰式命名" class="headerlink" title="将字符串转换为小驼峰式命名"></a>将字符串转换为小驼峰式命名</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="keyword">const</span> camelCase = str.<span class="title function_">replace</span>(<span class="regexp">/\s(.)/g</span>, <span class="function">(<span class="params">$1</span>) =&gt;</span> $1.<span class="title function_">toUpperCase</span>()).<span class="title function_">replace</span>(<span class="regexp">/\s/g</span>, <span class="string">&#x27;&#x27;</span>).<span class="title function_">replace</span>(<span class="regexp">/^(.)/</span>, <span class="function">(<span class="params">$1</span>) =&gt;</span> $1.<span class="title function_">toLowerCase</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(camelCase) <span class="comment">// &quot;helloWorld&quot;</span></span><br></pre></td></tr></table></figure><h3 id="计算两个日期之间的间隔"><a href="#计算两个日期之间的间隔" class="headerlink" title="计算两个日期之间的间隔"></a>计算两个日期之间的间隔</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">diffInDays</span> = (<span class="params">dateA, dateB</span>) =&gt; <span class="title class_">Math</span>.<span class="title function_">floor</span>((dateB - dateA) / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>));</span><br></pre></td></tr></table></figure><h3 id="查找日期位于一年中的第几天"><a href="#查找日期位于一年中的第几天" class="headerlink" title="查找日期位于一年中的第几天"></a>查找日期位于一年中的第几天</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">dayOfYear</span> = (<span class="params">date</span>) =&gt; <span class="title class_">Math</span>.<span class="title function_">floor</span>((date - <span class="keyword">new</span> <span class="title class_">Date</span>(date.<span class="title function_">getFullYear</span>(), <span class="number">0</span>, <span class="number">0</span>)) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>);</span><br></pre></td></tr></table></figure><h3 id="复制内容到剪切板"><a href="#复制内容到剪切板" class="headerlink" title="复制内容到剪切板"></a>复制内容到剪切板</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">copyToClipboard</span> = (<span class="params">text</span>) =&gt; navigator.<span class="property">clipboard</span>.<span class="title function_">writeText</span>(text);</span><br><span class="line"></span><br><span class="line"><span class="title function_">copyToClipboard</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="获取变量的类型"><a href="#获取变量的类型" class="headerlink" title="获取变量的类型"></a>获取变量的类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getType</span> = (<span class="params">variable</span>) =&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(variable).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>).<span class="title function_">toLowerCase</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">getType</span>(<span class="string">&#x27;&#x27;</span>);     <span class="comment">// string</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="number">0</span>);      <span class="comment">// number</span></span><br><span class="line"><span class="title function_">getType</span>();       <span class="comment">// undefined</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="literal">null</span>);   <span class="comment">// null</span></span><br><span class="line"><span class="title function_">getType</span>(&#123;&#125;);     <span class="comment">// object</span></span><br><span class="line"><span class="title function_">getType</span>([]);     <span class="comment">// array</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="number">0</span>);      <span class="comment">// number</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="function">() =&gt;</span> &#123;&#125;);  <span class="comment">// function</span></span><br></pre></td></tr></table></figure><h3 id="检测对象是否为空"><a href="#检测对象是否为空" class="headerlink" title="检测对象是否为空"></a>检测对象是否为空</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isEmptyObject</span> = (<span class="params">obj</span>) =&gt; <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="property">length</span> === <span class="number">0</span> &amp;&amp; obj.<span class="property">constructor</span> === <span class="title class_">Object</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在这篇博客中，我们将分享 10+ 个实用的一行  JavaScript 代码，这些代码可以帮助你提高编码效率和代码简洁度。这些代码片段将涵盖各种用途，从操作数组和字符串，到更高级的概念，如异步编程和面向对象编程。&lt;/p&gt;
&lt;h3 id=&quot;获取数组中的随机元素&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="js" scheme="http://example.com/categories/js/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>10个JavaScript简洁编码技巧</title>
    <link href="http://example.com/2023/05/07/js-pithy/"/>
    <id>http://example.com/2023/05/07/js-pithy/</id>
    <published>2023-05-07T03:01:42.000Z</published>
    <updated>2023-05-07T03:01:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前端开发中，代码简洁非常重要。不仅可以提高代码的可读性和可维护性，还能使代码更易于扩展和重用。下面介绍一些前端代码简洁的方法。</p><h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greeting</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  name = name || <span class="string">&#x27;Guest&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用默认值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greeting</span>(<span class="params">name = <span class="string">&#x27;Guest&#x27;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用箭头函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">a, b</span>) =&gt; a + b;</span><br></pre></td></tr></table></figure><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统写法</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Alice&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用模板字符串</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Alice&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br></pre></td></tr></table></figure><h3 id="对象字面量简写"><a href="#对象字面量简写" class="headerlink" title="对象字面量简写"></a>对象字面量简写</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统写法</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">&#x27;John&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">&#x27;Doe&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: firstName,</span><br><span class="line">  <span class="attr">lastName</span>: lastName</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用简写</span></span><br><span class="line"><span class="keyword">const</span> firstName = <span class="string">&#x27;John&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> lastName = <span class="string">&#x27;Doe&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> user = &#123; firstName, lastName &#125;;</span><br></pre></td></tr></table></figure><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统写法</span></span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;Doe&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> firstName = user.<span class="property">firstName</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = user.<span class="property">lastName</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用解构赋值</span></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;Doe&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; firstName, lastName &#125; = user;</span><br></pre></td></tr></table></figure><h3 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map()"></a>Array.prototype.map()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统写法</span></span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> doubledNumbers = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numbers.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  doubledNumbers.<span class="title function_">push</span>(numbers[i] * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用map()</span></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> doubledNumbers = numbers.<span class="title function_">map</span>(<span class="function"><span class="params">number</span> =&gt;</span> number * <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="Array-prototype-filter"><a href="#Array-prototype-filter" class="headerlink" title="Array.prototype.filter()"></a>Array.prototype.filter()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统写法</span></span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> evenNumbers = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numbers.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (numbers[i] % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    evenNumbers.<span class="title function_">push</span>(numbers[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用filter()</span></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> evenNumbers = numbers.<span class="title function_">filter</span>(<span class="function"><span class="params">number</span> =&gt;</span> number % <span class="number">2</span> === <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce()"></a>Array.prototype.reduce()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统写法</span></span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numbers.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  sum += numbers[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用reduce()</span></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> sum = numbers.<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, number</span>) =&gt;</span> total + number, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="避免使用全局变量"><a href="#避免使用全局变量" class="headerlink" title="避免使用全局变量"></a>避免使用全局变量</h3><p>全局变量会导致变量名冲突和意外的赋值，最好避免使用。可以将需要的变量定义在函数内部或使用模块化的方式管理变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐使用全局变量</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐使用函数内部变量</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐使用模块化</span></span><br><span class="line"><span class="comment">// moduleA.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="comment">// moduleB.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">&#x27;./moduleA.js&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="使用数组和对象解构"><a href="#使用数组和对象解构" class="headerlink" title="使用数组和对象解构"></a>使用数组和对象解构</h3><p>解构可以让代码更加简洁，同时提高可读性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组解构</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> [first, second, third] = arr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象解构</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = obj;</span><br></pre></td></tr></table></figure><h3 id="使用函数式编程思想"><a href="#使用函数式编程思想" class="headerlink" title="使用函数式编程思想"></a>使用函数式编程思想</h3><p>函数式编程思想可以让代码更加简洁，同时提高可维护性。可以使用纯函数、高阶函数、柯里化等方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 纯函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高阶函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">double</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fn</span>(num) * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是一些简单的示例，当然还有很多其他的技巧和方法可以用来让前端代码更加简洁。总之，通过使用这些技巧和方法，我们可以让代码更加易于阅读、维护和扩展，提高开发效率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在前端开发中，代码简洁非常重要。不仅可以提高代码的可读性和可维护性，还能使代码更易于扩展和重用。下面介绍一些前端代码简洁的方法。&lt;/p&gt;
&lt;h3 id=&quot;参数默认值&quot;&gt;&lt;a href=&quot;#参数默认值&quot; class=&quot;headerlink&quot; title=&quot;参数默认值&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="js" scheme="http://example.com/categories/js/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>[译] 动画无法动画化的元素</title>
    <link href="http://example.com/2023/05/06/animatingTheUnanimatable/"/>
    <id>http://example.com/2023/05/06/animatingTheUnanimatable/</id>
    <published>2023-05-06T03:01:42.000Z</published>
    <updated>2023-05-06T03:01:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em><a href="https://www.joshwcomeau.com/react/animating-the-unanimatable/">原文 Animating the Unanimatable</a></em></p></blockquote><p>在 CSS3 transitions、@keyframe动画和即将推出的 <a href="https://w3c.github.io/web-animations/">Web Animations API</a> 等新技术的帮助下，我们在构建Web动画方面拥有了更多的控制力。</p><p>然而，仍有一件事情是这些技术不能直接处理的；即列表重新排序的动画效果。</p><p>假设你有这样一个组件：</p><p><img src="https://www.joshwcomeau.com/images/legacy/flip-move-demo.gif" alt="几个列表项正在重组，带有动画"></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArticleList</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;article-list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.props.articles.map(article =&gt; (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Article</span> <span class="attr">key</span>=<span class="string">&#123;article.id&#125;</span> &#123;<span class="attr">...article</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">        ))&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们有一个父级 <code>ArticleList</code> 组件，它以文章列表为props。 它按顺序映射它们并呈现它们。</p><p>如果列表顺序发生更改（例如：用户切换更改排序的设置，项目被点赞并更改位置，从服务器接收新数据…），React会协调两个状态，并更新 DOM，创建新节点，移动现有节点或销毁节点。</p><p>如果项目从其原始位置移除并重新插入到下方200px处，它对于元素的屏幕位置没有意识。</p><p><strong>由于元素的CSS属性没有更改，因此无法使用CSS转换来动画显示此更改。</strong></p><p>我们怎样才能让浏览器表现得好像这些元素已经移动了一样？这个问题的解决方案将带我们体验低级 DOM 操作、React 生命周期方法和硬件加速 CSS 实践。甚至会有一些基础数学！</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote><p><strong>TL:DR —</strong> 我制作了一个 React 模块来执行此操作。 <a href="https://github.com/joshwcomeau/react-flip-move">来源</a>| <a href="http://joshwcomeau.github.io/react-flip-move/examples">演示</a></p></blockquote><p>为了解决这个问题，我们需要一些特定时刻的信息。暂且不考虑获取这些信息的复杂性，我们假设：</p><ul><li><em>我们知道 React 只是重新渲染</em>，DOM 节点已经重新排列。</li><li><em>浏览器还没有绘制。</em>尽管 DOM 节点处于新位置，但屏幕上的元素尚未更新。</li><li><em>我们知道元素在屏幕上的位置。</em></li><li><em>我们知道元素将在哪里重新绘制。</em></li></ul><p>我们的情况可能是这样的：我们有一个包含 3 个项目的列表，它们只是被颠倒了。我们知道他们原来的位置（左侧），我们知道他们要移动到哪里（右侧）。</p><p><img src="/img/an.png" alt="已重新排序的三个彩色矩形"><br>请忽略我缺乏艺术能力</p><h3 id="操作顺序"><a href="#操作顺序" class="headerlink" title="操作顺序"></a>操作顺序</h3><p>一个小插曲：你可能会惊讶地发现存在一个时间点，我们可以在某个时间点将项目绘制到屏幕上<em>之前判断它的位置。</em></p><p>仔细想想，这是有道理的；浏览器如何在不知道确切绘制位置的情况下将新的像素绘制到屏幕上呢？</p><p>幸运的是，这不是黑匣子；浏览器以不同的步骤更新，可以在计算布局和绘制到屏幕之间执行逻辑。</p><p>但是，我们如何访问计算后的布局？</p><h3 id="DOMRects-来拯救！"><a href="#DOMRects-来拯救！" class="headerlink" title="DOMRects 来拯救！"></a>DOMRects 来拯救！</h3><p>DOM 节点有一个非常有用的本地方法<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect">getBoundingClientRect</a>。它为我们提供了目标元素相对于视口的大小和位置。在计算新布局之前，如果我们在顶部的蓝色矩形上调用它，它可能会给我们以下信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">blueItem.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   top: 0,</span></span><br><span class="line"><span class="comment">//   bottom: 600,</span></span><br><span class="line"><span class="comment">//   left: 0,</span></span><br><span class="line"><span class="comment">//   right: 500,</span></span><br><span class="line"><span class="comment">//   height: 60,</span></span><br><span class="line"><span class="comment">//   width: 400</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>并且，在计算新布局之后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">blueItem.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   top: 136,</span></span><br><span class="line"><span class="comment">//   bottom: 464,</span></span><br><span class="line"><span class="comment">//   left: 0,</span></span><br><span class="line"><span class="comment">//   right: 500,</span></span><br><span class="line"><span class="comment">//   height: 60,</span></span><br><span class="line"><span class="comment">//   width: 400</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p><strong>getBoundingClientRect</strong> 足够聪明，可以计算出元素的新布局位置，同时考虑元素的高度、边距和任何其他会影响它在视口中的位置的变量。</p><p>有了这两个数据，我们就可以计算出元素位置的<em>变化；</em>它的 delta 值。</p><blockquote><p>Δy &#x3D; finalTop - initialTop &#x3D; 132 - 0 &#x3D; 132</p></blockquote><p>所以，我们知道元素向下移动了 132px。同样，我们知道中间的项目根本没有移动（Δy &#x3D; 0px），最后一个项目<em>向上</em>移动了132px（Δy &#x3D; -132px）。</p><p>问题在于，虽然我们知道所有这些事实，但DOM即将更新；在眨眼间，那些盒子将瞬间处于它们的新位置！</p><p>这是我们工具库中的下一个工具的用武之地：<a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">requestAnimationFrame</a>。</p><p>这是 window 对象上的一个方法，它告诉浏览器“嘿，在你对屏幕进行任何更改之前，你能先运行这段代码吗？”。这是一种在更新元素之前快速进行任何所需调整的方法。</p><p>如果在浏览器绘制之前，我们应用更改的<em>逆</em>函数怎么办？想象一下这个 CSS：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.blue-item</span> &#123;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">132px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.purple-item</span> &#123;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.fuscia-item</span> &#123;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">132px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器会绘制此更新，但绘制不会改变任何东西；DOM 节点的位置发生了变化，但我们已经用 CSS 抵消了这种变化。</p><p>这是个有技巧的操作，让我们简要回顾一下刚才发生了什么：</p><ul><li>React 渲染我们的初始状态，蓝色项目在顶部。我们使用 <strong>getBoundingClientRect</strong> 来确定项目的位置。</li><li>React 收到 props：项目已被撤销！现在蓝色项目在底部。</li><li>我们使用 <strong>getBoundingClientRect</strong> 来确定项目现在的位置，并计算位置的变化。</li><li>我们使用 <strong>requestAnimationFrame</strong> 告诉 DOM 应用一些 CSS 来<em>撤销</em>这个新的变化；如果元素的新位置低 100px，我们应用 CSS 使其高 100px。</li></ul><h3 id="到了动画时间了"><a href="#到了动画时间了" class="headerlink" title="到了动画时间了"></a>到了动画时间了</h3><p>好的，我们确实完成了某些事情；我们使得 DOM 的变化对用户完全不可见。这可能是一个很有趣的花招，但现在可能还不清楚它如何帮助我们。</p><p>问题是，我们现在处于一个情况下，普通的 CSS 过渡效果可以再次使用了。为了将这些元素动画到它们的新位置，我们可以添加一个过渡效果并撤消这些人为的位置更改。</p><p>继续使用我们上面的例子：我们的蓝色项实际上是最后一项，但它看起来像是第一项。它的 CSS 如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.blue-item</span> &#123;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">132px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，让我们更新 CSS，使其看起来像这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.blue-item</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: top <span class="number">500ms</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>蓝色项目现在将在半秒内从顶部位置向下滑动到底部位置。万岁！我们已经动画化了一些东西。</p><p>这种技术由 Google 的 Paul Lewis 推广，他称之为 <a href="https://aerotwist.com/blog/flip-your-animations/">FLIP 技术</a>。FLIP 是<strong>First</strong>、<strong>Last</strong>、<strong>I</strong> nverse、<strong>P</strong> lay 的首字母缩写词。</p><p><img src="https://www.joshwcomeau.com/images/legacy/1__wYXRKNWYMbpvirtKPilg8Q.gif" alt="做很多后空翻的家伙如此运动"></p><ul><li>计算<strong>第一个</strong>位置。</li><li>计算<strong>最后</strong>位置。</li><li><strong>反转</strong>位置</li><li><strong>播放</strong>动画</li></ul><p>我们的版本有些不同，但原理是相同的。</p><h2 id="对DOM的简要探究"><a href="#对DOM的简要探究" class="headerlink" title="对DOM的简要探究"></a>对DOM的简要探究</h2><p>在学习这项技术和编写我的模块时，我学到了很多关于 DOM 渲染的知识。虽然我学到的大部分内容超出了本文的范围，但我们应该快速了解一下：绘画和合成之间的区别，以及它对选择硬件加速 CSS 属性的影响。</p><p>最初，浏览器通过 CPU 完成所有工作。近年来，一些非常聪明的人发现可以将某些任务委托给 GPU 以大幅提高性能；具体来说，当静态内容的“纹理”没有改变时。</p><p>主要目标是加快滚动速度；当您向下滚动页面时，没有任何元素发生<em>变化</em>，它们只是向上滑动。浏览器的人很友善，也允许某些 css 属性以相同的方式工作。</p><p>通过使用CSS 属性的<em>变换</em>套件——平移、缩放、旋转、倾斜等——以及不透明度，我们不会改变元素的纹理。如果纹理没有改变，则不必在每一帧上都重新绘制；它可以由 GPU 合成。这就是实现 60+fps 动画的方法。</p><p>如果您想了解有关浏览器渲染过程的更多信息（您应该这样做！既有趣又实用），我在下面提供了一些链接。</p><p>但是，在我们的例子中，这意味着我们应该使用 <em>transform</em> 而不是 <em>top</em>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.blue-item</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">500ms</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">0px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缺失的部分：React"><a href="#缺失的部分：React" class="headerlink" title="缺失的部分：React"></a>缺失的部分：React</h2><blockquote><p><strong>注意</strong>：这篇文章最初是很久以前写的，特别是这一部分的代码还没有很好地老化。使用的生命周期方法已被弃用，并且强烈建议不要使用 ReactDOM.findDOMNode。本节中的思路是可靠，但但请不要尝试重用提供的代码！</p></blockquote><p>React 如何与这一技术结合？令人高兴的是，React 与这一技术完美契合。</p><p>每个子元素都需要两个重要的属性才能使其正常运作：：</p><ul><li>每个子元素都需要一个唯一的”key”属性，这是我们用来区分它们的。 </li><li>每个子元素都需要一个 ref，这样我们就可以查找 DOM 节点并计算其边界框。</li></ul><h3 id="获取第一个位置"><a href="#获取第一个位置" class="headerlink" title="获取第一个位置"></a>获取第一个位置</h3><p>每当组件接收到新的 props，我们需要检查是否需要动画。最早的机会是在 <a href="https://facebook.github.io/react/docs/component-specs.html#updating-componentwillreceiveprops">componentWillReceiveProps</a> 生命周期方法中。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArticleList</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">componentWillReceiveProps</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// Find the ref for this specific child.</span></span><br><span class="line">      <span class="keyword">const</span> ref = <span class="variable language_">this</span>.<span class="property">refs</span>[child.<span class="property">key</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Look up the DOM node</span></span><br><span class="line">      <span class="keyword">const</span> domNode = <span class="title class_">ReactDOM</span>.<span class="title function_">findDOMNode</span>(ref);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Calculate the bounding box</span></span><br><span class="line">      <span class="keyword">const</span> boundingBox = domNode.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Store that box in the state, by its key.</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        [child.<span class="property">key</span>]: boundingBox,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个过程的结尾，我们的 state 将充满 DOMRect 对象，准确地描述每个子元素在页面上的位置。</p><h3 id="获得最后位置"><a href="#获得最后位置" class="headerlink" title="获得最后位置"></a>获得最后位置</h3><p>下一个任务是弄清楚事物的去向。</p><p>这里要做出的非常重要的区别是 <strong>React 的 *render* 方法不会立即绘制到屏幕上。</strong>我对底层细节有点模糊，但这个过程看起来有点像这样：</p><ul><li><em>render</em>返回它希望 DOM 成为什么的表示，</li><li>React 将这种表示与 DOM 的实际状态相协调，并应用差异，</li><li>浏览器注意到有些东西发生了变化，并计算出新的布局，</li><li>React 的 <a href="https://facebook.github.io/react/docs/component-specs.html#updating-componentdidupdate">componentDidUpdate</a> 生命周期方法触发，</li><li>浏览器将更改绘制到屏幕上。</li></ul><p>这个过程的美妙之处在于，我们有机会在计算布局<em>之后</em>但在屏幕更新<em>之前</em>连接到 DOM 的状态。</p><p>下面是代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">previousProps</span>) &#123;</span><br><span class="line">  previousProps.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> domNode  = <span class="title class_">ReactDOM</span>.<span class="title function_">findDOMNode</span>(<span class="variable language_">this</span>.<span class="property">refs</span>[child.<span class="property">key</span>]);</span><br><span class="line">    <span class="keyword">const</span> newBox = domNode.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...more to come</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h3><p>我们现在知道第一个和最后一个位置，没有一毫秒的空闲时间！DOM 即将更新！</p><p>我们将使用 <strong>requestAnimationFrame</strong> 来确保我们的更改在该帧之前完成。</p><p>我们继续编写 <strong>componentDidUpdate</strong> 方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">previousProps</span>) &#123;</span><br><span class="line">  previousProps.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> domNode = <span class="title class_">ReactDOM</span>.<span class="title function_">findDOMNode</span>(<span class="variable language_">this</span>.<span class="property">refs</span>[child.<span class="property">key</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newBox = domNode.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line">    <span class="keyword">const</span> oldBox = <span class="variable language_">this</span>.<span class="property">state</span>[key];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> deltaX = oldBox.<span class="property">left</span> - newBox.<span class="property">left</span>;</span><br><span class="line">    <span class="keyword">const</span> deltaY = oldBox.<span class="property">top</span>  - newBox.<span class="property">top</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">requestAnimationFrame</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// Before the DOM paints, Invert it to its old position</span></span><br><span class="line">      domNode.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`translate(<span class="subst">$&#123;deltaX&#125;</span>px, <span class="subst">$&#123;deltaY&#125;</span>px)`</span>;</span><br><span class="line">      <span class="comment">// Ensure it inverts it immediately</span></span><br><span class="line">      domNode.<span class="property">style</span>.<span class="property">transition</span> = <span class="string">&#x27;transform 0s&#x27;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，该方法运行后，我们的 DOM 节点将重新排列，但它们在屏幕上的位置将保持不变。太棒了！只剩下最后一步了…</p><h3 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">previousProps</span>) &#123;</span><br><span class="line">  previousProps.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> domNode = <span class="title class_">ReactDOM</span>.<span class="title function_">findDOMNode</span>(<span class="variable language_">this</span>.<span class="property">refs</span>[child.<span class="property">key</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newBox = domNode.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line">    <span class="keyword">const</span> oldBox = <span class="variable language_">this</span>.<span class="property">state</span>[key];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> deltaX = oldBox.<span class="property">left</span> - newBox.<span class="property">left</span>;</span><br><span class="line">    <span class="keyword">const</span> deltaY = oldBox.<span class="property">top</span>  - newBox.<span class="property">top</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">requestAnimationFrame</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      domNode.<span class="property">style</span>.<span class="property">transform</span>  = <span class="string">`translate(<span class="subst">$&#123;deltaX&#125;</span>px, <span class="subst">$&#123;deltaY&#125;</span>px)`</span>;</span><br><span class="line">      domNode.<span class="property">style</span>.<span class="property">transition</span> = <span class="string">&#x27;transform 0s&#x27;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="title function_">requestAnimationFrame</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// In order to get the animation to play, we&#x27;ll need to wait for</span></span><br><span class="line">        <span class="comment">// the &#x27;invert&#x27; animation frame to finish, so that its inverted</span></span><br><span class="line">        <span class="comment">// position has propagated to the DOM.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Then, we remove the transform, reverting it to its natural</span></span><br><span class="line">        <span class="comment">// state, and apply a transition so it does so smoothly.</span></span><br><span class="line">        domNode.<span class="property">style</span>.<span class="property">transform</span>  = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        domNode.<span class="property">style</span>.<span class="property">transition</span> = <span class="string">&#x27;transform 500ms&#x27;</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈！我们已经完成了，我们已经为不可动画的元素添加了动画效果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://www.joshwcomeau.com/react/animating-the-unanimatable/&quot;&gt;原文 Animating the Unanimatable&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blo</summary>
      
    
    
    
    <category term="外文翻译" scheme="http://example.com/categories/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
    <category term="动画" scheme="http://example.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>10个超级实用的typescript使用技巧</title>
    <link href="http://example.com/2023/05/04/typescript-eg/"/>
    <id>http://example.com/2023/05/04/typescript-eg/</id>
    <published>2023-05-04T04:00:00.000Z</published>
    <updated>2023-05-04T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>概览：在实际的开发工作过程中，积累了一些常见又超级好用的 typescript 技巧和代码片段，包括整理的其他大神的ts使用技巧，今天筛选了 10+ 个，以供大家参考。</p><h3 id="使用交叉类型来合并多个类型"><a href="#使用交叉类型来合并多个类型" class="headerlink" title="使用交叉类型来合并多个类型"></a>使用交叉类型来合并多个类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Admin</span> = &#123;</span><br><span class="line">  <span class="attr">role</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserAndAdmin</span> = <span class="title class_">User</span> &amp; <span class="title class_">Admin</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">user</span>: <span class="title class_">UserAndAdmin</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">role</span>: <span class="string">&quot;admin&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用联合类型来允许多个类型"><a href="#使用联合类型来允许多个类型" class="headerlink" title="使用联合类型来允许多个类型"></a>使用联合类型来允许多个类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Status</span> = <span class="string">&quot;success&quot;</span> | <span class="string">&quot;error&quot;</span> | <span class="string">&quot;loading&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showMessage</span>(<span class="params">status: Status, message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">showMessage</span>(<span class="string">&quot;success&quot;</span>, <span class="string">&quot;Operation completed successfully&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="使用类型守卫来判断变量的类型"><a href="#使用类型守卫来判断变量的类型" class="headerlink" title="使用类型守卫来判断变量的类型"></a>使用类型守卫来判断变量的类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Admin</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">role</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">user: User | Admin</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;role&quot;</span> <span class="keyword">in</span> user) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;user.name&#125;</span>, you are an admin`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;user.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用optional-chaining操作符-和nullish-coalescing操作符-来简化代码"><a href="#使用optional-chaining操作符-和nullish-coalescing操作符-来简化代码" class="headerlink" title="使用optional chaining操作符(?.)和nullish coalescing操作符(??)来简化代码"></a>使用optional chaining操作符(?.)和nullish coalescing操作符(??)来简化代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">address</span>: &#123;</span><br><span class="line">    <span class="attr">city</span>: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cityName = user?.<span class="property">address</span>?.<span class="property">city</span> ?? <span class="string">&quot;unknown&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="使用装饰器来扩展类和方法的行为"><a href="#使用装饰器来扩展类和方法的行为" class="headerlink" title="使用装饰器来扩展类和方法的行为"></a>使用装饰器来扩展类和方法的行为</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> originalMethod = descriptor.<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">  descriptor.<span class="property">value</span> = <span class="keyword">function</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Calling method <span class="subst">$&#123;propertyKey&#125;</span> with arguments: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(args)&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> originalMethod.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> age: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@log</span></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> and I am <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>);</span><br><span class="line">user.<span class="title function_">greet</span>();</span><br></pre></td></tr></table></figure><h3 id="使用-Record-来定义键值对类型"><a href="#使用-Record-来定义键值对类型" class="headerlink" title="使用 Record 来定义键值对类型"></a>使用 Record 来定义键值对类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">AgeMap</span> = <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">ages</span>: <span class="title class_">AgeMap</span> = &#123;</span><br><span class="line">  <span class="title class_">John</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="title class_">Mary</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="title class_">Mike</span>: <span class="number">35</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用模板字符串和-keyof-来生成属性名称"><a href="#使用模板字符串和-keyof-来生成属性名称" class="headerlink" title="使用模板字符串和 keyof 来生成属性名称"></a>使用模板字符串和 keyof 来生成属性名称</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> getProperty&lt;T, K <span class="keyword">extends</span> keyof T&gt;(<span class="attr">obj</span>: T, <span class="attr">key</span>: K): T[K] &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person</span>: <span class="title class_">Person</span> = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> propertyName = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getProperty</span>(person, propertyName <span class="keyword">as</span> keyof <span class="title class_">Person</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getProperty</span>(person, <span class="string">&quot;age&quot;</span>));</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用模板字符串和 keyof 操作符来生成属性名称，并将其作为参数传递给函数 getProperty。</p><h3 id="使用类型保护来检查变量的类型"><a href="#使用类型保护来检查变量的类型" class="headerlink" title="使用类型保护来检查变量的类型"></a>使用类型保护来检查变量的类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">breed</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isDog</span>(<span class="params">pet: Dog | Cat</span>): pet is <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (pet <span class="keyword">as</span> <span class="title class_">Dog</span>).<span class="property">breed</span> !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">dog</span>: <span class="title class_">Dog</span> = &#123; <span class="attr">name</span>: <span class="string">&quot;Max&quot;</span>, <span class="attr">breed</span>: <span class="string">&quot;Labrador&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">cat</span>: <span class="title class_">Cat</span> = &#123; <span class="attr">name</span>: <span class="string">&quot;Whiskers&quot;</span>, <span class="attr">age</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isDog</span>(dog)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isDog</span>(cat)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用 isDog 函数来检查变量 pet 是否是 Dog 类型。</p><h3 id="使用-Exclude-和-Extract-来过滤类型"><a href="#使用-Exclude-和-Extract-来过滤类型" class="headerlink" title="使用 Exclude 和 Extract 来过滤类型"></a>使用 Exclude 和 Extract 来过滤类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">Exclude</span>&lt;<span class="variable constant_">T1</span>, <span class="built_in">boolean</span>&gt;;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="title class_">Extract</span>&lt;<span class="variable constant_">T1</span>, <span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用 Exclude 和 Extract 类型来过滤 T1 类型。T2 类型将移除 boolean 类型，而 T3 类型将只保留 string 类型。</p><h3 id="使用-Partial-和-Required-来转换类型"><a href="#使用-Partial-和-Required-来转换类型" class="headerlink" title="使用 Partial 和 Required 来转换类型"></a>使用 Partial 和 Required 来转换类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialPerson</span> = <span class="title class_">Partial</span>&lt;<span class="title class_">Person</span>&gt;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">RequiredPerson</span> = <span class="title class_">Required</span>&lt;<span class="title class_">PartialPerson</span>&gt;;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用 Partial 和 Required 类型来转换类型。PartialPerson 类型将转换为可选的属性，而 RequiredPerson 类型将转换为必填的属性。</p><h3 id="使用-Pick-和-Omit-来选择和排除属性"><a href="#使用-Pick-和-Omit-来选择和排除属性" class="headerlink" title="使用 Pick 和 Omit 来选择和排除属性"></a>使用 Pick 和 Omit 来选择和排除属性</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">address</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PersonNameAge</span> = <span class="title class_">Pick</span>&lt;<span class="title class_">Person</span>, <span class="string">&quot;name&quot;</span> | <span class="string">&quot;age&quot;</span>&gt;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PersonWithoutAddress</span> = <span class="title class_">Omit</span>&lt;<span class="title class_">Person</span>, <span class="string">&quot;address&quot;</span>&gt;;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用 Pick 和 Omit 类型来选择和排除属性。PersonNameAge 类型将只保留 name 和 age 属性，而 PersonWithoutAddress 类型将排除 address 属性。</p><h3 id="使用-as-const-来创建只读数组和对象"><a href="#使用-as-const-来创建只读数组和对象" class="headerlink" title="使用 as const 来创建只读数组和对象"></a>使用 as const 来创建只读数组和对象</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125; <span class="keyword">as</span> <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用 as const 来创建只读数组和对象。arr 和 obj 将不可修改。</p><h3 id="使用-Readonly-来使对象的所有属性变为只读"><a href="#使用-Readonly-来使对象的所有属性变为只读" class="headerlink" title="使用 Readonly 来使对象的所有属性变为只读"></a>使用 Readonly 来使对象的所有属性变为只读</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">address</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReadonlyPerson</span> = <span class="title class_">Readonly</span>&lt;<span class="title class_">Person</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person</span>: <span class="title class_">ReadonlyPerson</span> = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>, <span class="attr">age</span>: <span class="number">30</span>, <span class="attr">address</span>: <span class="string">&quot;123 Main St.&quot;</span> &#125;;</span><br><span class="line">person.<span class="property">age</span> = <span class="number">31</span>; <span class="comment">// Error: Cannot assign to &#x27;age&#x27; because it is a read-only property.</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用 Readonly 来使对象的所有属性变为只读。ReadonlyPerson 类型将具有与 Person 相同的属性，但所有属性都是只读的。</p><h3 id="使用-Required-来使对象的所有属性变为必需的"><a href="#使用-Required-来使对象的所有属性变为必需的" class="headerlink" title="使用 Required 来使对象的所有属性变为必需的"></a>使用 Required 来使对象的所有属性变为必需的</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">  address?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">RequiredPerson</span> = <span class="title class_">Required</span>&lt;<span class="title class_">Person</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person</span>: <span class="title class_">RequiredPerson</span> = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>, <span class="attr">age</span>: <span class="number">30</span>, <span class="attr">address</span>: <span class="string">&quot;123 Main St.&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用 Required 来使对象的所有属性变为必需的。RequiredPerson 类型将具有与 Person 相同的属性，但所有属性都是必需的。</p><h3 id="使用-NonNullable-来移除对象的所有可空属性"><a href="#使用-NonNullable-来移除对象的所有可空属性" class="headerlink" title="使用 NonNullable 来移除对象的所有可空属性"></a>使用 NonNullable 来移除对象的所有可空属性</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span> | <span class="literal">null</span>;</span><br><span class="line">  address?: <span class="built_in">string</span> | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NonNullablePerson</span> = <span class="title class_">NonNullable</span>&lt;<span class="title class_">Person</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person</span>: <span class="title class_">NonNullablePerson</span> = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>, <span class="attr">age</span>: <span class="number">30</span>, <span class="attr">address</span>: <span class="string">&quot;123 Main St.&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;概览：在实际的开发工作过程中，积累了一些常见又超级好用的 typescript 技巧和代码片段，包括整理的其他大神的ts使用技巧，今天筛选了 10+ 个，以供大家参考。&lt;/p&gt;
&lt;h3 id=&quot;使用交叉类型来合并多个类型&quot;&gt;&lt;a href=&quot;#使用交叉类型来合并多个类型&quot; </summary>
      
    
    
    
    <category term="js" scheme="http://example.com/categories/js/"/>
    
    
    <category term="typescript" scheme="http://example.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>[译] ECMAScript 2023有哪些新特性</title>
    <link href="http://example.com/2023/04/20/javascript/"/>
    <id>http://example.com/2023/04/20/javascript/</id>
    <published>2023-04-20T03:01:42.000Z</published>
    <updated>2023-04-20T03:01:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em><a href="https://pawelgrzybek.com/whats-new-in-ecmascript-2023">原文 What’s new in ECMAScript 2023</a></em><br>2023.4.18 by Pawel</p></blockquote><p>在阅读了<a href="https://github.com/tc39/notes/tree/main/meetings/2023-03">上一次 TC39 </a>会议的记录之后，似乎已经知道了即将推出的 JavaScript 的新功能列表。ECMAScript规范的最终版本预计将在 6 月底发布。</p><blockquote><p>最后而且最重要的是，我们正在削减 ES2023。我们将其冻结，或者更确切地说，我应该说我们已经将其冻结。我们不希望再有任何重大的编辑性变化。可能会有至少几个非常小的编辑性微调，但没有大的变化。</p></blockquote><p>让我分享一下所有达到第4阶段的新功能列表，这些功能预计将包含在即将推出的ECMAScript版本中。就像我在<a href="https://pawelgrzybek.com/whats-new-in-ecmascript-2022/">2022</a>、 <a href="https://pawelgrzybek.com/whats-new-in-ecmascript-2021/">2021</a>、 <a href="https://pawelgrzybek.com/whats-new-in-ecmascript-2020/">2020</a>、 <a href="https://pawelgrzybek.com/whats-new-in-ecmascript-2019/">2019</a>、 <a href="https://pawelgrzybek.com/whats-new-in-ecmascript-2018/">2018</a>,、<a href="https://pawelgrzybek.com/whats-new-in-ecmascript-2017/">2017</a> 和 <a href="https://pawelgrzybek.com/whats-new-in-ecmascript-2016-es7/">2016</a> 年所做的那样。</p><ul><li><a href="https://pawelgrzybek.com/whats-new-in-ecmascript-2023/#array-find-from-last">从后向前查找数组元素</a></li><li><a href="https://pawelgrzybek.com/whats-new-in-ecmascript-2023/#hashbang-grammar">Hashbang语法</a></li><li><a href="https://pawelgrzybek.com/whats-new-in-ecmascript-2023/#symbols-as-weakmap-keys">Symbol作为WeakMap键</a></li><li><a href="https://pawelgrzybek.com/whats-new-in-ecmascript-2023/#change-array-by-copy">通过复制改变数组</a></li></ul><h3 id="从后向前查找数组元素"><a href="#从后向前查找数组元素" class="headerlink" title="从后向前查找数组元素"></a>从后向前查找数组元素</h3><p><a href="https://github.com/tc39/proposal-array-find-from-last">由Wenlu Wang提出的“从后向前查找数组元素”提案</a>在Array和TypedArray原型上添加了findLast()和findLastIndex()方法。它们与find()和findIndex()方法具有相同的功能，但顺序相反。这两种方法很方便，让我们避免创建临时副本、突变和混淆的索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const isEven = (number) =&gt; number % 2 === 0;</span><br><span class="line">const numbers = [1, 2, 3, 4];</span><br><span class="line">​</span><br><span class="line">// 从第一个到最后一个查找</span><br><span class="line">console.log(numbers.find(isEven));</span><br><span class="line">// 2</span><br><span class="line">console.log(numbers.findIndex(isEven));</span><br><span class="line">// 1</span><br><span class="line">​</span><br><span class="line">// 从最后一个到第一个查找</span><br><span class="line">console.log(numbers.findLast(isEven));</span><br><span class="line">// 4</span><br><span class="line">console.log(numbers.findLastIndex(isEven));</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure><h3 id="Hashbang语法"><a href="#Hashbang语法" class="headerlink" title="Hashbang语法"></a>Hashbang语法</h3><p><a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">Hashbang，也称为shebang</a> ，是可执行脚本开头的一系列字符，用于定义要运行的程序的解释器。当Unix内核的程序加载器执行JavaScript程序时，主机会剥离hashbang以生成有效的源代码，然后将其传递给引擎。Bradley Farias提出的Hashbang语法提案规范了这个过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env node</span><br><span class="line">​</span><br><span class="line">console.log(&#x27;hi 👋&#x27;);</span><br></pre></td></tr></table></figure><h3 id="Symbol作为WeakMap键"><a href="#Symbol作为WeakMap键" class="headerlink" title="Symbol作为WeakMap键"></a>Symbol作为WeakMap键</h3><p>在JavaScript中，对象和Symbol保证是唯一的，不能重新创建，这使它们都成为WeakMap键的理想候选者。先前的版本或规范只允许使用对象作为键，但幸运的是，由Daniel Ehrenberg、Richard Button、Robin Ricard、Leo Balter、Rick Waldron和Caridy Patiño提出的Symbol作为WeakMap键提案将未注册的Symbol添加到允许的键列表中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const weak = new WeakMap();</span><br><span class="line">const key = Symbol(&quot;ref&quot;);</span><br><span class="line">weak.set(key, &quot;ECMAScript 2023&quot;);</span><br><span class="line">​</span><br><span class="line">console.log(weak.get(key));</span><br><span class="line">// ECMAScript 2023</span><br></pre></td></tr></table></figure><h3 id="通过复制改变数组"><a href="#通过复制改变数组" class="headerlink" title="通过复制改变数组"></a>通过复制改变数组</h3><p><code>Array.prototype</code> 上的 <code>reverse()</code>、<code>sort()</code> 和 <code>splice()</code> 方法会就地突变数组。<a href="https://github.com/tc39/proposal-change-array-by-copy">Ashley Claymore 和 Robin Ricard 提出的 Change Array by Copy proposal</a> 添加了 <code>toReversed()</code>、<code>toSorted()</code> 和 <code>toSpliced()</code> 方法的副本，它们会返回一个新的数组。此提议还添加了一个 <code>with()</code> 方法，该方法返回一个新数组，其中给定索引处的元素用给定值替换，以避免使用括号表示法进行就地突变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">const original = [1, 2, 3, 4];</span><br><span class="line">const reversed = original.toReversed();</span><br><span class="line">​</span><br><span class="line">console.log(original);</span><br><span class="line">// [ 1, 2, 3, 4 ]</span><br><span class="line">​</span><br><span class="line">console.log(reversed);</span><br><span class="line">// [ 4, 3, 2, 1 ]</span><br><span class="line">const original = [1, 3, 2, 4];</span><br><span class="line">const sorted = original.toSorted();</span><br><span class="line">​</span><br><span class="line">console.log(original);</span><br><span class="line">// [ 1, 3, 2, 4 ]</span><br><span class="line">​</span><br><span class="line">console.log(sorted);</span><br><span class="line">// [ 1, 2, 3, 4 ]</span><br><span class="line">const original = [1, 4];</span><br><span class="line">const spliced = original.toSpliced(1, 0, 2, 3);</span><br><span class="line">​</span><br><span class="line">console.log(original);</span><br><span class="line">// [ 1, 4 ]</span><br><span class="line">​</span><br><span class="line">console.log(spliced);</span><br><span class="line">// [ 1, 2, 3, 4 ]</span><br><span class="line">const original = [1, 2, 2, 4];</span><br><span class="line">const withThree = original.with(2, 3);</span><br><span class="line">​</span><br><span class="line">console.log(original);</span><br><span class="line">// [ 1, 2, 2, 4 ]</span><br><span class="line">​</span><br><span class="line">console.log(withThree);</span><br><span class="line">// [ 1, 2, 3, 4 ]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://pawelgrzybek.com/whats-new-in-ecmascript-2023&quot;&gt;原文 What’s new in ECMAScript 2023&lt;/a&gt;&lt;/em&gt;&lt;br&gt;2023.4.18 b</summary>
      
    
    
    
    <category term="js" scheme="http://example.com/categories/js/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>10个超级实用的reduce使用技巧</title>
    <link href="http://example.com/2023/04/20/reduce/"/>
    <id>http://example.com/2023/04/20/reduce/</id>
    <published>2023-04-20T03:01:42.000Z</published>
    <updated>2023-04-20T03:01:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>reduce 函数可以根据需要进行累加、过滤、分组、映射等操作，是一个非常强大的数组方法。在数据处理时使用的非常频繁，很多复杂的逻辑如果用reduce去处理，都非常的简洁，在实际的开发工作过程中，积累了一些常见又超级好用的 reduce 技巧的代码片段，筛选了如下 10 个，以供大家参考</p><h3 id="reduce-介绍"><a href="#reduce-介绍" class="headerlink" title="reduce 介绍"></a>reduce 介绍</h3><p><code>reduce</code> 是数组的方法，可以对数组中的每个元素依次执行一个回调函数，从左到右依次累积计算出一个最终的值。其语法为：</p><blockquote><p>arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</p></blockquote><p>其中，<code>callback</code> 是每个元素执行的回调函数，其包含 4 个参数：</p><ul><li><code>accumulator</code>：累积器，即上一次回调函数执行的返回值。</li><li><code>currentValue</code>：当前元素的值。</li><li><code>index</code>：当前元素的下标。</li><li><code>array</code>：原始数组。</li></ul><p><code>initialValue</code> 是可选的，表示累积器的初始值。</p><p><code>reduce</code> 函数的执行过程如下：</p><ol><li>如果没有提供 <code>initialValue</code>，则将数组的第一个元素作为累积器的初始值，否则将 <code>initialValue</code> 作为累积器的初始值。</li><li>从数组的第二个元素开始，依次对数组中的每个元素执行回调函数。</li><li>回调函数的返回值作为下一次回调函数执行时的累积器的值。</li><li>对数组中的每个元素执行完回调函数后，<code>reduce</code> 函数返回最后一次回调函数的返回值，即最终的累积值。</li></ol><h3 id="计算数组中每个元素出现的次数"><a href="#计算数组中每个元素出现的次数" class="headerlink" title="计算数组中每个元素出现的次数"></a>计算数组中每个元素出现的次数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> count = fruits.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">  accumulator[currentValue] = (accumulator[currentValue] || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> accumulator;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count); <span class="comment">// Output: &#123; apple: 3, banana: 2, orange: 1 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="拍平嵌套数组"><a href="#拍平嵌套数组" class="headerlink" title="拍平嵌套数组"></a>拍平嵌套数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nestedArray = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line"><span class="keyword">const</span> flattenedArray = nestedArray.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> accumulator.<span class="title function_">concat</span>(currentValue), []);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flattenedArray); <span class="comment">// Output: [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><h3 id="按条件分组"><a href="#按条件分组" class="headerlink" title="按条件分组"></a>按条件分组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;Charlie&#x27;</span>, <span class="attr">age</span>: <span class="number">35</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;David&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;Emily&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> groupedPeople = people.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> key = currentValue.<span class="property">age</span>;</span><br><span class="line">  <span class="keyword">if</span> (!accumulator[key]) &#123;</span><br><span class="line">    accumulator[key] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  accumulator[key].<span class="title function_">push</span>(currentValue);</span><br><span class="line">  <span class="keyword">return</span> accumulator;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(groupedPeople);</span><br><span class="line"><span class="comment">// Output: &#123;</span></span><br><span class="line"><span class="comment">//   25: [&#123; name: &#x27;Alice&#x27;, age: 25 &#125;, &#123; name: &#x27;David&#x27;, age: 25 &#125;],</span></span><br><span class="line"><span class="comment">//   30: [&#123; name: &#x27;Bob&#x27;, age: 30 &#125;, &#123; name: &#x27;Emily&#x27;, age: 30 &#125;],</span></span><br><span class="line"><span class="comment">//   35: [&#123; name: &#x27;Charlie&#x27;, age: 35 &#125;]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h3 id="将多个数组合并为一个对象"><a href="#将多个数组合并为一个对象" class="headerlink" title="将多个数组合并为一个对象"></a>将多个数组合并为一个对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> keys = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> values = [<span class="string">&#x27;Alice&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;female&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> person = keys.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue, index</span>) =&gt;</span> &#123;</span><br><span class="line">    accumulator[currentValue] = values[index];</span><br><span class="line">    <span class="keyword">return</span> accumulator;</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// Output: &#123; name: &#x27;Alice&#x27;, age: 25, gender: &#x27;female&#x27; &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="将字符串转换为对象"><a href="#将字符串转换为对象" class="headerlink" title="将字符串转换为对象"></a>将字符串转换为对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;key1=value1&amp;key2=value2&amp;key3=value3&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> obj = str.<span class="title function_">split</span>(<span class="string">&#x27;&amp;&#x27;</span>).<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [key, value] = currentValue.<span class="title function_">split</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">  accumulator[key] = value;</span><br><span class="line">  <span class="keyword">return</span> accumulator;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); </span><br><span class="line"><span class="comment">// Output: &#123; key1: &#x27;value1&#x27;, key2: &#x27;value2&#x27;, key3: &#x27;value3&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h3 id="将对象转换为查询字符串"><a href="#将对象转换为查询字符串" class="headerlink" title="将对象转换为查询字符串"></a>将对象转换为查询字符串</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> params = &#123; <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> queryString = <span class="title class_">Object</span>.<span class="title function_">entries</span>(params).<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, [key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;acc&#125;</span><span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;value&#125;</span>&amp;`</span>;</span><br><span class="line">&#125;, <span class="string">&quot;?&quot;</span>).<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queryString); <span class="comment">// &quot;?foo=bar&amp;baz=42&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="打印斐波那契数列"><a href="#打印斐波那契数列" class="headerlink" title="打印斐波那契数列"></a>打印斐波那契数列</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fibonacci</span> = n =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> [...<span class="title class_">Array</span>(n)].<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      accumulator.<span class="title function_">push</span>(index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      accumulator.<span class="title function_">push</span>(accumulator[index - <span class="number">1</span>] + accumulator[index - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> accumulator;</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fibonacci</span>(<span class="number">10</span>)); <span class="comment">// Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span></span><br></pre></td></tr></table></figure><h3 id="检查字符串是否是回文字符串"><a href="#检查字符串是否是回文字符串" class="headerlink" title="检查字符串是否是回文字符串"></a>检查字符串是否是回文字符串</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;racecar&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> isPalindrome = str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator &amp;&amp; currentValue === array[array.<span class="property">length</span> - index - <span class="number">1</span>];</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(isPalindrome); <span class="comment">// Output: true</span></span><br></pre></td></tr></table></figure><h3 id="检查括号是否匹配"><a href="#检查括号是否匹配" class="headerlink" title="检查括号是否匹配"></a>检查括号是否匹配</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;(()()())&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> balanced = str.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (cur === <span class="string">&quot;(&quot;</span>) &#123;</span><br><span class="line">    acc++;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur === <span class="string">&quot;)&quot;</span>) &#123;</span><br><span class="line">    acc--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> acc;</span><br><span class="line">&#125;, <span class="number">0</span>) === <span class="number">0</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(balanced); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="递归获取对象属性"><a href="#递归获取对象属性" class="headerlink" title="递归获取对象属性"></a>递归获取对象属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">info</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Jason&quot;</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123; <span class="attr">home</span>: <span class="string">&quot;Shaanxi&quot;</span>, <span class="attr">company</span>: <span class="string">&quot;Xian&quot;</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">config, path, defaultVal</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> path.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_">reduce</span>(<span class="function">(<span class="params">config, name</span>) =&gt;</span> config[name], config) || defaultVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">get</span>(user, <span class="string">&quot;info.name&quot;</span>); <span class="comment">// Jason</span></span><br><span class="line"><span class="title function_">get</span>(user, <span class="string">&quot;info.address.home&quot;</span>); <span class="comment">// Shaanxi</span></span><br><span class="line"><span class="title function_">get</span>(user, <span class="string">&quot;info.address.company&quot;</span>); <span class="comment">// Xian</span></span><br><span class="line"><span class="title function_">get</span>(user, <span class="string">&quot;info.address.abc&quot;</span>, <span class="string">&quot;default&quot;</span>); <span class="comment">// default</span></span><br></pre></td></tr></table></figure><h3 id="手写-reduce"><a href="#手写-reduce" class="headerlink" title="手写 reduce"></a>手写 reduce</h3><p>可以通过手写一个简单的 <code>reduce</code> 函数来更好地理解它的实现原理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myReduce</span>(<span class="params">arr, callback, initialValue</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> accumulator = initialValue === <span class="literal">undefined</span> ? arr[<span class="number">0</span>] : initialValue;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = initialValue === <span class="literal">undefined</span> ? <span class="number">1</span> : <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    accumulator = <span class="title function_">callback</span>(accumulator, arr[i], i, arr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> accumulator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，<code>myReduce</code> 函数接受 3 个参数：要执行 <code>reduce</code> 操作的数组 <code>arr</code>、回调函数 <code>callback</code> 和累积器的初始值 <code>initialValue</code>。如果没有提供初始值，则将数组的第一个元素作为累积器的初始值。</p><p>接下来，在循环中，如果有 initialValue，则从第一个元素开始遍历 callback，此时 callabck 的第二个参数是从数组的第一项开始的；如果没有 initialValue，则从第二个元素开始遍历 callback，此时 callback 的第二个参数是从数组的第二项开始的从数组的第二个元素开始，依次对数组中的每个元素执行回调函数，并将返回值作为下一次回调函数执行时的累积器的值。</p><p>最后，<code>myReduce</code> 函数返回最后一次回调函数的返回值，即最终的累积值。</p><p>这个简易的 <code>reduce</code> 函数并没有考虑很多边界情况和复杂的应用场景，但是可以帮助我们更好地理解 <code>reduce</code> 函数的实现原理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;reduce 函数可以根据需要进行累加、过滤、分组、映射等操作，是一个非常强大的数组方法。在数据处理时使用的非常频繁，很多复杂的逻辑如果用reduce去处理，都非常的简洁，在实际的开发工作过程中，积累了一些常见又超级好用的 reduce 技巧的代码片段，筛选了如下 10 个</summary>
      
    
    
    
    <category term="js" scheme="http://example.com/categories/js/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
    <category term="reduce" scheme="http://example.com/tags/reduce/"/>
    
  </entry>
  
  <entry>
    <title>10个超级实用的Set、Map使用技巧</title>
    <link href="http://example.com/2023/04/20/set-map/"/>
    <id>http://example.com/2023/04/20/set-map/</id>
    <published>2023-04-20T03:01:42.000Z</published>
    <updated>2023-04-20T03:01:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>Set是一种类似于数组的数据结构，但是它的值是唯一的，即Set中的每个值只会出现一次。Set对象的实例可以用于存储任何类型的唯一值，从而使它们非常适用于去重。</p><p>Map是一种键值对集合，其中每个键都是唯一的，可以是任何类型，而值则可以是任何类型。Map对象的实例可以用于存储复杂的对象，并且可以根据键进行快速的查找和访问。</p><p>以下是Set和Map的一些常用方法：</p><p>Set:</p><ul><li>new Set(): 创建一个新的Set对象</li><li>add(value): 向Set对象中添加一个新的值</li><li>delete(value): 从Set对象中删除一个值</li><li>has(value): 检查Set对象中是否存在指定的值</li><li>size: 获取Set对象中的值的数量</li><li>clear(): 从Set对象中删除所有值</li></ul><p>Map:</p><ul><li>new Map(): 创建一个新的Map对象</li><li>set(key, value): 向Map对象中添加一个键值对</li><li>get(key): 根据键获取Map对象中的值</li><li>delete(key): 从Map对象中删除一个键值对</li><li>has(key): 检查Map对象中是否存在指定的键</li><li>size: 获取Map对象中的键值对数量</li><li>clear(): 从Map对象中删除所有键值对</li></ul><p>Set和Map是非常有用的数据结构，它们可以提高程序的性能和可读性，并且可以简化代码的编写。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h4><p>使用 Set 可以轻松地进行数组去重操作，因为 Set 只能存储唯一的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> uniqueArr = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uniqueArr); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h4 id="数组转换"><a href="#数组转换" class="headerlink" title="数组转换"></a>数组转换</h4><p>可以使用 Set 将数组转换为不包含重复元素的 Set 对象，再使用 Array.from() 将其转换回数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(arr);</span><br><span class="line"><span class="keyword">const</span> uniqueArr = <span class="title class_">Array</span>.<span class="title function_">from</span>(set);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uniqueArr); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h4 id="优化数据查找"><a href="#优化数据查找" class="headerlink" title="优化数据查找"></a>优化数据查找</h4><p>使用 Set 存储数据时，查找操作的时间复杂度为 O(1)，比数组的 O(n) 要快得多，因此可以使用 Set 来优化数据查找的效率。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dataSet = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dataSet.<span class="title function_">has</span>(<span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据已经存在&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据不存在&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="并集、交集、差集"><a href="#并集、交集、差集" class="headerlink" title="并集、交集、差集"></a>并集、交集、差集</h4><p>Set数据结构可以用于计算两个集合的并集、交集和差集。以下是一些使用Set进行集合运算的示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">const</span> union = <span class="keyword">new</span> <span class="title class_">Set</span>([...setA, ...setB]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(union); <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">const</span> intersection = <span class="keyword">new</span> <span class="title class_">Set</span>([...setA].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> setB.<span class="title function_">has</span>(x)));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(intersection); <span class="comment">// Set &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">const</span> difference = <span class="keyword">new</span> <span class="title class_">Set</span>([...setA].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> !setB.<span class="title function_">has</span>(x)));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(difference); <span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure><h4 id="模糊搜索"><a href="#模糊搜索" class="headerlink" title="模糊搜索"></a>模糊搜索</h4><p>Set 还可以通过正则表达式实现模糊搜索。可以将匹配结果保存到 Set 中，然后使用 Array.from() 方法将 Set 转换成数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索以 &quot;a&quot; 开头的水果</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(data.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="regexp">/^a/i</span>.<span class="title function_">test</span>(item))));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// [&quot;apple&quot;]</span></span><br></pre></td></tr></table></figure><h4 id="使用-Set-替代数组实现队列和栈"><a href="#使用-Set-替代数组实现队列和栈" class="headerlink" title="使用 Set 替代数组实现队列和栈"></a>使用 Set 替代数组实现队列和栈</h4><p>可以使用 Set 来模拟队列和栈的数据结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Set 实现队列</span></span><br><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">queue.<span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line">queue.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line">queue.<span class="title function_">add</span>(<span class="number">3</span>);</span><br><span class="line">queue.<span class="title function_">delete</span>(queue.<span class="title function_">values</span>().<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 删除第一个元素</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue); <span class="comment">// Set(2) &#123; 2, 3 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Set 实现栈</span></span><br><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">stack.<span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line">stack.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line">stack.<span class="title function_">add</span>(<span class="number">3</span>);</span><br><span class="line">stack.<span class="title function_">delete</span>([...stack][stack.<span class="property">size</span> - <span class="number">1</span>]); <span class="comment">// 删除最后一个元素</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack); <span class="comment">// Set(2) &#123; 1, 2 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="将-Map-转换为对象"><a href="#将-Map-转换为对象" class="headerlink" title="将 Map 转换为对象"></a>将 Map 转换为对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;value1&#x27;</span>).<span class="title function_">set</span>(<span class="string">&#x27;key2&#x27;</span>, <span class="string">&#x27;value2&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(map);</span><br></pre></td></tr></table></figure><h4 id="将-Map-转换为数组"><a href="#将-Map-转换为数组" class="headerlink" title="将 Map 转换为数组"></a>将 Map 转换为数组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;value1&#x27;</span>).<span class="title function_">set</span>(<span class="string">&#x27;key2&#x27;</span>, <span class="string">&#x27;value2&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> array = <span class="title class_">Array</span>.<span class="title function_">from</span>(map);</span><br></pre></td></tr></table></figure><h4 id="记录数据的顺序"><a href="#记录数据的顺序" class="headerlink" title="记录数据的顺序"></a>记录数据的顺序</h4><p>如果你需要记录添加元素的顺序，那么可以使用<code>Map</code>来解决这个问题。当你需要按照添加顺序迭代元素时，可以使用<code>Map</code>来保持元素的顺序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;d&#x27;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output: a 1, b 2, c 3, d 4</span></span><br></pre></td></tr></table></figure><h4 id="统计数组中元素出现次数"><a href="#统计数组中元素出现次数" class="headerlink" title="统计数组中元素出现次数"></a>统计数组中元素出现次数</h4><p>可以使用 Map 统计数组中每个元素出现的次数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> countMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  countMap.<span class="title function_">set</span>(item, (countMap.<span class="title function_">get</span>(item) || <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(countMap.<span class="title function_">get</span>(<span class="number">1</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(countMap.<span class="title function_">get</span>(<span class="number">2</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(countMap.<span class="title function_">get</span>(<span class="number">3</span>)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h4 id="统计字符出现次数"><a href="#统计字符出现次数" class="headerlink" title="统计字符出现次数"></a>统计字符出现次数</h4><p>使用Map数据结构可以方便地统计字符串中每个字符出现的次数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> charCountMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> str) &#123;</span><br><span class="line">  charCountMap.<span class="title function_">set</span>(char, (charCountMap.<span class="title function_">get</span>(char) || <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(charCountMap); <span class="comment">// Map &#123; &#x27;h&#x27; =&gt; 1, &#x27;e&#x27; =&gt; 1, &#x27;l&#x27; =&gt; 3, &#x27;o&#x27; =&gt; 2, &#x27; &#x27; =&gt; 1, &#x27;w&#x27; =&gt; 1, &#x27;r&#x27; =&gt; 1, &#x27;d&#x27; =&gt; 1 &#125;</span></span><br></pre></td></tr></table></figure><h4 id="缓存计算结果"><a href="#缓存计算结果" class="headerlink" title="缓存计算结果"></a>缓存计算结果</h4><p>在处理复杂的计算时，可能需要对中间结果进行缓存以提高性能。可以使用Map数据结构缓存计算结果，以避免重复计算。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span> || n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cache.<span class="title function_">has</span>(n)) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache.<span class="title function_">get</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title function_">fibonacci</span>(n - <span class="number">1</span>) + <span class="title function_">fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">  cache.<span class="title function_">set</span>(n, result);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fibonacci</span>(<span class="number">10</span>)); <span class="comment">// 55</span></span><br></pre></td></tr></table></figure><h4 id="使用-Map-进行数据的分组"><a href="#使用-Map-进行数据的分组" class="headerlink" title="使用 Map 进行数据的分组"></a>使用 Map 进行数据的分组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> students = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Tom&quot;</span>, <span class="attr">grade</span>: <span class="string">&quot;A&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Jerry&quot;</span>, <span class="attr">grade</span>: <span class="string">&quot;B&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Kate&quot;</span>, <span class="attr">grade</span>: <span class="string">&quot;A&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Mike&quot;</span>, <span class="attr">grade</span>: <span class="string">&quot;C&quot;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gradeMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">students.<span class="title function_">forEach</span>(<span class="function">(<span class="params">student</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> grade = student.<span class="property">grade</span>;</span><br><span class="line">  <span class="keyword">if</span> (!gradeMap.<span class="title function_">has</span>(grade)) &#123;</span><br><span class="line">    gradeMap.<span class="title function_">set</span>(grade, [student]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    gradeMap.<span class="title function_">get</span>(grade).<span class="title function_">push</span>(student);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gradeMap.<span class="title function_">get</span>(<span class="string">&quot;A&quot;</span>)); <span class="comment">// [&#123; name: &quot;Tom&quot;, grade: &quot;A&quot; &#125;, &#123; name: &quot;Kate&quot;, grade: &quot;A&quot; &#125;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="使用-Map-过滤符合条件的对象"><a href="#使用-Map-过滤符合条件的对象" class="headerlink" title="使用 Map 过滤符合条件的对象"></a>使用 Map 过滤符合条件的对象</h4><p>在实际开发中，我们常常需要在一个对象数组中查找符合某些条件的对象。此时，我们可以结合使用 Map 和 filter 方法来实现。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;Charlie&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> userMap = <span class="keyword">new</span> <span class="title class_">Map</span>(users.<span class="title function_">map</span>(<span class="function"><span class="params">user</span> =&gt;</span> [user.<span class="property">name</span>, user]));</span><br><span class="line"><span class="keyword">const</span> result = users.<span class="title function_">filter</span>(<span class="function"><span class="params">user</span> =&gt;</span> userMap.<span class="title function_">has</span>(user.<span class="property">name</span>) &amp;&amp; user.<span class="property">age</span> &gt; <span class="number">20</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// [&#123; name: &#x27;Alice&#x27;, age: 22 &#125;, &#123; name: &#x27;Charlie&#x27;, age: 25 &#125;]</span></span><br></pre></td></tr></table></figure><p>首先，我们将对象数组转换为 Map，以便快速查找。然后，我们使用 filter 方法来过滤符合条件的对象。</p><p>这里我们列举了一些使用<code>Set</code>和<code>Map</code>的实用技巧，它们可以大大简化你的代码，并使你更有效地处理数据。<code>Set</code>和<code>Map</code>是JavaScript中非常有用的数据结构，值得我们在编写代码时好好利用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Set是一种类似于数组的数据结构，但是它的值是唯一的，即Set中的每个值只会出现一次。Set对象的实例可以用于存储任何类型的唯一值，从而使它们非常适用于去重。&lt;/p&gt;
&lt;p&gt;Map是一种键值对集合，其中每个键都是唯一的，可以是任何类型，而值则可以是任何类型。Map对象的实例</summary>
      
    
    
    
    <category term="js" scheme="http://example.com/categories/js/"/>
    
    
    <category term="ES6" scheme="http://example.com/tags/ES6/"/>
    
    <category term="set" scheme="http://example.com/tags/set/"/>
    
    <category term="map" scheme="http://example.com/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>Vuex 3 vs Vuex 4：差异对比</title>
    <link href="http://example.com/2023/04/18/vuex3-4/"/>
    <id>http://example.com/2023/04/18/vuex3-4/</id>
    <published>2023-04-18T03:01:42.000Z</published>
    <updated>2023-04-18T03:01:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>Vuex 是 Vue.js 的官方状态管理库，用于在 Vue.js 应用中管理应用状态。Vuex 3 是用于 Vue 2 的版本，而 Vuex 4 是用于 Vue 3 的版本。下面是 Vuex 3 和 Vuex 4 在一些重要方面的异同点：</p><h3 id="创建-Store-的方式"><a href="#创建-Store-的方式" class="headerlink" title="创建 Store 的方式"></a>创建 Store 的方式</h3><ul><li>Vuex 3：使用 <code>new Vuex.Store()</code> 创建 store 实例</li></ul><!----><pre><code>import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;​Vue.use(Vuex)​const store = new Vuex.Store(&#123;  // 配置项&#125;)​export default store</code></pre><ul><li>Vuex 4：使用 <code>createStore</code> 函数创建 store 实例</li></ul><!----><pre><code>import &#123; createStore &#125; from &#39;vuex&#39;​const store = createStore(&#123;  // 配置项&#125;)​export default store</code></pre><p>Vuex 4 中使用 <code>createStore</code> 函数来创建 store 实例，而不是直接在 Vue 实例上挂载。</p><h3 id="在组件中使用-Store"><a href="#在组件中使用-Store" class="headerlink" title="在组件中使用 Store"></a>在组件中使用 Store</h3><ul><li>Vuex 3：使用 <code>this.$store</code> 访问 store 实例，通过 <code>this.$store.state</code> 访问状态，通过 <code>this.$store.commit()</code> 进行提交 mutation，通过 <code>this.$store.dispatch()</code> 进行分发 action。</li></ul><!----><pre><code>export default &#123;  computed: &#123;    count() &#123;      return this.$store.state.count    &#125;  &#125;,  methods: &#123;    increment() &#123;      this.$store.commit(&#39;increment&#39;)    &#125;,    incrementAsync() &#123;      this.$store.dispatch(&#39;incrementAsync&#39;)    &#125;  &#125;&#125;</code></pre><ul><li>Vuex 4：使用 <code>useStore</code> 函数来获取 store 实例，通过 <code>store.state</code> 访问状态，通过 <code>store.commit()</code> 进行提交 mutation，通过 <code>store.dispatch()</code> 进行分发 action。</li></ul><!----><pre><code>import &#123; useStore &#125; from &#39;vuex&#39;​export default &#123;  setup() &#123;    const store = useStore()    const count = computed(() =&gt; store.state.count)​    const increment = () =&gt; &#123;      store.commit(&#39;increment&#39;)    &#125;​    const incrementAsync = () =&gt; &#123;      store.dispatch(&#39;incrementAsync&#39;)    &#125;​    return &#123;      count,      increment,      incrementAsync    &#125;  &#125;&#125;</code></pre><p>虽然 Vuex4 推荐使用更符合 Composition API 风格的 <code>useStore()</code> 来获取 <code>store</code> 实例。但是并没有移除 <code>this.$store</code>，但是在 <code>&lt;template&gt;</code> 和 <code>Vue2</code> 选项式写法中还是支持使用 <code>$store</code> 的。</p><h3 id="辅助函数的用法"><a href="#辅助函数的用法" class="headerlink" title="辅助函数的用法"></a>辅助函数的用法</h3><ul><li>Vuex 3：使用 <code>mapState</code>、<code>mapGetters</code>、<code>mapMutations</code> 和 <code>mapActions</code> 辅助函数来进行映射，简化在组件中对 store 的访问。</li></ul><!----><pre><code>import &#123; mapState, mapGetters, mapMutations, mapActions &#125; from &#39;vuex&#39;​export default &#123;  computed: &#123;    ...mapState([&#39;count&#39;]),    ...mapGetters([&#39;doubleCount&#39;]),  &#125;,  methods: &#123;    ...mapMutations([&#39;increment&#39;]),    ...mapActions([&#39;incrementAsync&#39;]),  &#125;&#125;</code></pre><ul><li>Vuex 4：使用 Composition API 中的 <code>computed</code> 函数和普通的 JavaScript 函数来实现类似的功能。</li></ul><!----><pre><code>import &#123; computed, useStore &#125; from &#39;vuex&#39;​export default &#123;  setup() &#123;    const store = useStore()​    const count = computed(() =&gt; store.state.count)    const doubleCount = computed(() =&gt; store.getters.doubleCount)​    const increment = () =&gt; &#123;      store.commit(&#39;increment&#39;)    &#125;​    const incrementAsync = () =&gt; &#123;      store.dispatch(&#39;incrementAsync&#39;)    &#125;​    return &#123;      count,      doubleCount,      increment,      incrementAsync    &#125;  &#125;&#125;</code></pre><p>Vuex4 支持选项式写法的辅助函数，在使用时和 Vuex3 一模一样的。但是需要注意辅助函数不能在组合式写法 <code>setup</code> 中使用。</p><h3 id="响应式的改进"><a href="#响应式的改进" class="headerlink" title="响应式的改进"></a>响应式的改进</h3><ul><li>Vuex 3：使用 Vue 2 的响应式系统 ( Object.defineProperty ) 进行状态的监听和更新。</li><li>Vuex 4：使用 Vue 3 的响应式系统 ( proxy ) 进行状态的监听和更新，可以利用 Composition API 中的 <code>reactive</code> 和 <code>computed</code> 函数进行更加灵活和高效的状态管理。</li></ul><p>实质上这是 Vue2 和 Vue3 的区别，只是由于 Vue 2 匹配的 Vuex 3，Vue 3 匹配的 Vuex 4 的原因，严格来说不能算作 Vuex3 与 Vuex4 的不同。</p><h3 id="Vuex4-支持多例模式"><a href="#Vuex4-支持多例模式" class="headerlink" title="Vuex4 支持多例模式"></a>Vuex4 支持多例模式</h3><p>Vuex 3 是单例模式的，即整个应用只能有一个全局的 Vuex Store 实例。而在 Vuex 4 中，你可以通过 <code>useStore</code> 函数在不同组件中创建多个独立的 Vuex Store 实例，从而支持多例模式。</p><p>以下是一个示例展示了如何在 Vuex 4 中使用 <code>useStore</code> 辅助函数创建多个独立的 Vuex Store 实例：</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;p&gt;Counter 1: &#123;&#123; counter1 &#125;&#125;&lt;/p&gt;    &lt;p&gt;Counter 2: &#123;&#123; counter2 &#125;&#125;&lt;/p&gt;    &lt;button @click=&quot;incrementCounter1&quot;&gt;Increment Counter 1&lt;/button&gt;    &lt;button @click=&quot;incrementCounter2&quot;&gt;Increment Counter 2&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;​&lt;script&gt;import &#123; useStore &#125; from &#39;vuex&#39;​export default &#123;  setup() &#123;    // 使用 useStore 辅助函数创建 Vuex Store 实例    const store1 = useStore(&#39;store1&#39;)    const store2 = useStore(&#39;store2&#39;)​    // 通过 store1.state.count 获取第一个 Store 的状态    const count1 = store1.state.count    // 通过 store2.state.count 获取第二个 Store 的状态    const count2 = store2.state.count​    // 通过 store1.commit() 提交 mutations 到第一个 Store    const incrementCounter1 = () =&gt; &#123;      store1.commit(&#39;increment&#39;)    &#125;​    // 通过 store2.commit() 提交 mutations 到第二个 Store    const incrementCounter2 = () =&gt; &#123;      store2.commit(&#39;increment&#39;)    &#125;​    return &#123;      count1,      count2,      incrementCounter1,      incrementCounter2    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><p>上述示例展示了如何在 Vue 组件中使用 <code>useStore</code> 辅助函数创建多个独立的 Vuex Store 实例，并通过这些实例分别访问和修改各自的状态和 mutations。这是 Vuex 4 相对于 Vuex 3 的一个重要的改进，使得 Vuex 在支持多例模式的场景下更加灵活和可扩展。</p><p>参考链接：</p><ol><li>Vuex 4 官方文档：<a href="https://vuex.vuejs.org/zh/">https://vuex.vuejs.org/zh/</a></li><li>Vuex 3 官方文档：<a href="https://v3.vuex.vuejs.org/zh/">https://v3.vuex.vuejs.org/zh/</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Vuex 是 Vue.js 的官方状态管理库，用于在 Vue.js 应用中管理应用状态。Vuex 3 是用于 Vue 2 的版本，而 Vuex 4 是用于 Vue 3 的版本。下面是 Vuex 3 和 Vuex 4 在一些重要方面的异同点：&lt;/p&gt;
&lt;h3 id=&quot;创建-S</summary>
      
    
    
    
    <category term="vuex" scheme="http://example.com/categories/vuex/"/>
    
    
    <category term="vuex" scheme="http://example.com/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>[译] javascript 检测剪贴板中的内容类型</title>
    <link href="http://example.com/2023/04/14/plate/"/>
    <id>http://example.com/2023/04/14/plate/</id>
    <published>2023-04-14T03:01:42.000Z</published>
    <updated>2023-04-14T03:01:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>原文地址：</em><a href="https://davidwalsh.name/detect-clipboard-content">Detect the Content Type in the Clipboard</a></p><p>2023.03.06 By David Walsh</p></blockquote><p>用户的剪贴板是操作系统和应用程序之间的“万能收集器”。当你使用网页浏览器时，你可以选择文本并复制，也可以右键点击图像并选择“复制图像”。这让我想到开发人员如何检测剪贴板中的内容类型。</p><p>你可以使用 <code>navigator.clipboard</code> API 获取用户剪贴板的内容。由于剪贴板可能包含敏感数据，因此该 API 需要用户权限。你可以使用以下 JavaScript 代码获取使用剪贴板 API 的权限：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> navigator.<span class="property">permissions</span>.<span class="title function_">query</span>(&#123;<span class="attr">name</span>: <span class="string">&quot;clipboard-write&quot;</span>&#125;);</span><br><span class="line"><span class="keyword">if</span> (result.<span class="property">state</span> === <span class="string">&quot;granted&quot;</span> || result.<span class="property">state</span> === <span class="string">&quot;prompt&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">// 权限已授予</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>授予剪贴板权限后，你可以查询剪贴板以获取 <code>ClipboardItem</code> 实例，其中包含已复制的详细信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [item] = <span class="keyword">await</span> navigator.<span class="property">clipboard</span>.<span class="title function_">read</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当文本被复制到剪贴板时...</span></span><br><span class="line">item.<span class="property">types</span> <span class="comment">// [&quot;text/plain&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当从网站复制图像时...</span></span><br><span class="line">item.<span class="property">types</span> <span class="comment">// [&quot;text/html&quot;, &quot;image/png&quot;]</span></span><br></pre></td></tr></table></figure><p>一旦你知道了剪贴板中的内容和MIME类型，就可以使用 <code>readText()</code> 获取剪贴板中的文本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> content = <span class="keyword">await</span> navigator.<span class="property">clipboard</span>.<span class="title function_">readText</span>();</span><br></pre></td></tr></table></figure><p>对于图像，如果你有MIME类型和内容，你可以使用数据URI的 <code>&lt;img&gt;</code> 进行显示。了解用户剪贴板的内容对于展示他们复制的内容非常有帮助！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;原文地址：&lt;/em&gt;&lt;a href=&quot;https://davidwalsh.name/detect-clipboard-content&quot;&gt;Detect the Content Type in the Clipboard&lt;/a&gt;&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="外文翻译" scheme="http://example.com/categories/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>手写 Vuex(三)</title>
    <link href="http://example.com/2023/04/13/vuex3/"/>
    <id>http://example.com/2023/04/13/vuex3/</id>
    <published>2023-04-13T03:01:42.000Z</published>
    <updated>2023-04-13T03:01:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>map 辅助函数是 Vuex 提供的一种方便的方式，用于将 Vuex 中的状态、getters、mutations 和 actions 映射到 Vue 组件中的本地状态、计算属性、方法和动作。</p><h3 id="map-辅助函数"><a href="#map-辅助函数" class="headerlink" title="map 辅助函数"></a>map 辅助函数</h3><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><ul><li><strong>mapState(namespace?: string, map: Array&lt;string&gt; | Object&lt;string | function&gt;): Object</strong></li></ul><p>这里以 mapState 为例，简单看下 map 辅助函数的三种使用方法，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">computed</span>: <span class="title function_">mapState</span>(&#123;</span><br><span class="line">    <span class="comment">// 箭头函数可使代码更简练</span></span><br><span class="line">    <span class="attr">count</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">count</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传字符串参数 &#x27;count&#x27; 等同于 `state =&gt; state.count`</span></span><br><span class="line">    <span class="attr">countAlias</span>: <span class="string">&#x27;count&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span></span><br><span class="line">    countPlusLocalState (state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">count</span> + <span class="variable language_">this</span>.<span class="property">localCount</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不考虑 namespace，以数组为例，可以很简单的实现实现 mapState 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mapState</span> = args =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> states = &#123;&#125;</span><br><span class="line">    args.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        states[item] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>[item]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> states</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="normalizeMap"><a href="#normalizeMap" class="headerlink" title="normalizeMap"></a>normalizeMap</h4><p>由于用户传入可能为数组或对象，首先需要格式化参数格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">normalizeMap</span>(<span class="params">map</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(map)</span><br><span class="line">        ? map.<span class="title function_">map</span>(<span class="function"><span class="params">key</span> =&gt;</span> (&#123; key, <span class="attr">val</span>: key &#125;))</span><br><span class="line">        : <span class="title class_">Object</span>.<span class="title function_">keys</span>(map).<span class="title function_">map</span>(<span class="function"><span class="params">key</span> =&gt;</span> (&#123; key, <span class="attr">val</span>: map[key] &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="normalizeNamespace"><a href="#normalizeNamespace" class="headerlink" title="normalizeNamespace"></a>normalizeNamespace</h4><p>根据 namespace 配置，对开启命名空间的模块，拼接路径参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">normalizeNamespace</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">namespace, map</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> namespace !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">            map = namespace</span><br><span class="line">            namespace = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (namespace.<span class="title function_">charAt</span>(namespace.<span class="property">length</span> - <span class="number">1</span>) !== <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            namespace += <span class="string">&#x27;/&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fn</span>(namespace, map)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getModuleByNamespace"><a href="#getModuleByNamespace" class="headerlink" title="getModuleByNamespace"></a>getModuleByNamespace</h4><p>获取 namespace 对应的 module 模块，注：这里可以参考 namespace 一节中的数据结构，就很容易理解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getModuleByNamespace</span>(<span class="params">store, helper, namespace</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="variable language_">module</span> = store.<span class="property">_modulesNamespaceMap</span>[namespace]</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">module</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`[vuex] module namespace not found in <span class="subst">$&#123;helper&#125;</span>(): <span class="subst">$&#123;namespace&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">module</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a>mapState</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapState = <span class="title function_">normalizeNamespace</span>(<span class="function">(<span class="params">namespace, states</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">    <span class="title function_">normalizeMap</span>(states).<span class="title function_">forEach</span>(<span class="function">(<span class="params">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        res[key] = <span class="keyword">function</span> <span class="title function_">mappedState</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">// 根模块 state、getters</span></span><br><span class="line">            <span class="keyword">let</span> state = <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span></span><br><span class="line">            <span class="keyword">let</span> getters = <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span></span><br><span class="line">            <span class="keyword">if</span> (namespace) &#123;</span><br><span class="line">              <span class="comment">// 通过 namespace 拿到相应的模块</span></span><br><span class="line">                <span class="keyword">const</span> <span class="variable language_">module</span> = <span class="title function_">getModuleByNamespace</span>(<span class="variable language_">this</span>.<span class="property">$store</span>, <span class="string">&#x27;mapState&#x27;</span>, namespace)</span><br><span class="line">                <span class="keyword">if</span> (!<span class="variable language_">module</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">// 子模块 state、getter</span></span><br><span class="line">                state = <span class="variable language_">module</span>.<span class="property">state</span></span><br><span class="line">                getters = <span class="variable language_">module</span>.<span class="property">getters</span></span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 如：以下场景的配置项，需要执行函数，得到最终结果在返回</span></span><br><span class="line">            <span class="comment">// countPlusLocalState (state) &#123;</span></span><br><span class="line">            <span class="comment">//  return state.count + this.localCount</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">                ? val.<span class="title function_">call</span>(<span class="variable language_">this</span>, state, getters)</span><br><span class="line">                : state[val]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>同理可依次实现 mapGetters、mapMutations、mapActions 辅助函数</p><h4 id="mapGetters"><a href="#mapGetters" class="headerlink" title="mapGetters"></a>mapGetters</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapGetters = <span class="title function_">normalizeNamespace</span>(<span class="function">(<span class="params">namespace, getters</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">normalizeMap</span>(getters).<span class="title function_">forEach</span>(<span class="function">(<span class="params">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// The namespace has been mutated by normalizeNamespace</span></span><br><span class="line">        val = namespace + val</span><br><span class="line">        res[key] = <span class="keyword">function</span> <span class="title function_">mappedGetter</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (namespace &amp;&amp; !<span class="title function_">getModuleByNamespace</span>(<span class="variable language_">this</span>.<span class="property">$store</span>, <span class="string">&#x27;mapGetters&#x27;</span>, namespace)) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>[val]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a>mapMutations</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapMutations = <span class="title function_">normalizeNamespace</span>(<span class="function">(<span class="params">namespace, mutations</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">normalizeMap</span>(mutations).<span class="title function_">forEach</span>(<span class="function">(<span class="params">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        res[key] = <span class="keyword">function</span> <span class="title function_">mappedMutation</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">            <span class="comment">// Get the commit method from store</span></span><br><span class="line">            <span class="keyword">let</span> commit = <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">commit</span></span><br><span class="line">            <span class="keyword">if</span> (namespace) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="variable language_">module</span> = <span class="title function_">getModuleByNamespace</span>(<span class="variable language_">this</span>.<span class="property">$store</span>, <span class="string">&#x27;mapMutations&#x27;</span>, namespace)</span><br><span class="line">                <span class="keyword">if</span> (!<span class="variable language_">module</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">const</span> _type = namespace + val</span><br><span class="line">                commit = <span class="function">() =&gt;</span> &#123; <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(_type) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">                ? val.<span class="title function_">apply</span>(<span class="variable language_">this</span>, [commit].<span class="title function_">concat</span>(args))</span><br><span class="line">                : commit.<span class="title function_">apply</span>(<span class="variable language_">this</span>.<span class="property">$store</span>, [val].<span class="title function_">concat</span>(args))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a>mapActions</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapActions = <span class="title function_">normalizeNamespace</span>(<span class="function">(<span class="params">namespace, actions</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">normalizeMap</span>(actions).<span class="title function_">forEach</span>(<span class="function">(<span class="params">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        res[key] = <span class="keyword">function</span> <span class="title function_">mappedAction</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">            <span class="comment">// get dispatch function from store</span></span><br><span class="line">            <span class="keyword">let</span> dispatch = <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">dispatch</span></span><br><span class="line">            <span class="keyword">if</span> (namespace) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="variable language_">module</span> = <span class="title function_">getModuleByNamespace</span>(<span class="variable language_">this</span>.<span class="property">$store</span>, <span class="string">&#x27;mapActions&#x27;</span>, namespace)</span><br><span class="line">                <span class="keyword">if</span> (!<span class="variable language_">module</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">const</span> _type = namespace + val</span><br><span class="line">                dispatch = <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(_type) &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">                ? val.<span class="title function_">apply</span>(<span class="variable language_">this</span>, [dispatch].<span class="title function_">concat</span>(args))</span><br><span class="line">                : dispatch.<span class="title function_">apply</span>(<span class="variable language_">this</span>.<span class="property">$store</span>, [val].<span class="title function_">concat</span>(args))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>至此，手写 Vuex 基础功能、模块化、命名空间、严格模式等已完结，以源码为例，实现了一个简易的Vuex3，帮助我们理解其原理，希望这篇文章对你有所帮助！更多详细信息请参考 <a href="https://github.com/vuejs/vuex/tree/v3.6.2">vuex 源码</a>。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a><a href="https://github.com/xuyangzhou/my-vuex3">完整代码</a></h3><h3 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h3><ul><li><a href="/2023/04/10/vuex1/">手写 Vuex(一)</a></li><li><a href="/2023/04/11/vuex2/">手写 Vuex(二)</a></li><li><a href="/2023/04/13/vuex3/">手写 Vuex(三)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;map 辅助函数是 Vuex 提供的一种方便的方式，用于将 Vuex 中的状态、getters、mutations 和 actions 映射到 Vue 组件中的本地状态、计算属性、方法和动作。&lt;/p&gt;
&lt;h3 id=&quot;map-辅助函数&quot;&gt;&lt;a href=&quot;#map-辅助函数</summary>
      
    
    
    
    <category term="vuex" scheme="http://example.com/categories/vuex/"/>
    
    
    <category term="vuex 源码" scheme="http://example.com/tags/vuex-%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>手写 Vuex(二)</title>
    <link href="http://example.com/2023/04/11/vuex2/"/>
    <id>http://example.com/2023/04/11/vuex2/</id>
    <published>2023-04-11T03:01:42.000Z</published>
    <updated>2023-04-11T03:01:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>书接上文：<a href="/2023/04/10/vuex1/">手写 Vuex (一)</a> 中，实现了 Vuex 的基础功能，现在继续对其进行完善，实现模块化的状态管理。模块化可以帮助我们更好地组织和管理复杂的应用状态，使得状态的结构更加清晰和可维护。</p><h3 id="格式化参数"><a href="#格式化参数" class="headerlink" title="格式化参数"></a>格式化参数</h3><p>将参数模块格式化为模块嵌套的树形结构（如下），方便我们后续的操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根模块</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">root</span> = &#123;   <span class="comment">// 模块的配置：包含当前模块的 state、getters、mutations、actions</span></span><br><span class="line">    <span class="attr">_raw</span>: xxx,</span><br><span class="line">    <span class="attr">_children</span>: &#123; <span class="comment">// 子模块</span></span><br><span class="line">      a模块: &#123;</span><br><span class="line">        <span class="attr">_raw</span>: xxx,</span><br><span class="line">        <span class="attr">_children</span>: &#123;&#125;,</span><br><span class="line">        <span class="attr">state</span>: xxx.<span class="property">state</span></span><br><span class="line">      &#125;,</span><br><span class="line">      b模块: &#123;</span><br><span class="line">        <span class="attr">_raw</span>: xxx,</span><br><span class="line">        <span class="attr">_children</span>: &#123;&#125;,</span><br><span class="line">        <span class="attr">state</span>: xxx.<span class="property">state</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">state</span>: xxx.<span class="property">state</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Module-类"><a href="#Module-类" class="headerlink" title="Module 类"></a>Module 类</h4><p>创建 Module 类，通过 new Module 便可以得到格式化后的树形数据结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Module</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">rootModule</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_raw</span> = rootModule,</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_children</span> = &#123;&#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = rootModule.<span class="property">state</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ModuleCollection-类"><a href="#ModuleCollection-类" class="headerlink" title="ModuleCollection 类"></a>ModuleCollection 类</h4><p>在这个类中，实现将用户传入的参数转化为格式化后的结果，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module-collection.js</span></span><br><span class="line"><span class="keyword">import</span> forEachValue <span class="keyword">from</span> <span class="string">&quot;./utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Module</span> <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">ModlueCollection</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="comment">// 注册模块 []表示路径 递归注册模块</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">register</span>([], options)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">register</span>(<span class="params">path, rootModule</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> newModlue = <span class="keyword">new</span> <span class="title class_">Module</span>(rootModule)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="property">length</span> == <span class="number">0</span>) &#123; <span class="comment">// 根模块</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">root</span> = newModlue</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> parent = path.<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">1</span>).<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, next</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> pre.<span class="title function_">getChild</span>(next)</span><br><span class="line">            &#125;, <span class="variable language_">this</span>.<span class="property">root</span>)</span><br><span class="line">            parent.<span class="title function_">addChild</span>(path[path.<span class="property">length</span> - <span class="number">1</span>], newModlue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注册子模块</span></span><br><span class="line">        <span class="keyword">if</span> (rootModule.<span class="property">modules</span>) &#123;</span><br><span class="line">            <span class="title function_">forEachValue</span>(rootModule.<span class="property">modules</span>, <span class="function">(<span class="params">moduleValue, moduleName</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 递归</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">register</span>([...path, moduleName], moduleValue)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="forEachValue"><a href="#forEachValue" class="headerlink" title="forEachValue"></a>forEachValue</h4><p>其中 forEachValue 方法提取为工具方法，方便后续复用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">forEachValue</span> = (<span class="params">obj = &#123;&#125;, fn</span>) =&gt; &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">fn</span>(obj[key], key)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> forEachValue</span><br></pre></td></tr></table></figure><h4 id="getChild、addChild"><a href="#getChild、addChild" class="headerlink" title="getChild、addChild"></a>getChild、addChild</h4><p>增加获取子模块和追加子模块方法，便于调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Module</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取子模块</span></span><br><span class="line">    <span class="title function_">getChild</span>(<span class="params">key</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_children</span>[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 追加子模块</span></span><br><span class="line">    <span class="title function_">addChild</span>(<span class="params">key, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_children</span>[key] = <span class="variable language_">module</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此完成模块格式化为模块嵌套的树形结构，接下来重构 Store，实现 state、getter、commit、dispatch等</p><h3 id="installModule"><a href="#installModule" class="headerlink" title="installModule"></a>installModule</h3><p>installModlue方法：将创建的树形结构上的状态、方法安装到 Store 实例上，就可以通过$store方式获取到对应的数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ModuleCollection</span> <span class="keyword">from</span> <span class="string">&#x27;./module-collection.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> forEachValue <span class="keyword">from</span> <span class="string">&#x27;./utils&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Vue</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">installModule</span>(<span class="params">store, rootState, path, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 收集所有模块的状态</span></span><br><span class="line">    <span class="keyword">if</span> (path.<span class="property">length</span> &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果是子模块 就需要将子模块的状态定义到根模块上</span></span><br><span class="line">        <span class="keyword">let</span> parent = path.<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">1</span>).<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, next</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> pre[next]</span><br><span class="line">        &#125;, rootState)</span><br><span class="line">        <span class="comment">// 将属性设置为响应式 可以新增属性</span></span><br><span class="line">        <span class="title class_">Vue</span>.<span class="title function_">set</span>(parent, path[path.<span class="property">length</span> - <span class="number">1</span>], <span class="variable language_">module</span>.<span class="property">state</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">module</span>.<span class="title function_">forEachChild</span>(<span class="function">(<span class="params">child, key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">installModule</span>(store, rootState, path.<span class="title function_">concat</span>(key), child)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_modules</span> = <span class="keyword">new</span> <span class="title class_">ModuleCollection</span>(options)</span><br><span class="line">        <span class="comment">// 注册所有模块到Store实例上 </span></span><br><span class="line">        <span class="comment">// this当前实例、根状态、路径、根模块</span></span><br><span class="line">        <span class="keyword">const</span> state = <span class="variable language_">this</span>.<span class="property">_modules</span>.<span class="property">root</span>.<span class="property">state</span></span><br><span class="line">        <span class="title function_">installModule</span>(<span class="variable language_">this</span>, state, [], <span class="variable language_">this</span>.<span class="property">_modules</span>.<span class="property">root</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="forEachChild"><a href="#forEachChild" class="headerlink" title="forEachChild"></a>forEachChild</h4><p>遍历安装当前模块的子模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Module</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 遍历当前模块的child</span></span><br><span class="line">    <span class="title function_">forEachChild</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">      <span class="title function_">forEachValue</span>(<span class="variable language_">this</span>.<span class="property">_children</span>, fn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="resetStoreVm"><a href="#resetStoreVm" class="headerlink" title="resetStoreVm"></a>resetStoreVm</h4><p>实现 state 数据响应式响应式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resetStoreVm</span>(<span class="params">store, state</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> wrappedGetters = store.<span class="property">_wrappedGetters</span></span><br><span class="line">    <span class="keyword">const</span> computed = &#123;&#125;</span><br><span class="line">    store.<span class="property">getters</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="comment">// 通过使用vue的computed实现缓存</span></span><br><span class="line">    <span class="title function_">forEachValue</span>(wrappedGetters, <span class="function">(<span class="params">fn, key</span>) =&gt;</span> &#123;</span><br><span class="line">        computed[key] = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">fn</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 代理</span></span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(store.<span class="property">getters</span>, key, &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> store.<span class="property">_vm</span>[key] &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 将状态实现响应式</span></span><br><span class="line">    store.<span class="property">_vm</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">$$state</span>: state</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        computed</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">let</span> state = <span class="variable language_">this</span>.<span class="property">_modules</span>.<span class="property">root</span>.<span class="property">state</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//实现state响应式</span></span><br><span class="line">        <span class="title function_">resetStoreVm</span>(<span class="variable language_">this</span>, state)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">state</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_vm</span>.<span class="property">_data</span>.<span class="property">$$state</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="forEachGetters"><a href="#forEachGetters" class="headerlink" title="forEachGetters"></a>forEachGetters</h4><p>扩展 Module 类，遍历 getters</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Module</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 遍历当前模块的getters</span></span><br><span class="line">    <span class="title function_">forEachGetters</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_raw</span>.<span class="property">getters</span>) &#123;</span><br><span class="line">            <span class="title function_">forEachValue</span>(<span class="variable language_">this</span>.<span class="property">_raw</span>.<span class="property">getters</span>, fn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">installModule</span>(<span class="params">store, rootState, path, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="variable language_">module</span>.<span class="title function_">forEachGetters</span>(<span class="function">(<span class="params">getters, key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 同名计算属性会覆盖 所以不用存储</span></span><br><span class="line">        store.<span class="property">_wrappedGetters</span>[key] = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">getters</span>(<span class="variable language_">module</span>.<span class="property">state</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_wrappedGetters</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)  <span class="comment">// 存放所有模块的getters</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="commit（mutations）"><a href="#commit（mutations）" class="headerlink" title="commit（mutations）"></a>commit（mutations）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">installModule</span>(<span class="params">store, rootState, path, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="variable language_">module</span>.<span class="title function_">forEachMutations</span>(<span class="function">(<span class="params">mutations, type</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 收集所有模块的mutations 存放到 实例的store._mutations上</span></span><br><span class="line">        <span class="comment">// 同名的mutations和 actions 并不会覆盖 所以要有一个数组存储 &#123;changeAge: [fn,fn,fn]&#125;</span></span><br><span class="line">        store.<span class="property">_mutations</span>[type] = (store.<span class="property">_mutations</span>[type] || [])</span><br><span class="line">        store.<span class="property">_mutations</span>[type].<span class="title function_">push</span>(<span class="function">(<span class="params">payload</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 函数包装 包装传参是灵活的</span></span><br><span class="line">            <span class="comment">// 使this 永远指向实例 当前模块状态 入参数</span></span><br><span class="line">            mutations.<span class="title function_">call</span>(store, <span class="variable language_">module</span>.<span class="property">state</span>, payload)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_mutations</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)   <span class="comment">// 存放所有模块的mutation</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    commit = <span class="function">(<span class="params">type, payload</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 触发commit会触发_mutations里面的方法</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_mutations</span>[type].<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>(payload))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="forEachMutations"><a href="#forEachMutations" class="headerlink" title="forEachMutations"></a>forEachMutations</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Module</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 遍历当前模块的mutations</span></span><br><span class="line">    <span class="title function_">forEachMutations</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_raw</span>.<span class="property">mutations</span>) &#123;</span><br><span class="line">            <span class="title function_">forEachValue</span>(<span class="variable language_">this</span>.<span class="property">_raw</span>.<span class="property">mutations</span>, fn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dispatch（actions）"><a href="#dispatch（actions）" class="headerlink" title="dispatch（actions）"></a>dispatch（actions）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">installModule</span>(<span class="params">store, rootState, path, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="variable language_">module</span>.<span class="title function_">forEachActions</span>(<span class="function">(<span class="params">actions, type</span>) =&gt;</span> &#123;</span><br><span class="line">        store.<span class="property">_actions</span>[type] = (store.<span class="property">_actions</span>[type] || [])</span><br><span class="line">        store.<span class="property">_actions</span>[type].<span class="title function_">push</span>(<span class="function">(<span class="params">payload</span>) =&gt;</span> &#123;</span><br><span class="line">            actions.<span class="title function_">call</span>(store, store, payload)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_actions</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)     <span class="comment">// 存放所有模块的actions</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// dispatch</span></span><br><span class="line">    dispatch = <span class="function">(<span class="params">type, payload</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_actions</span>[type].<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>(payload))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="forEachActions"><a href="#forEachActions" class="headerlink" title="forEachActions"></a>forEachActions</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Module</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 遍历当前模块的actions</span></span><br><span class="line">    <span class="title function_">forEachActions</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_raw</span>.<span class="property">actions</span>) &#123;</span><br><span class="line">            <span class="title function_">forEachValue</span>(<span class="variable language_">this</span>.<span class="property">_raw</span>.<span class="property">actions</span>, fn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>默认情况下（或 namespace: false），模块内部的 action、mutation 和 getter 是注册在<strong>全局命名空间</strong>的——这样使得多个模块能够对同一 mutation 或 action 作出响应。</p><p>如果想要模块具有更高的封装度和复用性，可以通过添加 <code>namespaced: true</code> 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名</p><h4 id="getNamespaced"><a href="#getNamespaced" class="headerlink" title="getNamespaced"></a>getNamespaced</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module-collection.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">ModlueCollection</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">     <span class="comment">// 获取命名空间</span></span><br><span class="line">    <span class="title function_">getNamespaced</span>(<span class="params">path</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> root = <span class="variable language_">this</span>.<span class="property">root</span></span><br><span class="line">        <span class="keyword">return</span> path.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, next</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 获取子模块 查看是否有namespaced属性</span></span><br><span class="line">            root = root.<span class="title function_">getChild</span>(next)</span><br><span class="line">            <span class="comment">// 拼接上有namespace属性的路径</span></span><br><span class="line">            <span class="keyword">return</span> pre + (root.<span class="property">namespaced</span> ? next + <span class="string">&#x27;/&#x27;</span> :<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        &#125;, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Module</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    get namespaced () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_raw</span>.<span class="property">namespaced</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加-namespace"><a href="#添加-namespace" class="headerlink" title="添加 namespace"></a>添加 namespace</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">installModule</span>(<span class="params">store, rootState, path, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 获取命名空间</span></span><br><span class="line">    <span class="keyword">const</span> namespaced  = store.<span class="property">_modules</span>.<span class="title function_">getNamespaced</span>(path)</span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">module</span>.<span class="title function_">forEachMutations</span>(<span class="function">(<span class="params">mutations, type</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 添加 namespace</span></span><br><span class="line">        store.<span class="property">_mutations</span>[namespaced + type] = (store.<span class="property">_mutations</span>[namespaced + type] || [])</span><br><span class="line">        store.<span class="property">_mutations</span>[namespaced + type].<span class="title function_">push</span>(<span class="function">(<span class="params">payload</span>) =&gt;</span> &#123;</span><br><span class="line">            mutations.<span class="title function_">call</span>(store, <span class="variable language_">module</span>.<span class="property">state</span>, payload)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">module</span>.<span class="title function_">forEachActions</span>(<span class="function">(<span class="params">actions, type</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 添加 namespace</span></span><br><span class="line">        store.<span class="property">_actions</span>[namespaced + type] = (store.<span class="property">_actions</span>[namespaced + type] || [])</span><br><span class="line">        store.<span class="property">_actions</span>[namespaced + type].<span class="title function_">push</span>(<span class="function">(<span class="params">payload</span>) =&gt;</span> &#123;</span><br><span class="line">            actions.<span class="title function_">call</span>(store, store, payload)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">module</span>.<span class="title function_">forEachGetters</span>(<span class="function">(<span class="params">getters, key</span>) =&gt;</span> &#123;</span><br><span class="line">        store.<span class="property">_wrappedGetters</span>[namespaced + key] = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">getters</span>(<span class="variable language_">module</span>.<span class="property">state</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。</p><h4 id="接收-strict-配置项，添加-mutation-提交状态标识"><a href="#接收-strict-配置项，添加-mutation-提交状态标识" class="headerlink" title="接收 strict 配置项，添加 mutation 提交状态标识"></a>接收 strict 配置项，添加 mutation 提交状态标识</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// strict mode</span></span><br><span class="line">        <span class="keyword">const</span> &#123; strict = <span class="literal">false</span> &#125; = options</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">strict</span> = strict</span><br><span class="line">        <span class="comment">// 添加 committing 状态</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_committing</span> = <span class="literal">false</span></span><br><span class="line">        <span class="comment">//实现状态响应式</span></span><br><span class="line">        <span class="title function_">resetStoreVm</span>(<span class="variable language_">this</span>, state)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在 mutation 之前，设置 _committing = true, 调用 mutation 之后更改状态</span></span><br><span class="line">    <span class="comment">// 如此当状态变化时，_committing 为 true，说明是同步更改，false 说明是非 mutation 提交</span></span><br><span class="line">    _withCommit = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> committing = <span class="variable language_">this</span>.<span class="property">_committing</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_committing</span> = <span class="literal">true</span>;</span><br><span class="line">        <span class="title function_">fn</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_committing</span> = committing;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 修改 commit 方法，使用 _withCommit 调用 mutation</span></span><br><span class="line">  commit = <span class="function">(<span class="params">type, payload</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_mutations</span>[type]) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Mutation &quot;<span class="subst">$&#123;type&#125;</span>&quot; not found`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> entry = <span class="variable language_">this</span>.<span class="property">_mutations</span>[type]</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">_withCommit</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            entry.<span class="title function_">forEach</span>(<span class="function">(<span class="params">handler</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">handler</span>(payload)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resetStoreVm</span>(<span class="params">store, state</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 如果开启了严格模式，则调用 enableStrictMode</span></span><br><span class="line">    <span class="keyword">if</span> (store.<span class="property">strict</span>) &#123;</span><br><span class="line">        <span class="title function_">enableStrictMode</span>(store)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="enableStrictMode"><a href="#enableStrictMode" class="headerlink" title="enableStrictMode"></a>enableStrictMode</h4><p>监听 state 数据变化，判断 _committing 如果是 true 表示是同步执行，如果为 false，则会抛出错误提示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">enableStrictMode</span>(<span class="params">store</span>) &#123;</span><br><span class="line">    store.<span class="property">_vm</span>.$watch(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_data</span>.<span class="property">$$state</span> &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">assert</span>(store.<span class="property">_committing</span>, <span class="string">`[vuex] do not mutate vuex store state outside mutation handlers.`</span>)</span><br><span class="line">    &#125;, &#123; <span class="attr">deep</span>: <span class="literal">true</span>, <span class="attr">sync</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上只是基于vuex源码实现了最核心的功能，但它帮助我们更好地理解了 Vuex 的模块化的实现原理。本来计划在这篇中实现 map辅助函数，但发现模块化的写起来实在太多了，所以将 mapState、 mapGetters、 mapMutations、 mapActions 放到下篇讲解。希望这篇文章对你有所帮助！更多详细信息请参考 <a href="https://github.com/vuejs/vuex/tree/v3.6.2">vuex 源码</a>。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a><a href="https://github.com/xuyangzhou/my-vuex3">完整代码</a></h3><h3 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h3><ul><li><a href="/2023/04/10/vuex1/">手写 Vuex(一)</a></li><li><a href="/2023/04/11/vuex2/">手写 Vuex(二)</a></li><li><a href="/2023/04/13/vuex3/">手写 Vuex(三)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;书接上文：&lt;a href=&quot;/2023/04/10/vuex1/&quot;&gt;手写 Vuex (一)&lt;/a&gt; 中，实现了 Vuex 的基础功能，现在继续对其进行完善，实现模块化的状态管理。模块化可以帮助我们更好地组织和管理复杂的应用状态，使得状态的结构更加清晰和可维护。&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    <category term="vuex" scheme="http://example.com/categories/vuex/"/>
    
    
    <category term="vuex 源码" scheme="http://example.com/tags/vuex-%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>手写 Vuex(一)</title>
    <link href="http://example.com/2023/04/10/vuex1/"/>
    <id>http://example.com/2023/04/10/vuex1/</id>
    <published>2023-04-10T03:01:42.000Z</published>
    <updated>2023-04-10T03:01:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>Vuex 是 Vue.js 的状态管理模式，它主要解决了组件之间共享状态时的问题。在本文中，我们将实现一个简单的状态管理器，来帮助我们更好地理解 Vuex 的实现原理。</p><h3 id="使用-vue-use-启用-vuex-插件"><a href="#使用-vue-use-启用-vuex-插件" class="headerlink" title="使用 vue.use 启用 vuex 插件"></a>使用 vue.use 启用 vuex 插件</h3><p>vue.use 是 vue 提供的安装插件 API。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象。</p><p>即需要导出 <code>install</code> 方法，同时导出一个类 <code>Store</code> ，于是可以写出以下代码：</p><pre><code>let Vue = null​class Store &#123;  constructor(options) &#123;&#125;&#125;​function install(_Vue) &#123;  Vue = _Vue&#125;​export default &#123;  Store,  install,&#125;</code></pre><h3 id="实现-install-方法"><a href="#实现-install-方法" class="headerlink" title="实现 install 方法"></a>实现 install 方法</h3><pre><code>function install(_Vue) &#123;  Vue = _Vue // install 方法调用时，会将 Vue 作为参数传入  // 实现每一个组件，都能通过 this 调用 $store  Vue.mixin(&#123;    beforeCreate() &#123;      // 通过 this.$options 可以获取 new Vue(&#123;参数&#125;) 传递的参数      if (this.$options &amp;&amp; this.$options.store) &#123;        // vue的原型上挂载 store（ Store 的实例 ）        this.$store = this.$options.store        // 等同于 Vue.prototype.$store = this.$options.store      &#125;    &#125;  &#125;)&#125;</code></pre><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>在 <code>Vuex</code> 中，<code>Store</code> 是一个对象，它是一个容器，用于存储和管理状态( state )，包含了以下几个主要部分：</p><ul><li><code>state</code>：存储状态的数据，也就是全局要共享的数据。</li><li><code>getters</code>：包含一些函数，用于对 <code>state</code> 进行计算操作。</li><li><code>mutations</code>：包含一些函数，用于改变 <code>state</code> 的值。</li><li><code>actions</code>：包含一些函数，用于处理异步操作或者一些逻辑处理。</li></ul><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><p>首先，我们需要定义一个存储对象，用于保存应用程序的所有状态。我们可以创建一个名为 Store 的类，并在其中定义一个状态对象。我们还可以将 state 对象定义为响应式的，以便在状态更改时通知 Vue 更新视图。这可以通过使用 Vue.observable 方法来实现</p><pre><code>class Store &#123;  constructor(options) &#123;    const &#123; state = &#123;&#125; &#125; = options;    // 使用 observable 响应化处理    this.state = Vue.observable(state);  &#125;&#125;</code></pre><h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h4><p>接下来，我们需要实现 getters，以便从状态中派生计算属性。我们将 getters 添加到 Store 类中：</p><pre><code>class Store &#123;  constructor(options) &#123;    const &#123; getters = &#123;&#125; &#125; = options;        this.getters = &#123;&#125;;    for (const [key, value] of Object.entries(getters)) &#123;      Object.defineProperty(this.getters, key, &#123;        get: () =&gt; value(this.state),      &#125;);    &#125;  &#125;&#125;</code></pre><h4 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h4><p>最后，我们需要实现 mutations 和 actions，以便更改状态和处理异步操作。mutations 是唯一可以更改状态的方法，而 actions 则是处理异步操作的地方，它们可以触发 mutations 来更改状态。我们将 mutations 和 actions 添加到 Store 类中：</p><p>在下面的代码中，我们添加了一个 commit 方法，它接受一个类型和有效载荷参数，并调用与类型匹配的 mutation 函数来更改状态。</p><pre><code>class Store &#123;  constructor(options) &#123;    const &#123; mutations = &#123;&#125; &#125; = options;        this.mutations = mutations;        commit(type, payload) &#123;      if (!this.mutations[type]) &#123;        throw new Error(`Mutation &quot;$&#123;type&#125;&quot; not found`);      &#125;      this.mutations[type](this.state, payload);    &#125;  &#125;&#125;</code></pre><h4 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h4><p>还需要添加了一个 dispatch 方法，它接受一个类型和有效载荷参数，并调用与类型匹配的 action 函数。注意，我们将 commit 和 state 作为参数传递给 action 函数，以便在需要更改状态时使用。</p><pre><code>class Store &#123;  constructor(options) &#123;    const &#123; actions = &#123;&#125; &#125; = options;        this.actions = actions;        dispatch(type, payload) &#123;      if (!this.actions[type]) &#123;        throw new Error(`Action &quot;$&#123;type&#125;&quot; not found`);      &#125;      return this.actions[type](&#123; commit: this.commit, state: this.state &#125;, payload);    &#125;  &#125;&#125;</code></pre><p>这个简单的状态管理器只是 Vuex 的一部分实现，但它帮助我们更好地理解了 Vuex 的概念和实现原理。你会发现还没有实现 map辅助函数、模块化以及严格模式等，后续将一步步完善，对比与 vuex4、pinia 的差异化等。希望这篇文章对你有所帮助！</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a><a href="https://github.com/xuyangzhou/my-vuex3">完整代码</a></h3><h3 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h3><ul><li><a href="/2023/04/10/vuex1/">手写 Vuex(一)</a></li><li><a href="/2023/04/11/vuex2/">手写 Vuex(二)</a></li><li><a href="/2023/04/13/vuex3/">手写 Vuex(三)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Vuex 是 Vue.js 的状态管理模式，它主要解决了组件之间共享状态时的问题。在本文中，我们将实现一个简单的状态管理器，来帮助我们更好地理解 Vuex 的实现原理。&lt;/p&gt;
&lt;h3 id=&quot;使用-vue-use-启用-vuex-插件&quot;&gt;&lt;a href=&quot;#使用-vue-</summary>
      
    
    
    
    <category term="vuex" scheme="http://example.com/categories/vuex/"/>
    
    
    <category term="vuex 源码" scheme="http://example.com/tags/vuex-%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>[译] Volar: 一个新的开始</title>
    <link href="http://example.com/2023/04/06/volar/"/>
    <id>http://example.com/2023/04/06/volar/</id>
    <published>2023-04-06T04:00:00.000Z</published>
    <updated>2023-04-06T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em><a href="https://blog.vuejs.org/posts/volar-a-new-beginning.html">原文 https://blog.vuejs.org/posts/volar-a-new-beginning.html</a></em></p></blockquote><p>大多数 Volar 用户都知道它是的 Vue.js 的 VSCode 扩展。它最初是一个个人项目，当时官方推荐的还是 Vetur ，随着时间的推移，由于改进的架构和性能而被采纳为新的官方扩展。</p><p>作为一个旨在改善开发人员开发质量的项目，我们花了两年多的时间才发布 <a href="https://blog.vuejs.org/posts/volar-1.0.html">1.0</a> 版本，并且一直在不断改进稳定性。</p><p>但我们还有更多工作要做，2023 年有令人兴奋的计划。</p><hr><h2 id="Volar-js：嵌入式语言工具框架"><a href="#Volar-js：嵌入式语言工具框架" class="headerlink" title="Volar.js：嵌入式语言工具框架"></a>Volar.js：嵌入式语言工具框架</h2><p>尽管最初是为 Vue 单文件组件的特定需求而设计的，但 Volar 的代码库包含许多不特定于 Vue 的部分，例如：</p><ul><li>嵌入式编程语言的处理（多元框架的通病）</li><li>Vue 语言服务器实际上是一个成熟的 TypeScript 语言服务器</li><li>处理与 LSP &#x2F; Web &#x2F; 嵌入式语言服务等交互的代码</li></ul><p>我们现在已经将这些通用部分提取到一组与框架无关的工具中。这些工具现在作为一个新的独立项目进行维护：<a href="https://volarjs.github.io/">Volar.js</a>。</p><p>Volar.js 的架构支持任何涉及嵌入式语言的文件格式——不仅是 Vue，还包括 Astro、Svelte，甚至 Angular。它还能够实现常规的单语言 LSP 服务器，例如 TypeScript、CSS 和 HTML。</p><p>Volar.js 的另一个主要关注点是性能。它旨在最大限度地减少实现本地嵌入式语言服务性能的开销。有许多问题和优化机会只能在相当大的用户基础上慢慢发现，而 Volar.js 的优化是基于我们从数百万次下载中积累的经验。</p><p>例如，字节跳动的 Lynx 团队是 Volar.js 的早期采用者，一个开发人员用两周的时间交付了一整套支持其内部框架的语言工具。如果从头开始构建，即使是一个团队，也需要几个月的时间。</p><h2 id="旧的-Volar-现在是-vuejs-language-tools"><a href="#旧的-Volar-现在是-vuejs-language-tools" class="headerlink" title="旧的 Volar 现在是 vuejs&#x2F;language-tools"></a>旧的 Volar 现在是 vuejs&#x2F;language-tools</h2><p>提取核心后，原始 Volar 扩展的代码库<code>vue-tsc</code>已移至<a href="https://github.com/vuejs/language-tools"><code>vuejs/language-tools</code></a>存储库。这个 repo 现在依赖于 Volar.js 并包含 Vue 特定支持的代码。</p><p>我们还将把一些 npm 包从<code>@volar</code> npm 组织移到<code>@vue</code>- 但这些更改不应该影响最终用户。</p><h2 id="团队与组织"><a href="#团队与组织" class="headerlink" title="团队与组织"></a>团队与组织</h2><p>类似于 <a href="https://vitejs.dev/">Vite</a> 诞生于 Vue 生态系统，并最终发展成自己的社区，连接整个 Web 开发生态系统的用户，Volar.js 希望遵循同样的道路。</p><p>我 ( <a href="https://github.com/johnsoncodehk">@johnsoncodehk</a> ) 已经与Astro 核心团队成员Erika ( <a href="https://elk.zone/mastodon.gamedevalliance.fr/@erika">@erika</a> )建立了 Volar.js 核心团队。Erika 与我一样，致力于改善人们的开发体验。我们将共同努力，为所有网络开发者改进 DX，而不仅仅是 Vue 和 Astro。</p><p>我们已经创建了 <a href="https://github.com/volarjs"><code>volarjs</code> 组织</a>来维护框架和相关的回购协议。</p><ul><li><a href="https://github.com/volarjs/volar.js">volar.js</a> : 框架的核心</li><li><a href="https://github.com/volarjs/plugins">plugins</a> : 可以在<code>volar.config.js</code>框架中或插件中使用</li><li><a href="https://volarjs.github.io/">volarjs.github.io</a> : 官方网站</li><li><a href="https://github.com/volarjs/language-tools-starter">language-tools-starter</a>：开始使用 Volar.js 构建语言服务器的模板</li><li><a href="https://github.com/volarjs/ecosystem-ci">ecosystem-ci</a>：用于运行 volar 生态系统项目的集成测试</li><li><a href="https://github.com/volarjs/pug-language-tools">pug-language-tools</a> : 基于 language-tools-starter 的 Pug 工具</li><li><a href="https://github.com/volarjs/angular-language-tools">angular-language-tools</a>：基于 language-tools-starter 的 Angular 示例</li><li><a href="https://github.com/volarjs/svelte-language-tools">svelte-language-tools</a>：基于 language-tools-starter 的 Svelte 示例</li></ul><p>此外，我很高兴地宣布：</p><p><strong><a href="https://stackblitz.com/">StackBlitz</a>将全职支持我在 Volar.js 上工作！</strong></p><p>我们对未来感到兴奋，迫不及待地想看看在接下来的几个月里我们能取得什么成就！</p><h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>我们才刚刚起步，所以我们还没有明确的长期路线图，但这里有一些我们计划接下来探索和努力的主要方向。</p><h3 id="Monaco支持"><a href="#Monaco支持" class="headerlink" title="Monaco支持"></a>Monaco支持</h3><p>Monaco 对 Vue 的支持目前由 实现 <code>monaco-volar</code> 实现，我们计划在框架中支持它，因此所有基于 Volar.js 的语言服务器都可以轻松利用它。</p><h3 id="支持-VSCode-以外的-IDE"><a href="#支持-VSCode-以外的-IDE" class="headerlink" title="支持 VSCode 以外的 IDE"></a>支持 VSCode 以外的 IDE</h3><p>除了 VSCode 之外，许多慷慨的贡献者还为 Volar 实现了其他IDE的语言客户端，如 Vim、Sublime、Atom、Emacs、Nova、Lapce 。</p><p>拥有一整套的IDE支持可以有很大的参考价值，因为很少有人能够精通所有这些IDE。</p><p>我们将寻找方法来利用这些贡献者的努力来减少框架采用者在 VSCode 之外实现语言客户端的工作量。</p><p>此外，虽然 IntelliJ 没有一流的 LSP 支持，但我们将研究是否可以将其与框架集成。</p><h3 id="Bun-基础语言服务器"><a href="#Bun-基础语言服务器" class="headerlink" title="Bun 基础语言服务器"></a>Bun 基础语言服务器</h3><p>理论上，Volar 的性能只能无限接近，但不会快于 vanilla TS 语言服务器。但是，如果 Volar 语言服务器可以通过在 <a href="https://bun.sh/">Bun</a> 中运行来获得性能提升，它可能会改变游戏规则。</p><p>以前 Bun 的运行时还不兼容基于 Node.js 的 LSP 服务器。我们会持续关注相关问题，待问题解决后重试。</p><p>同样，所有基于 Volar.js 的语言服务器都将能够直接从中受益。</p><h3 id="单体服务器"><a href="#单体服务器" class="headerlink" title="单体服务器"></a>单体服务器</h3><p>想象这样一个场景，每一种语言都需要支持一些 TypeScript 特性，那么每一种语言的语言服务器都会运行自己昂贵的 TypeScript Language Service 实例，这让事情变得有点可怕，因为内存和 CPU 使用率都会成倍增加，而这种情况今天已经发生了。</p><p>如果这些语言服务器中的一些是基于 Volar.js 的，我们可能有一些方法让他们决定只激活一个语言服务器，然后将其余语言服务器的功能共享给激活的服务器，这样在最终我们只需要在一个语言服务器实例而不是多个语言服务器中运行 TypeScript 语言服务。</p><p>这也可以解决 TypeScript 插件无法支持的一些用例。</p><p>基于 Volar.js 架构，我们已经非常接近这个目标，我和 Erika 将为 Vue 和 Astro 语言服务器探索这个特性。</p><h3 id="规则-API（内置-Linter）"><a href="#规则-API（内置-Linter）" class="headerlink" title="规则 API（内置 Linter）"></a>规则 API（内置 Linter）</h3><p>你可能在 ESLint 和 Prettier 一起使用时遇到各种问题，而我们过去基于 Plugin API 的尝试并没有很好地避免这个问题。</p><p>Rules API 是避免不同 linting 工具之间冲突的另一种尝试，同时也确保性能和特性与 IDE 完美集成。</p><p>对于元框架，他们需要为 ESLint 和 Prettier 实现自己的解析器，但是有了 Rules API，他们甚至不需要这样做，因为我们可以复用 Volar 语言服务器的解析器。</p><p>因此，如果您编写了一个 TS 规则，它将直接通过 Rules API 用于 Vue<code>&lt;script&gt;</code>和模板中的 TypeScript 代码，而无需额外的解析器。</p><p>这并不意味着您需要重写所有规则；Rules API 只是一个 API，而不是一个单独的 linter，因此仍然可以复用 ESLint、TSLint 甚至 Rome 中的一些规则。</p><h3 id="脚本API"><a href="#脚本API" class="headerlink" title="脚本API"></a>脚本API</h3><p>对于 Vue 我们有<code>vue-tsc</code>检查 TS 代码，有时我们也想在 CI 中同时检查 CSS 和 Vue Template 代码。</p><p>Scripts API 旨在公开语言服务器的格式化和 linting 功能，以便它们可以在脚本中使用，允许您在 CI 或 git 预提交钩子中使用它并获得与在 IDE 中相同的结果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://blog.vuejs.org/posts/volar-a-new-beginning.html&quot;&gt;原文 https://blog.vuejs.org/posts/volar-a-new-beginning.</summary>
      
    
    
    
    <category term="外文翻译" scheme="http://example.com/categories/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
    <category term="外文翻译" scheme="http://example.com/tags/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    
    <category term="Volar" scheme="http://example.com/tags/Volar/"/>
    
  </entry>
  
  <entry>
    <title>[译] TypeScript 5.0 发布</title>
    <link href="http://example.com/2023/03/19/typescript/"/>
    <id>http://example.com/2023/03/19/typescript/</id>
    <published>2023-03-19T04:00:00.000Z</published>
    <updated>2023-03-19T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>原文地址：</em><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/">Announcing TypeScript 5.0</a></p><p>2023.3.16 by Daniel Rosenwasser and the TypeScript Team</p></blockquote><p>今天，我们很高兴地宣布 TypeScript 5.0 的发布！</p><p>此版本带来了许多新功能，同时旨在使 TypeScript 更小、更简单、更快。我们已经实施了新的装饰器标准，添加了更好地支持 Node 和 bundlers 中的 ESM 项目的功能，为库作者提供了控制泛型推理的新方法，扩展了我们的 JSDoc 功能，简化了配置，并进行了许多其他改进。</p><p>如果您还不熟悉 TypeScript，它是一种基于 JavaScript 的语言，通过添加类型语法来进行类型检查。类型检查可以帮助发现许多常见错误，从错别字到逻辑错误。将类型引入 JavaScript 还使我们能够构建出色的工具，因为类型可以在您喜欢的编辑器中支持代码补全、直接定义和重构等功能。事实上，如果您使用过 Visual Studio 或 VS Code 等编辑器，TypeScript 已经提供了 JavaScript 体验！您可以在 <a href="https://typescriptlang.org/">https://typescriptlang.org</a> 上了解这门语言。</p><p>但是，如果您已经熟悉 TypeScript，也不用担心！5.0 不是破坏性版本，你所知道的一切仍然适用。虽然 TypeScript 5.0 包括正确性更改和一些不常用选项的弃用，但我们相信大多数开发人员都会有与以前版本类似的升级体验。</p><p>要开始使用 TypeScript 5.0，您可以通过 <a href="https://www.nuget.org/packages/Microsoft.TypeScript.MSBuild">NuGet</a>获取它，或者使用 npm 和下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D typescript</span><br></pre></td></tr></table></figure><p>你也可以按照指示在 <a href="https://code.visualstudio.com/docs/typescript/typescript-compiling#_using-the-workspace-version-of-typescript">Visual Studio Code</a> 中使用新版本的 TypeScript 的说明进行操作。</p><p>这是 TypeScript 5.0 中新功能的快速列表！</p><ul><li><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#decorators">装饰器</a></li><li><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#const-type-parameters"><code>const</code> 泛型参数</a></li><li><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#supporting-multiple-configuration-files-in-extends"><code>extends</code> 支持多个配置文件</a></li><li><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#all-enums-are-union-enums">所有的枚举都是联合枚举</a></li><li><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#moduleresolution-bundler"><code>--moduleResolution 配置新增 bundler 支持</code></a></li><li><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#resolution-customization-flags">自定义解析标志</a></li><li><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#verbatimmodulesyntax"><code>--verbatimModuleSyntax</code></a></li><li><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#support-for-export-type">支持 <code>export type *</code></a></li><li><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#satisfies-support-in-jsdoc">JSDoc 支持 <code>@satisfies</code></a></li><li><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#overload-support-in-jsdoc">JSDoc 支持 <code>@overload</code></a></li><li><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#passing-emit-specific-flags-under-build">运行 tsc <code>--build</code> 可以传入的新指令</a></li><li><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#case-insensitive-import-sorting-in-editors">编辑器中不区分大小写的导入排序</a></li><li><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#exhaustive-switch-case-completions"><code>switch</code>&#x2F;<code>case</code> 语法补足</a></li><li><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#speed-memory-and-package-size-optimizations">速度、内存和包大小优化</a></li><li><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#breaking-changes-and-deprecations">重大更改和弃用</a></li><li><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#whats-next">下一步是什么？</a></li></ul><h2 id="自-Beta-和-RC-以来有什么新功能？"><a href="#自-Beta-和-RC-以来有什么新功能？" class="headerlink" title="自 Beta 和 RC 以来有什么新功能？"></a>自 Beta 和 RC 以来有什么新功能？</h2><p>自 <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/">beta 版</a>发布以来， TypeScript 5.0 有几个显著的变化。</p><p>自 TypeScript 5.0 Beta 以来，一个新区别是 TypeScript 允许将<a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#decorators">装饰器</a>放置在 <code>export</code> 和 <code>export default</code> 之前或之后。这一变化反映了 TC39（ECMAScript&#x2F;JavaScript 的标准机构）内部的讨论和共识。</p><p>另一个是<a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#moduleresolution-bundler">新的 <code>bundler</code> 模块解析选项</a>只能在 <code>--module</code> 选项设置为 <code>esnext</code> 时使用。这样做是为了确保在输入文件中写入的 <code>import</code> 语句不会在捆绑器解析它们之前转换为 <code>require</code> 调用，无论捆绑器或加载器是否遵从 TypeScript 的 <code>module</code> 选项。我们还在这些发布说明中提供了一些上下文，建议大多数库作者坚持使用 <code>node16</code> or <code>nodenext</code>。</p><p>虽然 TypeScript 5.0 Beta 附带了此功能，但我们没有记录我们在编辑器场景中支持不<a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#case-insensitive-import-sorting-in-editors">区分大小写的导入排序</a>的工作。这部分是因为用于自定义的 UX 仍在讨论中，但默认情况下，TypeScript 现在应该可以更好地与您的其他工具一起使用。</p><p><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-rc/">自我们的 RC 以来</a>，我们最显著的变化是 TypeScript 5.0 现在在 <code>package.json</code> 中指定了 Node.js 的最低版本为 <code>12.20</code>。 我们还发布了<a href="https://devblogs.microsoft.com/typescript/typescripts-migration-to-modules/">一篇关于 TypeScript 5.0 向 modules 迁移的文章</a>，并提供了链接。</p><p>自 TypeScript 5.0 Beta 和 RC 发布以来，<a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#speed-memory-and-package-size-optimizations">速度基准和包大小增量</a>的具体数字也进行了调整，尽管噪音一直是运行过程中的一个因素。为了清晰起见，还对一些基准的名称进行了调整，包大小的改进也被移至单独的图表中。</p><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器是即将推出的 ECMAScript 功能，它允许我们以可重用的方式自定义类及其成员。</p><p>让我们思考以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    greet() &#123;</span><br><span class="line">        console.log(`Hello, my name is $&#123;this.name&#125;.`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">const p = new Person(&quot;Ron&quot;);</span><br><span class="line">p.greet();</span><br></pre></td></tr></table></figure><p><code>greet</code> 这里很简单，但让我们想象它更复杂——也许它执行一些异步逻辑，它是递归的，它有副作用等等。不管你想象的是哪种场景，假设你抛出了一些 <code>console.log</code> 调用来帮助调试 <code>greet</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    greet() &#123;</span><br><span class="line">        console.log(&quot;LOG: Entering method.&quot;);</span><br><span class="line">​</span><br><span class="line">        console.log(`Hello, my name is $&#123;this.name&#125;.`);</span><br><span class="line">​</span><br><span class="line">        console.log(&quot;LOG: Exiting method.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种模式相当普遍。如果有一种方法我们可以为每种方法做到这一点，那就太好了！</p><p>这就是装饰器的用武之地。我们可以编写一个 <code>loggedMethod</code> 的函数，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function loggedMethod(originalMethod: any, _context: any) &#123;</span><br><span class="line">​</span><br><span class="line">    function replacementMethod(this: any, ...args: any[]) &#123;</span><br><span class="line">        console.log(&quot;LOG: Entering method.&quot;)</span><br><span class="line">        const result = originalMethod.call(this, ...args);</span><br><span class="line">        console.log(&quot;LOG: Exiting method.&quot;)</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    return replacementMethod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“这些 <code>any</code> 都是怎么回事？这是什么，<code>any</code>Script！？”</p><p>请耐心等待——我们暂时保持简单，以便我们可以专注于此函数在做什么。请注意，<code>loggedMethod</code> 接收原始方法 ( <code>originalMethod</code>) 并返回一个函数</p><ol><li>输出“Entering…”日志</li><li><code>this</code> 将其所有参数传递给原始方法</li><li>输出一条“Exiting…”日志，并且</li><li>返回原始方法返回的任何内容。</li></ol><p>现在我们可以使用 <code>loggedMethod</code> 来装饰方法 <code>greet</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    @loggedMethod</span><br><span class="line">    greet() &#123;</span><br><span class="line">        console.log(`Hello, my name is $&#123;this.name&#125;.`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">const p = new Person(&quot;Ron&quot;);</span><br><span class="line">p.greet();</span><br><span class="line">​</span><br><span class="line">// Output:</span><br><span class="line">//</span><br><span class="line">//   LOG: Entering method.</span><br><span class="line">//   Hello, my name is Ron.</span><br><span class="line">//   LOG: Exiting method.</span><br></pre></td></tr></table></figure><p>我们只是在 <code>greet</code> 上面使用了 <code>loggedMethod</code> 作为装饰器 ——注意我们把它写成了 <code>@loggedMethod</code>。当我们这样做时，它会被 target 方法和 context 对象调用。因为 <code>loggedMethod</code> 返回了一个新函数，该函数替换了<code>greet</code>.</p><p>我们还没有提到它，而是 <code>loggedMethod</code> 用第二个参数定义的。它被称为“上下文对象”，它有一些关于如何声明修饰方法的有用信息——比如它是 <code>#private</code> 成员还是静态成员，或者方法的名称是什么。让我们重写 <code>loggedMethod</code> 以利用它并打印出被装饰的方法的名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function loggedMethod(originalMethod: any, context: ClassMethodDecoratorContext) &#123;</span><br><span class="line">    const methodName = String(context.name);</span><br><span class="line">​</span><br><span class="line">    function replacementMethod(this: any, ...args: any[]) &#123;</span><br><span class="line">        console.log(`LOG: Entering method &#x27;$&#123;methodName&#125;&#x27;.`)</span><br><span class="line">        const result = originalMethod.call(this, ...args);</span><br><span class="line">        console.log(`LOG: Exiting method &#x27;$&#123;methodName&#125;&#x27;.`)</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    return replacementMethod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在使用 context 参数——它是 <code>loggedMethod</code> 中第一个具有比 <code>any</code> 和 <code>any[]</code> 更严格的参数类型。TypeScript 提供了一个名为 <code>ClassMethodDecoratorContext</code> 的类型，他对方法装饰器所接收的上下文对象进行建模。</p><p>除了元数据之外，方法的上下文对象还有一个有用的函数，称为 <code>addInitializer</code>。 这是一种挂钩到构造函数开头的方法（如果我们使用<code>static</code>，则挂钩到类本身的初始化）。</p><p>例如——在 JavaScript 中，通常会编写类似以下模式的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">​</span><br><span class="line">        this.greet = this.greet.bind(this);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    greet() &#123;</span><br><span class="line">        console.log(`Hello, my name is $&#123;this.name&#125;.`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，<code>greet</code> 可以声明为初始化为箭头函数的属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    greet = () =&gt; &#123;</span><br><span class="line">        console.log(`Hello, my name is $&#123;this.name&#125;.`);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写此代码是为了确保在 <code>greet</code> 作为独立函数调用或作为回调传递 <code>this</code> 时不会重新绑定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const greet = new Person(&quot;Ron&quot;).greet;</span><br><span class="line">​</span><br><span class="line">// We don&#x27;t want this to fail!</span><br><span class="line">greet();</span><br></pre></td></tr></table></figure><p>我们可以编写一个装饰器，使用 <code>addInitializer</code> 在构造函数中调用 <code>bind</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function bound(originalMethod: any, context: ClassMethodDecoratorContext) &#123;</span><br><span class="line">    const methodName = context.name;</span><br><span class="line">    if (context.private) &#123;</span><br><span class="line">        throw new Error(`&#x27;bound&#x27; cannot decorate private properties like $&#123;methodName as string&#125;.`);</span><br><span class="line">    &#125;</span><br><span class="line">    context.addInitializer(function () &#123;</span><br><span class="line">        this[methodName] = this[methodName].bind(this);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bound</code> 不返回任何东西——所以当它装饰一个方法时，它会保留原来的方法。相反，它将在任何其他字段初始化之前添加逻辑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    @bound</span><br><span class="line">    @loggedMethod</span><br><span class="line">    greet() &#123;</span><br><span class="line">        console.log(`Hello, my name is $&#123;this.name&#125;.`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">const p = new Person(&quot;Ron&quot;);</span><br><span class="line">const greet = p.greet;</span><br><span class="line">​</span><br><span class="line">// Works!</span><br><span class="line">greet();</span><br></pre></td></tr></table></figure><p>请注意，我们堆叠了两个装饰器—— <code>@bound</code> 和 <code>@loggedMethod</code>。这些装饰以“相反的顺序”运行。即 <code>@loggedMethod</code> 装饰原始方法 <code>greet</code>，<code>@bound</code> 装饰 <code>@loggedMethod</code> 的结果 。在此示例中，这并不重要——但如果您的装饰器有副作用或期望特定顺序，则可能会发生这种情况。</p><p>同样值得注意的是：根据你喜欢代码风格，可以将这些装饰器放在同一行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@bound @loggedMethod greet() &#123;</span><br><span class="line">   console.log(`Hello, my name is $&#123;this.name&#125;.`);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能不太明显的是，我们甚至可以创建<em>返回</em>装饰器函数的函数。这使得定制最终的装饰器成为可能。如果我们愿意，我们可以让 <code>loggedMethod</code> 返回一个装饰器并自定义它记录消息的方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function loggedMethod(headMessage = &quot;LOG:&quot;) &#123;</span><br><span class="line">    return function actualDecorator(originalMethod: any, context: ClassMethodDecoratorContext) &#123;</span><br><span class="line">        const methodName = String(context.name);</span><br><span class="line">​</span><br><span class="line">        function replacementMethod(this: any, ...args: any[]) &#123;</span><br><span class="line">            console.log(`$&#123;headMessage&#125; Entering method &#x27;$&#123;methodName&#125;&#x27;.`)</span><br><span class="line">            const result = originalMethod.call(this, ...args);</span><br><span class="line">            console.log(`$&#123;headMessage&#125; Exiting method &#x27;$&#123;methodName&#125;&#x27;.`)</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        return replacementMethod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们这样做，我们必须在使用 <code>loggedMethod</code> 作为装饰器之前调用它。然后我们可以传入任何字符串作为输出到控制台的日志的前缀。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    @loggedMethod(&quot;&quot;)</span><br><span class="line">    greet() &#123;</span><br><span class="line">        console.log(`Hello, my name is $&#123;this.name&#125;.`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">const p = new Person(&quot;Ron&quot;);</span><br><span class="line">p.greet();</span><br><span class="line">​</span><br><span class="line">// Output:</span><br><span class="line">//</span><br><span class="line">//    Entering method &#x27;greet&#x27;.</span><br><span class="line">//   Hello, my name is Ron.</span><br><span class="line">//    Exiting method &#x27;greet&#x27;.</span><br></pre></td></tr></table></figure><p>装饰器不仅仅可以用在方法上！它们可用于属性&#x2F;字段、getter、setter 和自动访问器。甚至类本身也可以为子类化和注册之类的事情进行装饰。</p><p>要深入了解有关装饰器的更多信息，您可以阅读 <a href="https://2ality.com/2022/10/javascript-decorators.html">Axel Rauschmayer 的详尽摘要</a>。</p><p>有关涉及的更改的更多信息，您可以<a href="https://github.com/microsoft/TypeScript/pull/50820">查看原始 pull request</a>。</p><h3 id="与实验性遗留装饰器的差异"><a href="#与实验性遗留装饰器的差异" class="headerlink" title="与实验性遗留装饰器的差异"></a>与实验性遗留装饰器的差异</h3><p>如果您已经使用 TypeScript 一段时间，您可能会意识到它多年来一直支持“实验性”装饰器。虽然这些实验性装饰器非常有用，但它们模拟了一个更旧版本的装饰器提案，并且始终需要一个名为 <code>--experimentalDecorators</code>。 任何在没有此标志的情况下尝试在 TypeScript 中使用装饰器都会提示错误消息。</p><p><code>--experimentalDecorators</code> 在可预见的未来将继续存在；然而，如果没有这个标志，装饰器现在将成为所有新代码的有效语法。在之外<code>--experimentalDecorators</code>，它们将以不同方式进行类型检查和释放。类型检查规则和 emit 完全不同，虽然<em>可以</em>编写装饰器来支持旧的和新的装饰器行为，但任何现有的装饰器函数都不太可能这样做。</p><p>这个新的装饰器提案与 <code>--emitDecoratorMetadata</code> 不兼容，它不允许装饰参数。未来的 ECMAScript 提案可能会帮助弥合这一差距。</p><p>最后一点：除了允许将装饰器放在 <code>export</code> 关键字之前，装饰器提案现在还提供了在 <code>export</code> 或 <code>export default</code> 之后放置装饰器的选项。唯一的例外是不允许混合使用这两种样式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//  allowed</span><br><span class="line">@register export default class Foo &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">//  also allowed</span><br><span class="line">export default @register class Bar &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">//  error - before *and* after is not allowed</span><br><span class="line">@before export @after class Bar &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写类型良好的装饰器"><a href="#编写类型良好的装饰器" class="headerlink" title="编写类型良好的装饰器"></a>编写类型良好的装饰器</h3><p>上面的 <code>loggedMethod</code> 和 <code>bound</code> 装饰器示例有意简单化并省略了很多关于类型的细节。</p><p>键入装饰器可能相当复杂。例如，上面的类型正确的版本 <code>loggedMethod</code> 可能看起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function loggedMethod&lt;This, Args extends any[], Return&gt;(</span><br><span class="line">    target: (this: This, ...args: Args) =&gt; Return,</span><br><span class="line">    context: ClassMethodDecoratorContext&lt;This, (this: This, ...args: Args) =&gt; Return&gt;</span><br><span class="line">) &#123;</span><br><span class="line">    const methodName = String(context.name);</span><br><span class="line">​</span><br><span class="line">    function replacementMethod(this: This, ...args: Args): Return &#123;</span><br><span class="line">        console.log(`LOG: Entering method &#x27;$&#123;methodName&#125;&#x27;.`)</span><br><span class="line">        const result = target.call(this, ...args);</span><br><span class="line">        console.log(`LOG: Exiting method &#x27;$&#123;methodName&#125;&#x27;.`)</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    return replacementMethod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们必须使用类型参数 <code>This</code>、<code>Args</code> 和 <code>Return</code> 分别定义 <code>this</code> 的类型、参数和原始方法的返回类型。</p><p>装饰器函数定义的具体复杂程度取决于您要保证的内容。请记住，您的装饰器将被使用的次数多于它们被编写的次数，因此类型良好的版本通常更可取——但显然需要与可读性进行权衡，因此请尽量保持简单。</p><p>将来会提供更多关于编写装饰器的文档——但<a href="https://2ality.com/2022/10/javascript-decorators.html">这篇文章</a>应该有大量关于装饰器机制的细节。</p><h2 id="const-泛型参数"><a href="#const-泛型参数" class="headerlink" title="const 泛型参数"></a><code>const</code> 泛型参数</h2><p>在推断对象的类型时，TypeScript 通常会选择一种通用的类型。例如，在本例中，<code>names</code> 的推断类型是 <code>string[]</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type HasNames = &#123; readonly names: string[] &#125;;</span><br><span class="line">function getNamesExactly&lt;T extends HasNames&gt;(arg: T): T[&quot;names&quot;] &#123;</span><br><span class="line">    return arg.names;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">// Inferred type: string[]</span><br><span class="line">const names = getNamesExactly(&#123; names: [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;]&#125;);</span><br></pre></td></tr></table></figure><p>通常这样做的目的是使突变成为可能。</p><p>但是，根据 <code>getNamesExactly</code> 的具体功能和用途，通常需要更具体的类型。</p><p>到目前为止，API 作者通常不得不建在某些地方添加 <code>as const</code> 以实现所需的推理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// The type we wanted:</span><br><span class="line">//    readonly [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;]</span><br><span class="line">// The type we got:</span><br><span class="line">//    string[]</span><br><span class="line">const names1 = getNamesExactly(&#123; names: [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;]&#125;);</span><br><span class="line">​</span><br><span class="line">// Correctly gets what we wanted:</span><br><span class="line">//    readonly [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;]</span><br><span class="line">const names2 = getNamesExactly(&#123; names: [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;]&#125; as const);</span><br></pre></td></tr></table></figure><p>这可能很麻烦且容易忘记。在 TypeScript 5.0 中，您现在可以将 <code>const</code> 修饰符添加到类型参数声明中，以使<code>const</code>-like 推理成为默认值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type HasNames = &#123; names: readonly string[] &#125;;</span><br><span class="line">function getNamesExactly&lt;const T extends HasNames&gt;(arg: T): T[&quot;names&quot;] &#123;</span><br><span class="line">//                       ^^^^^</span><br><span class="line">    return arg.names;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">// Inferred type: readonly [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;]</span><br><span class="line">// Note: Didn&#x27;t need to write &#x27;as const&#x27; here</span><br><span class="line">const names = getNamesExactly(&#123; names: [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;] &#125;);</span><br></pre></td></tr></table></figure><p>请注意，<code>const</code> 修饰符不<em>拒绝</em>可变值，也不需要不可变约束。使用可变类型约束可能会产生令人惊讶的结果。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">declare function fnBad&lt;const T extends string[]&gt;(args: T): void;</span><br><span class="line">​</span><br><span class="line">// &#x27;T&#x27; is still &#x27;string[]&#x27; since &#x27;readonly [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#x27; is not assignable to &#x27;string[]&#x27;</span><br><span class="line">fnBad([&quot;a&quot;, &quot;b&quot; ,&quot;c&quot;]);</span><br></pre></td></tr></table></figure><p>在这里，推断的候选项 <code>T</code> 是 <code>readonly [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code>，并且 <code>readonly</code> 不能在需要可变数组的地方使用数组。在这种情况下，推理回退到约束条件，数组被视为 <code>string[]</code>，并且调用仍然成功进行。</p><p>此函数的更好定义应该使用 <code>readonly string[]</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">declare function fnGood&lt;const T extends readonly string[]&gt;(args: T): void;</span><br><span class="line">​</span><br><span class="line">// T is readonly [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fnGood([&quot;a&quot;, &quot;b&quot; ,&quot;c&quot;]);</span><br></pre></td></tr></table></figure><p>同样，请记住修饰符 <code>const</code> 仅影响在调用中编写的对象、数组和原始表达式的推断，因此不会（或不能）修改的参数不会看到 <code>as const</code> 任何行为变化:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">declare function fnGood&lt;const T extends readonly string[]&gt;(args: T): void;</span><br><span class="line">const arr = [&quot;a&quot;, &quot;b&quot; ,&quot;c&quot;];</span><br><span class="line">​</span><br><span class="line">// &#x27;T&#x27; is still &#x27;string[]&#x27;-- the &#x27;const&#x27; modifier has no effect here</span><br><span class="line">fnGood(arr);</span><br></pre></td></tr></table></figure><p>有关更多详细信息，<a href="https://github.com/microsoft/TypeScript/pull/51865">请参阅拉取请求</a>和（<a href="https://github.com/microsoft/TypeScript/issues/30680">第一个</a>和<a href="https://github.com/microsoft/TypeScript/issues/41114">第二个</a>）激励问题。</p><h2 id="extends-支持多个配置文件"><a href="#extends-支持多个配置文件" class="headerlink" title="extends 支持多个配置文件"></a><code>extends</code> 支持多个配置文件</h2><p><code>tsconfig.json</code> 管理多个项目时，拥有一个其他文件可以扩展的“基本”配置文件会很有帮助。这就是为什么 TypeScript 支持 <code>extends</code>从 <code>compilerOptions</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// packages/front-end/src/tsconfig.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;extends&quot;: &quot;../../../tsconfig.base.json&quot;,</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;outDir&quot;: &quot;../lib&quot;,</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，在某些情况下，您可能希望从多个配置文件进行扩展。例如，假设使用<a href="https://github.com/tsconfig/bases">发送到 npm 的 TypeScript 基本配置文件</a>。如果您希望所有项目也使用 npm 包中的选项 <code>@tsconfig/strictest</code>，那么有一个简单的解决方案：扩展 <code>tsconfig.base.json</code> 自<code>@tsconfig/strictest</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// tsconfig.base.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;extends&quot;: &quot;@tsconfig/strictest/tsconfig.json&quot;,</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这在一定程度上起作用。<em>如果</em>您有任何项目<em>不想</em>使用 <code>@tsconfig/strictest</code>，他们必须手动禁用这些选项，或者创建一个短度的 <code>tsconfig.base.json</code> 版本，该版本不扩展 <code>@tsconfig/strictest</code></p><p>为了在此处提供更多灵活性，Typescript 5.0 现在允许该 <code>extends</code> 字段采用多个条目。例如，在这个配置文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;extends&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;],</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写这个有点像 <code>c</code> 直接扩展，其中 <code>c</code> extends <code>b</code> 和 <code>b</code> extends <code>a</code>。如果任何字段“冲突”，则后一个条目获胜。</p><p>所以在下面的例子中， 和 <code>strictNullChecks</code> 都 <code>noImplicitAny</code>在最终的 <code>tsconfig.json</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// tsconfig1.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;strictNullChecks&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">// tsconfig2.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;noImplicitAny&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">// tsconfig.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;extends&quot;: [&quot;./tsconfig1.json&quot;, &quot;./tsconfig2.json&quot;],</span><br><span class="line">    &quot;files&quot;: [&quot;./index.ts&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再举一个例子，我们可以用下面的方式重写我们原来的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// packages/front-end/src/tsconfig.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;extends&quot;: [&quot;@tsconfig/strictest/tsconfig.json&quot;, &quot;../../../tsconfig.base.json&quot;],</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;outDir&quot;: &quot;../lib&quot;,</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有关更多详细信息，<a href="https://github.com/microsoft/TypeScript/pull/50403">请阅读有关原始拉取请求的更多信息</a>。</p><h2 id="所有枚举都是联合枚举"><a href="#所有枚举都是联合枚举" class="headerlink" title="所有枚举都是联合枚举"></a>所有枚举都是联合枚举</h2><p>当 TypeScript 最初引入枚举时，它们只不过是一组具有相同类型的数字常量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum E &#123;</span><br><span class="line">    Foo = 10,</span><br><span class="line">    Bar = 20,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>E.Foo</code> 和 <code>E.Bar</code> 的唯一特别之处在于它们可以赋值给除 <code>E</code> 类型之外的任何类型。除此之外，他们几乎只是 <code>number</code>s。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function takeValue(e: E) &#123;&#125;</span><br><span class="line">​</span><br><span class="line">takeValue(E.Foo); // works</span><br><span class="line">takeValue(123); // error!</span><br></pre></td></tr></table></figure><p>直到 TypeScript 2.0 引入了枚举文字类型，枚举才变得更加特殊。枚举文字类型为每个枚举成员提供了自己的类型，并将枚举本身变成了每个成员类型的<em>联合</em>。它们还允许我们仅引用枚举类型的一个子集，并缩小这些类型的范围。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Color is like a union of Red | Orange | Yellow | Green | Blue | Violet</span><br><span class="line">enum Color &#123;</span><br><span class="line">    Red, Orange, Yellow, Green, Blue, /* Indigo */, Violet</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">// Each enum member has its own type that we can refer to!</span><br><span class="line">type PrimaryColor = Color.Red | Color.Green | Color.Blue;</span><br><span class="line">​</span><br><span class="line">function isPrimaryColor(c: Color): c is PrimaryColor &#123;</span><br><span class="line">    // Narrowing literal types can catch bugs.</span><br><span class="line">    // TypeScript will error here because</span><br><span class="line">    // we&#x27;ll end up comparing &#x27;Color.Red&#x27; to &#x27;Color.Green&#x27;.</span><br><span class="line">    // We meant to use ||, but accidentally wrote &amp;&amp;.</span><br><span class="line">    return c === Color.Red &amp;&amp; c === Color.Green &amp;&amp; c === Color.Blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为每个枚举成员赋予其自己的类型的一个问题是，这些类型在某些部分与成员的实际值相关联。在某些情况下，无法计算该值——例如，枚举成员可以通过函数调用进行初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum E &#123;</span><br><span class="line">    Blah = Math.random()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当 TypeScript 遇到这些问题时，它都会悄悄退出并使用旧的枚举策略。这意味着放弃联合和文字类型的所有优势。</p><p>TypeScript 5.0 通过为每个计算成员创建唯一类型，设法将所有枚举变成联合枚举。这意味着现在可以缩小所有枚举的范围，并将其成员也作为类型引用。</p><p>有关此更改的更多详细信息，您可以<a href="https://github.com/microsoft/TypeScript/pull/50528">阅读 GitHub 上的详细信息</a>。</p><h2 id="moduleResolution-新增-bundler-支持"><a href="#moduleResolution-新增-bundler-支持" class="headerlink" title="--moduleResolution 新增 bundler 支持"></a><code>--moduleResolution 新增 bundler 支持</code></h2><p>TypeScript 4.7 在 <code>--module</code> 和 <code>--moduleResolution</code> 设置中引入了 <code>node16</code> 和 <code>nodenext</code> 选项。这些选项的目的是更好地模拟 Node.js 中 ECMAScript 模块的精确查找规则；然而，这种模式有很多限制，其他工具并没有真正强制执行。</p><p>例如，在 Node.js 的 ECMAScript 模块中，任何相对导入都需要包含文件扩展名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// entry.mjs</span><br><span class="line">import * as utils from &quot;./utils&quot;;     //  wrong - we need to include the file extension.</span><br><span class="line">​</span><br><span class="line">import * as utils from &quot;./utils.mjs&quot;; //  works</span><br></pre></td></tr></table></figure><p>在 Node.js 和浏览器中这样做有一定的原因——它使文件查找更快，并且更适合原始文件服务器。但是对于许多使用捆绑器等工具的开发人员来说，<code>node16</code>&#x2F;<code>nodenext</code>设置很麻烦，因为捆绑器没有这些限制中的大部分。在某些方面，<code>node</code>解析模式对任何使用捆绑器的人来说都更好。</p><p>但在某些方面，原有的 <code>node</code> 解决模式已经落伍了。大多数现代捆绑器在 Node.js 中使用 ECMAScript 模块和 CommonJS 查找规则的融合。例如，无扩展名的导入就像在 CommonJS 中一样工作得很好，但是在查看包的 <a href="https://nodejs.org/api/packages.html#nested-conditions"><code>export</code>条件</a>时，他们会更喜欢 ECMAScript 文件中的 <code>import</code> 条件。</p><p>为了模拟打包器的工作方式，TypeScript 现在引入了一种新策略：<code>--moduleResolution bundler</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;target&quot;: &quot;esnext&quot;,</span><br><span class="line">        &quot;moduleResolution&quot;: &quot;bundler&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您正在使用像 Vite、esbuild、swc、Webpack、Parcel 和其他实施混合查找策略的现代捆绑器，那么新选项 <code>bundler</code> 应该非常适合您。</p><p>另一方面，如果您正在编写一个打算在 npm 上发布的库，则使用该 <code>bundler</code> 选项可以隐藏兼容性问题，这些问题可能会出现在您<em>不</em>使用捆绑器的用户身上。因此，在这些情况下，使用 <code>node16</code> 或 <code>nodenext</code> 解决方案可能是更好的途径。</p><p>要了解更多信息 <code>--moduleResolution bundler</code>，<a href="https://github.com/microsoft/TypeScript/pull/51669">请查看实施拉取请求</a>。</p><h2 id="自定义解析标志"><a href="#自定义解析标志" class="headerlink" title="自定义解析标志"></a>自定义解析标志</h2><p>JavaScript 工具现在可以模拟“混合”解析规则，就像 <code>bundler</code> 我们上面描述的模式一样。由于工具的支持可能略有不同，TypeScript 5.0 提供了启用或禁用一些功能的方法，这些功能可能适用于您的配置，也可能不适用于您的配置。</p><h3 id="allowImportingTsExtensions"><a href="#allowImportingTsExtensions" class="headerlink" title="allowImportingTsExtensions"></a><code>allowImportingTsExtensions</code></h3><p><code>--allowImportingTsExtensions</code> 允许使用特定于 TypeScript 的扩展名（如<code>.ts</code>、<code>.mts</code>或<code>.tsx</code>）。</p><p>此标志仅在 <code>--noEmit</code> 或 <code>--emitDeclarationOnly</code> 启用时才被允许，因为这些导入路径在运行时无法在 JavaScript 输出文件中解析。这里的期望是您的解析器（例如您的捆绑器、运行时或其他一些工具）将使这些 <code>.ts</code> 文件之间的导入工作。</p><h3 id="resolvePackageJsonExports"><a href="#resolvePackageJsonExports" class="headerlink" title="resolvePackageJsonExports"></a><code>resolvePackageJsonExports</code></h3><p><code>--resolvePackageJsonExports</code> 强制 TypeScript 解析 <a href="https://nodejs.org/api/packages.html#exports"><code>package.json</code>的 <code>exports</code> 字段</a>，如果曾经从 <code>node_modules</code> 中的读取过json文件。</p><p>当配置项 <code>--modulerresolve</code> 为 <code>node16</code>、<code>nodenext</code> 和 <code>bundler</code> 时，该选项默认为true。</p><h3 id="resolvePackageJsonImports"><a href="#resolvePackageJsonImports" class="headerlink" title="resolvePackageJsonImports"></a><code>resolvePackageJsonImports</code></h3><p><code>--resolvePackageJsonImports</code> 强制 TypeScript 在从其祖先目录包含 package.json 的文件执行以 # 开头的查找时查询 package.json 文件的导入字段。</p><p>当配置项 <code>--modulerresolve</code> 为 <code>node16</code>、<code>nodenext</code> 和 <code>bundler</code> 时，该选项默认为true。</p><h3 id="allowArbitraryExtensions"><a href="#allowArbitraryExtensions" class="headerlink" title="allowArbitraryExtensions"></a><code>allowArbitraryExtensions</code></h3><p>在 TypeScript 5.0 中，当导入路径以不是已知 JavaScript 或 TypeScript 文件扩展名的扩展名结尾时，编译器将以 <code>&#123;file basename&#125;.d.&#123;extension&#125;.ts</code>。 例如，如果您在捆绑项目中使用 CSS 加载器，您可能希望为这些样式表编写（或生成）声明文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* app.css */</span><br><span class="line">.cookie-banner &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br><span class="line">// app.d.css.ts</span><br><span class="line">declare const css: &#123;</span><br><span class="line">  cookieBanner: string;</span><br><span class="line">&#125;;</span><br><span class="line">export default css;</span><br><span class="line">// App.tsx</span><br><span class="line">import styles from &quot;./app.css&quot;;</span><br><span class="line">​</span><br><span class="line">styles.cookieBanner; // string</span><br></pre></td></tr></table></figure><p>默认情况下，此导入会引发错误，让您知道 TypeScript 不理解此文件类型，并且您的运行时可能不支持导入它。但是，如果您已配置运行时或捆绑程序来处理它，则可以使用新的 <code>--allowArbitraryExtensions</code> 编译器选项来抑制错误。</p><p>请注意，从历史上看，通过添加名为 <code>app.css.d.ts</code> 的声明文件而不是 <code>app.d.css.ts</code> ，通常可以达到类似的效果 ——然而，这只是通过 Node 对 CommonJS 的 <code>require</code> 解析规则起作用。严格来说，前者被解释为一个名为<code>app.css.js</code> 的 JavaScript 文件的声明文件 。因为相对文件导入需要在 Node 的 ESM 支持中包含扩展名，所以 TypeScript 会在我们的示例中 <code>--moduleResolution node16</code> 在或 <code>nodenext</code> 下的 ESM 文件中出错 。</p><p>有关更多信息，请阅读<a href="https://github.com/microsoft/TypeScript/issues/50133">此功能的提案</a>及其<a href="https://github.com/microsoft/TypeScript/pull/51435">相应的拉取请求</a>。</p><h3 id="customConditions"><a href="#customConditions" class="headerlink" title="customConditions"></a><code>customConditions</code></h3><p><code>--customConditions</code> 接收一个附加条件列表，当 TypeScript 从 <code>package.json</code>的 <a href="https://nodejs.org/api/packages.html#exports"><code>exports</code></a> 或 <a href="https://nodejs.org/api/packages.html#imports"><code>imports</code></a> 字段解析时，这些条件将添加到解析器默认使用的任何现有条件中。</p><p>例如，当在 <code>tsconfig.json</code> 中设置此字段时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;target&quot;: &quot;es2022&quot;,</span><br><span class="line">        &quot;moduleResolution&quot;: &quot;bundler&quot;,</span><br><span class="line">        &quot;customConditions&quot;: [&quot;my-condition&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何时候在 <code>package.json</code> 中引用 <code>exports</code> 或 <code>imports</code> 字段时，TypeScript 都会考虑调用 <code>my-condition</code> 的条件。</p><p>因此，当从具有以下内容的包中导入时 <code>package.json</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">    &quot;exports&quot;: &#123;</span><br><span class="line">        &quot;.&quot;: &#123;</span><br><span class="line">            &quot;my-condition&quot;: &quot;./foo.mjs&quot;,</span><br><span class="line">            &quot;node&quot;: &quot;./bar.mjs&quot;,</span><br><span class="line">            &quot;import&quot;: &quot;./baz.mjs&quot;,</span><br><span class="line">            &quot;require&quot;: &quot;./biz.mjs&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TypeScript 将尝试查找与 <code>foo.mjs</code> 对应的文件。</p><p>该字段仅在 <code>--moduleResolution</code> 的 node16、nodenext 和 bundler 选项下有效</p><h2 id="verbatimModuleSyntax"><a href="#verbatimModuleSyntax" class="headerlink" title="--verbatimModuleSyntax"></a><code>--verbatimModuleSyntax</code></h2><p>默认情况下，TypeScript 会做一些叫做 <em>import elision</em> 的事情。基本上，如果你写类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Car &#125; from &quot;./car&quot;;</span><br><span class="line">​</span><br><span class="line">export function drive(car: Car) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TypeScript 检测到您只对类型使用导入，所以输出结果会将此导入代码删除。您的输出 JavaScript 可能看起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export function drive(car) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大多数时候这很好，因为如果 <code>Car</code> 不是从 <code>./car</code> 导出的值，我们将收到运行时错误。</p><p>但它确实为某些边缘情况增加了一层复杂性。例如，请注意没有像这样的语句 <code>import &quot;./car&quot;;</code>——导入被完全删除。这实际上对有无副作用的模块产生影响。</p><p>TypeScript 针对 JavaScript 的 emit 策略还有另外几层复杂性——导入省略并不总是由导入的使用方式驱动——它通常还会参考值的声明方式。所以并不总是很清楚是否像下面这样的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export &#123; Car &#125; from &quot;./car&quot;;</span><br></pre></td></tr></table></figure><p>应该保留或丢弃。如果 <code>Car</code> 用 <code>class</code> 之类的东西声明，那么它可以保存在生成的 JavaScript 文件中。但如果 <code>Car</code> 仅声明为 <code>type</code> 别名或 <code>interface</code>，则 JavaScript 文件 <code>Car</code> 根本不应导出。</p><p>虽然 TypeScript 可能能够根据来自跨文件的信息做出这些发出决定，但并非每个编译器都可以。</p><p>imports 和 exports 的修饰符 <code>type</code> 对这些情况有点帮助。我们可以明确指出导入或导出是否仅用于类型分析，并且可以通过使用修饰符将其完全删除到 JavaScript 文件中 <code>type</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// This statement can be dropped entirely in JS output</span><br><span class="line">import type * as car from &quot;./car&quot;;</span><br><span class="line">​</span><br><span class="line">// The named import/export &#x27;Car&#x27; can be dropped in JS output</span><br><span class="line">import &#123; type Car &#125; from &quot;./car&quot;;</span><br><span class="line">export &#123; type Car &#125; from &quot;./car&quot;;</span><br></pre></td></tr></table></figure><p><code>type</code> 修饰符本身并不是很有用——默认情况下，模块省略仍然会删除导入，并且没有什么强制您区分 <code>type</code> 普通导入和导出。所以 TypeScript 有标志 <code>--importsNotUsedAsValues</code> 来确保你使用 <code>type</code> 修饰符，<code>--preserveValueImports</code>以防止<em>某些</em>模块省略行为，并 <code>--isolatedModules</code> 确保你的 TypeScript 代码适用于不同的编译器。不幸的是，很难理解这 3 个标志的细节，并且仍然存在一些具有意外行为的边缘情况。</p><p><code>--verbatimModuleSyntax</code>TypeScript 5.0 引入了一个名为简化情况的新选项。规则要简单得多——任何没有 <code>type</code> 修饰符的导入或导出都会被保留。任何使用 <code>type</code> 修饰符的东西都会被完全丢弃。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Erased away entirely.</span><br><span class="line">import type &#123; A &#125; from &quot;a&quot;;</span><br><span class="line">​</span><br><span class="line">// Rewritten to &#x27;import &#123; b &#125; from &quot;bcd&quot;;&#x27;</span><br><span class="line">import &#123; b, type c, type d &#125; from &quot;bcd&quot;;</span><br><span class="line">​</span><br><span class="line">// Rewritten to &#x27;import &#123;&#125; from &quot;xyz&quot;;&#x27;</span><br><span class="line">import &#123; type xyz &#125; from &quot;xyz&quot;;</span><br></pre></td></tr></table></figure><p>有了这个新选项，所见即所得。</p><p>不过，当涉及到模块互操作时，这确实有一些影响。在此标志下，当您的设置或文件扩展名暗示不同的模块系统时，ECMAScript <code>import</code>s 和 <code>export</code>s 不会被重写为 <code>require</code> 调用。相反，你会得到一个错误。如果您需要发出使用 <code>require</code> 和 <code>module.exports</code> 的代码，则必须使用早于 ES2015 的 TypeScript 模块语法：</p><table><thead><tr><th>输入TypeScript</th><th>输出 JavaScript</th></tr></thead><tbody><tr><td><code>import foo = require(&quot;foo&quot;);</code></td><td><code>const foo = require(&quot;foo&quot;);</code></td></tr><tr><td><code>function foo() &#123;&#125; function bar() &#123;&#125; function baz() &#123;&#125; export = &#123; foo, bar, baz &#125;;</code></td><td><code>function foo() &#123;&#125; function bar() &#123;&#125; function baz() &#123;&#125; module.exports = &#123; foo, bar, baz &#125;;</code></td></tr></tbody></table><p>虽然这是一个限制，但它确实有助于使一些问题更加明显。例如，忘记在 <a href="https://nodejs.org/api/packages.html#type"><code>package.json</code> 中设置 type 字段</a> 是很常见的。<code>--module node16</code>。因此，开发人员会在没有意识到的情况下开始编写 CommonJS 模块而不是 ES 模块，从而提供令人惊讶的查找规则和 JavaScript 输出。这个新标志确保您有意使用您正在使用的文件类型，因为语法是有意不同的。</p><p>因为 <code>--verbatimModuleSyntax</code> 提供了比 <code>--importsNotUsedAsValues</code> 和 <code>--preserveValueImports</code> 更一致的故事，所以这两个现有的标志已被弃用。</p><p>有关更多详细信息，请阅读<a href="https://github.com/microsoft/TypeScript/pull/52203">原始拉取请求</a>及其<a href="https://github.com/microsoft/TypeScript/issues/51479">提案问题</a>。</p><h2 id="支持-export-type"><a href="#支持-export-type" class="headerlink" title="支持 export type *"></a>支持 <code>export type *</code></h2><p>当 TypeScript 3.8 引入纯类型导入时，新语法不允许用于 <code>export * from &quot;module&quot;</code> 或 <code>export * as ns from &quot;module&quot;</code> 重新导出。TypeScript 5.0 添加了对这两种形式的支持：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// models/vehicles.ts</span><br><span class="line">export class Spaceship &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">// models/index.ts</span><br><span class="line">export type * as vehicles from &quot;./vehicles&quot;;</span><br><span class="line">​</span><br><span class="line">// main.ts</span><br><span class="line">import &#123; vehicles &#125; from &quot;./models&quot;;</span><br><span class="line">​</span><br><span class="line">function takeASpaceship(s: vehicles.Spaceship) &#123;</span><br><span class="line">  //  ok - `vehicles` only used in a type position</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">function makeASpaceship() &#123;</span><br><span class="line">  return new vehicles.Spaceship();</span><br><span class="line">  //         ^^^^^^^^</span><br><span class="line">  // &#x27;vehicles&#x27; cannot be used as a value because it was exported using &#x27;export type&#x27;.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以<a href="https://github.com/microsoft/TypeScript/pull/52217">在此处阅读有关实施的更多信息</a>。</p><h2 id="JSDoc-支持-satisfies"><a href="#JSDoc-支持-satisfies" class="headerlink" title="JSDoc 支持 @satisfies"></a>JSDoc 支持 <code>@satisfies</code></h2><p>TypeScript 4.9 引入了 <code>satisfies</code> 运算符。它确保表达式的类型兼容，而不影响类型本身。例如，让我们看下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">interface CompilerOptions &#123;</span><br><span class="line">    strict?: boolean;</span><br><span class="line">    outDir?: string;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">interface ConfigSettings &#123;</span><br><span class="line">    compilerOptions?: CompilerOptions;</span><br><span class="line">    extends?: string | string[];</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">let myConfigSettings = &#123;</span><br><span class="line">    compilerOptions: &#123;</span><br><span class="line">        strict: true,</span><br><span class="line">        outDir: &quot;../lib&quot;,</span><br><span class="line">        // ...</span><br><span class="line">    &#125;,</span><br><span class="line">​</span><br><span class="line">    extends: [</span><br><span class="line">        &quot;@tsconfig/strictest/tsconfig.json&quot;,</span><br><span class="line">        &quot;../../../tsconfig.base.json&quot;</span><br><span class="line">    ],</span><br><span class="line">​</span><br><span class="line">&#125; satisfies ConfigSettings;</span><br></pre></td></tr></table></figure><p>在这里，TypeScript 知道它 <code>myConfigSettings.extends</code> 是用数组声明的——因为在 <code>satisfies</code> 验证我们对象的类型时，它并没有直接将其更改为 <code>ConfigSettings</code> 并丢失信息。所以如果我们想映射过来 <code>extends</code>，那很好。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">declare function resolveConfig(configPath: string): CompilerOptions;</span><br><span class="line">​</span><br><span class="line">let inheritedConfigs = myConfigSettings.extends.map(resolveConfig);</span><br></pre></td></tr></table></figure><p>这对 TypeScript 用户很有帮助，但是很多人使用 TypeScript 来使用 JSDoc 注释对他们的 JavaScript 代码进行类型检查。这就是为什么 TypeScript 5.0 支持一个名为 JSDoc 的新标签，<code>@satisfies</code>它做的事情完全一样。</p><p><code>/** @satisfies */</code> 可以捕获类型不匹配：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// @ts-check</span><br><span class="line">​</span><br><span class="line">/**</span><br><span class="line"> * @typedef CompilerOptions</span><br><span class="line"> * @prop &#123;boolean&#125; [strict]</span><br><span class="line"> * @prop &#123;string&#125; [outDir]</span><br><span class="line"> */</span><br><span class="line">​</span><br><span class="line">/**</span><br><span class="line"> * @satisfies &#123;CompilerOptions&#125;</span><br><span class="line"> */</span><br><span class="line">let myCompilerOptions = &#123;</span><br><span class="line">    outdir: &quot;../lib&quot;,</span><br><span class="line">//  ~~~~~~ oops! we meant outDir</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但它会保留我们表达式的原始类型，允许我们稍后在代码中更精确地使用我们的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// @ts-check</span><br><span class="line">​</span><br><span class="line">/**</span><br><span class="line"> * @typedef CompilerOptions</span><br><span class="line"> * @prop &#123;boolean&#125; [strict]</span><br><span class="line"> * @prop &#123;string&#125; [outDir]</span><br><span class="line"> */</span><br><span class="line">​</span><br><span class="line">/**</span><br><span class="line"> * @typedef ConfigSettings</span><br><span class="line"> * @prop &#123;CompilerOptions&#125; [compilerOptions]</span><br><span class="line"> * @prop &#123;string | string[]&#125; [extends]</span><br><span class="line"> */</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">/**</span><br><span class="line"> * @satisfies &#123;ConfigSettings&#125;</span><br><span class="line"> */</span><br><span class="line">let myConfigSettings = &#123;</span><br><span class="line">    compilerOptions: &#123;</span><br><span class="line">        strict: true,</span><br><span class="line">        outDir: &quot;../lib&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    extends: [</span><br><span class="line">        &quot;@tsconfig/strictest/tsconfig.json&quot;,</span><br><span class="line">        &quot;../../../tsconfig.base.json&quot;</span><br><span class="line">    ],</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">let inheritedConfigs = myConfigSettings.extends.map(resolveConfig);</span><br></pre></td></tr></table></figure><p><code>/** @satisfies */</code>也可以在任何带括号的表达式上内联使用。我们可以 <code>myConfigSettings</code>这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let myConfigSettings = /** @satisfies &#123;ConfigSettings&#125; */ (&#123;</span><br><span class="line">    compilerOptions: &#123;</span><br><span class="line">        strict: true,</span><br><span class="line">        outDir: &quot;../lib&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    extends: [</span><br><span class="line">        &quot;@tsconfig/strictest/tsconfig.json&quot;,</span><br><span class="line">        &quot;../../../tsconfig.base.json&quot;</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>为什么？好吧，当您更深入地了解其他一些代码（例如函数调用）时，它通常更有意义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compileCode(/** @satisfies &#123;ConfigSettings&#125; */ (&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p><a href="https://github.com/microsoft/TypeScript/pull/51753">此功能由</a><a href="https://github.com/a-tarasyuk">Oleksandr Tarasiuk</a>提供！</p><h2 id="JSDoc-支持-overload"><a href="#JSDoc-支持-overload" class="headerlink" title="JSDoc 支持 @overload"></a>JSDoc 支持 <code>@overload</code></h2><p>在 TypeScript 中，您可以为函数指定重载。重载为我们提供了一种方式，可以用不同的参数调用一个函数，并可能返回不同的结果。他们可以限制调用者实际使用我们函数的方式，并优化他们将返回的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Our overloads:</span><br><span class="line">function printValue(str: string): void;</span><br><span class="line">function printValue(num: number, maxFractionDigits?: number): void;</span><br><span class="line">​</span><br><span class="line">// Our implementation:</span><br><span class="line">function printValue(value: string | number, maximumFractionDigits?: number) &#123;</span><br><span class="line">    if (typeof value === &quot;number&quot;) &#123;</span><br><span class="line">        const formatter = Intl.NumberFormat(&quot;en-US&quot;, &#123;</span><br><span class="line">            maximumFractionDigits,</span><br><span class="line">        &#125;);</span><br><span class="line">        value = formatter.format(value);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们说过 <code>printValue</code> 将 <code>string</code>或 <code>number</code> 作为其第一个参数。如果它需要一个 <code>number</code>，它可以使用第二个参数来确定我们可以打印多少个小数位。</p><p>TypeScript 5.0 现在允许 JSDoc 使用新标签声明重载 <code>@overload</code>。每个带有标记的 JSDoc 注释都 <code>@overload</code> 被视为以下函数声明的不同重载。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// @ts-check</span><br><span class="line">​</span><br><span class="line">/**</span><br><span class="line"> * @overload</span><br><span class="line"> * @param &#123;string&#125; value</span><br><span class="line"> * @return &#123;void&#125;</span><br><span class="line"> */</span><br><span class="line">​</span><br><span class="line">/**</span><br><span class="line"> * @overload</span><br><span class="line"> * @param &#123;number&#125; value</span><br><span class="line"> * @param &#123;number&#125; [maximumFractionDigits]</span><br><span class="line"> * @return &#123;void&#125;</span><br><span class="line"> */</span><br><span class="line">​</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;string | number&#125; value</span><br><span class="line"> * @param &#123;number&#125; [maximumFractionDigits]</span><br><span class="line"> */</span><br><span class="line">function printValue(value, maximumFractionDigits) &#123;</span><br><span class="line">    if (typeof value === &quot;number&quot;) &#123;</span><br><span class="line">        const formatter = Intl.NumberFormat(&quot;en-US&quot;, &#123;</span><br><span class="line">            maximumFractionDigits,</span><br><span class="line">        &#125;);</span><br><span class="line">        value = formatter.format(value);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，无论我们是在 TypeScript 还是 JavaScript 文件中编写，TypeScript 都可以让我们知道我们是否错误地调用了我们的函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// all allowed</span><br><span class="line">printValue(&quot;hello!&quot;);</span><br><span class="line">printValue(123.45);</span><br><span class="line">printValue(123.45, 2);</span><br><span class="line">​</span><br><span class="line">printValue(&quot;hello!&quot;, 123); // error!</span><br></pre></td></tr></table></figure><p>这个新标签的<a href="https://github.com/microsoft/TypeScript/pull/51234">实现</a>要归功于<a href="https://github.com/apendua">Tomasz Lenarcik</a>。</p><h2 id="在tsc-build-时可以传入的新指令"><a href="#在tsc-build-时可以传入的新指令" class="headerlink" title="在tsc --build 时可以传入的新指令"></a>在tsc <code>--build</code> 时可以传入的新指令</h2><p>TypeScript 现在允许在 <code>--build</code> 模式下传递以下指令</p><ul><li><code>--declaration</code></li><li><code>--emitDeclarationOnly</code></li><li><code>--declarationMap</code></li><li><code>--sourceMap</code></li><li><code>--inlineSourceMap</code></li></ul><p>这使得自定义构建的某些部分变得更加容易，您可能有不同的开发和生产构建。</p><p>例如，库的开发构建可能不需要生成声明文件，但生产构建需要。项目可以将声明发射配置为默认关闭，只需使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --build -p ./my-project-dir</span><br></pre></td></tr></table></figure><p>一旦在内循环中完成迭代，“生产”构建就可以传递指令 <code>--declaration</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --build -p ./my-project-dir --declaration</span><br></pre></td></tr></table></figure><p><a href="https://github.com/microsoft/TypeScript/pull/51241">有关此更改的更多信息，请参见此处</a>。</p><h2 id="编辑器中不区分大小写的导入排序"><a href="#编辑器中不区分大小写的导入排序" class="headerlink" title="编辑器中不区分大小写的导入排序"></a>编辑器中不区分大小写的导入排序</h2><p>在 Visual Studio 和 VS Code 等编辑器中，TypeScript 支持组织和排序导入和导出的体验。但是，对于列表何时“排序”，通常会有不同的解释。</p><p>例如，下面的导入列表是否排序？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">    Toggle,</span><br><span class="line">    freeze,</span><br><span class="line">    toBoolean,</span><br><span class="line">&#125; from &quot;./utils&quot;;</span><br></pre></td></tr></table></figure><p>答案可能令人惊讶地是“视情况而定”。如果我们<em>不</em>关心区分大小写，那么这个列表显然没有排序。这封信 <code>f</code> 出现在 <code>t</code> 和之前 <code>T</code>。</p><p>但在大多数编程语言中，排序默认是比较字符串的字节值。JavaScript 比较字符串的方式意味着 <code>&quot;Toggle&quot;</code> 总是在前面 <code>&quot;freeze&quot;</code> ，因为根据 <a href="https://en.wikipedia.org/wiki/ASCII">ASCII 字符编码</a>，大写字母在小写字母之前。所以从这个角度来看，导入列表是排序的。</p><p>TypeScript 之前考虑对导入列表进行排序，因为它正在进行基本的区分大小写的排序。<em>对于喜欢不区分</em>大小写排序的开发人员，或者使用像 ESLint 这样默认需要不区分大小写排序的工具的开发人员来说，这可能是一个令人沮丧的地方。</p><p>TypeScript 现在默认检测区分大小写。这意味着 TypeScript 和 ESLint 等工具通常不会就如何最好地对导入进行排序而相互“争吵”。</p><p>我们的团队也一直在试验<a href="https://github.com/microsoft/TypeScript/pull/52115">进一步的排序策略，您可以在此处阅读有关内容</a>。这些选项最终可能由编辑器配置。目前，它们仍然不稳定且处于试验阶段，您现在可以通过使用 <code>typescript.unstable</code> JSON 选项中的条目在 VS Code 中选择加入它们。以下是您可以尝试的所有选项（设置为默认值）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;typescript.unstable&quot;: &#123;</span><br><span class="line">        // Should sorting be case-sensitive? Can be:</span><br><span class="line">        // - true</span><br><span class="line">        // - false</span><br><span class="line">        // - &quot;auto&quot; (auto-detect)</span><br><span class="line">        &quot;organizeImportsIgnoreCase&quot;: &quot;auto&quot;,</span><br><span class="line">​</span><br><span class="line">        // Should sorting be &quot;ordinal&quot; and use code points or consider Unicode rules? Can be:</span><br><span class="line">        // - &quot;ordinal&quot;</span><br><span class="line">        // - &quot;unicode&quot;</span><br><span class="line">        &quot;organizeImportsCollation&quot;: &quot;ordinal&quot;,</span><br><span class="line">​</span><br><span class="line">        // Under `&quot;organizeImportsCollation&quot;: &quot;unicode&quot;`,</span><br><span class="line">        // what is the current locale? Can be:</span><br><span class="line">        // - [any other locale code]</span><br><span class="line">        // - &quot;auto&quot; (use the editor&#x27;s locale)</span><br><span class="line">        &quot;organizeImportsLocale&quot;: &quot;en&quot;,</span><br><span class="line">​</span><br><span class="line">        // Under `&quot;organizeImportsCollation&quot;: &quot;unicode&quot;`,</span><br><span class="line">        // should upper-case letters or lower-case letters come first? Can be:</span><br><span class="line">        // - false (locale-specific)</span><br><span class="line">        // - &quot;upper&quot;</span><br><span class="line">        // - &quot;lower&quot;</span><br><span class="line">        &quot;organizeImportsCaseFirst&quot;: false,</span><br><span class="line">​</span><br><span class="line">        // Under `&quot;organizeImportsCollation&quot;: &quot;unicode&quot;`,</span><br><span class="line">        // do runs of numbers get compared numerically (i.e. &quot;a1&quot; &lt; &quot;a2&quot; &lt; &quot;a100&quot;)? Can be:</span><br><span class="line">        // - true</span><br><span class="line">        // - false</span><br><span class="line">        &quot;organizeImportsNumericCollation&quot;: true,</span><br><span class="line">​</span><br><span class="line">        // Under `&quot;organizeImportsCollation&quot;: &quot;unicode&quot;`,</span><br><span class="line">        // do letters with accent marks/diacritics get sorted distinctly</span><br><span class="line">        // from their &quot;base&quot; letter (i.e. is é different from e)? Can be</span><br><span class="line">        // - true</span><br><span class="line">        // - false</span><br><span class="line">        &quot;organizeImportsAccentCollation&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;javascript.unstable&quot;: &#123;</span><br><span class="line">        // same options valid here...</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以阅读<a href="https://github.com/microsoft/TypeScript/pull/51733">有关自动检测和指定不区分大小写的原始工作</a>的更多详细信息，然后是<a href="https://github.com/microsoft/TypeScript/pull/52115">更广泛的选项集</a>。</p><h2 id="switch-case-语法补足"><a href="#switch-case-语法补足" class="headerlink" title="switch&#x2F;case 语法补足"></a><code>switch</code>&#x2F;<code>case</code> 语法补足</h2><p>在编写 <code>switch</code> 语句时，TypeScript 现在会检测被检查的值何时具有文字类型。如果是这样，它将提供一个完成每个未发现的脚手架 <code>case</code>。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f46be8a37aea48dbbb6e2f5e2163f435~tplv-k3u1fbpfcp-watermark.image" alt="exhaustiveCaseCompletions-5.0-stable-1.gif"></p><p>您可以<a href="https://github.com/microsoft/TypeScript/pull/50996">在 GitHub 上查看实施细节</a>。</p><h2 id="速度、内存和包大小优化"><a href="#速度、内存和包大小优化" class="headerlink" title="速度、内存和包大小优化"></a>速度、内存和包大小优化</h2><p>TypeScript 5.0 在我们的代码结构、数据结构和算法实现中包含许多强大的变化。这些都意味着你的整个体验应该更快——不仅仅是运行 TypeScript，甚至安装它。</p><p>以下是我们相对于 TypeScript 4.9 在速度和大小方面取得的一些有趣的胜利。</p><table><thead><tr><th>设想</th><th>时间或大小相对于 TS 4.9</th></tr></thead><tbody><tr><td>material-ui 构建时间</td><td>90%</td></tr><tr><td>TypeScript 编译器启动时间</td><td>89%</td></tr><tr><td>编剧建造时间</td><td>88%</td></tr><tr><td>TypeScript Compiler 自建时间</td><td>87%</td></tr><tr><td>Outlook Web 构建时间</td><td>82%</td></tr><tr><td>VS 代码构建时间</td><td>80%</td></tr><tr><td>打字稿 npm 包大小</td><td>59%</td></tr></tbody></table><p><a href="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/03/speed-5.0-stable-2.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73208158996a434d98515e52316ecd17~tplv-k3u1fbpfcp-zoom-1.image" alt="TypeScript 5.0 相对于 TypeScript 4.9 的构建/运行时间图表：material-ui docs 构建时间：90%； 编剧建造时间：88%； tsc 启动时间：87%； tsc 构建时间：87%； Outlook Web 构建时间：82%； VS 代码构建时间：80%"></a></p><p><a href="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/03/size-5.0-stable-1.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ac8162940ec44d796be80db5e65c423~tplv-k3u1fbpfcp-zoom-1.image" alt="TypeScript 4.9 和 5.0 之间的 npm 包大小图表。 4.9 包大小为 63.8 MB，5.0 包大小为 37.4 MB。"></a></p><p>如何？有一些显着的改进，我们希望在未来提供更多细节。但我们不会让您等待那篇博文。</p><p>首先，我们最近将 TypeScript 从命名空间迁移到模块，使我们能够利用现代构建工具来执行范围提升等优化。使用此工具、重新审视我们的打包策略并删除一些已弃用的代码，已将 TypeScript 4.9 的 63.8 MB 包大小减少了约 26.4 MB。它还通过直接函数调用为我们带来了显着的加速。我们在这里整理了<a href="https://devblogs.microsoft.com/typescript/typescripts-migration-to-modules/">一份关于我们迁移到模块的详细文章</a>。</p><p>TypeScript 还为编译器中的内部对象类型增加了更多的统一性，并且还精简了存储在其中一些对象类型上的数据。这减少了多态操作，同时平衡了因使我们的对象形状更统一而增加的内存使用量。</p><p>在将信息序列化为字符串时，我们还执行了一些缓存。类型显示可能作为错误报告、声明发出、代码完成等的一部分发生，最终可能会相当昂贵。TypeScript 现在缓存了一些常用的机制以在这些操作中重用。</p><p>我们做出的另一个改进解析器的显着变化是利用 <code>var</code> 偶尔回避使用 <code>let</code> 和 <code>const</code> 跨闭包的成本。这提高了我们的一些解析性能。</p><p>总的来说，我们预计大多数代码库应该会看到 TypeScript 5.0 的速度提升，并且始终能够重现 10% 到 20% 之间的胜利。当然，这将取决于硬件和代码库特性，但我们鼓励您今天就在您的代码库上尝试一下！</p><p>有关详细信息，请参阅我们的一些显着优化：</p><ul><li><a href="https://github.com/microsoft/TypeScript/pull/51387">迁移到模块</a></li><li><a href="https://github.com/microsoft/TypeScript/pull/51682"><code>Node</code> 单体化</a></li><li><a href="https://github.com/microsoft/TypeScript/pull/51880"><code>Symbol</code> 单体化</a></li><li><a href="https://github.com/microsoft/TypeScript/pull/52170"><code>Identifier</code> 缩小尺寸</a></li><li><a href="https://github.com/microsoft/TypeScript/pull/52382"><code>Printer</code> 缓存</a></li><li><a href="https://github.com/microsoft/TypeScript/issues/52924">限制使用 <code>var</code></a></li></ul><h2 id="重大更改和弃用"><a href="#重大更改和弃用" class="headerlink" title="重大更改和弃用"></a>重大更改和弃用</h2><h3 id="运行时要求"><a href="#运行时要求" class="headerlink" title="运行时要求"></a>运行时要求</h3><p>TypeScript 现在以 ECMAScript 2018 为目标。TypeScript 包还设置了最低预期引擎 12.20。对于 Node 用户，这意味着 TypeScript 5.0 的最低版本要求至少为 Node.js 12.20 及更高版本。</p><h3 id="lib-d-ts变化"><a href="#lib-d-ts变化" class="headerlink" title="lib.d.ts变化"></a><code>lib.d.ts</code>变化</h3><p>更改 DOM 类型的生成方式可能会对现有代码产生影响。值得注意的是，某些属性已从 <code>number</code> 数字文字类型转换为数字文字类型，并且用于剪切、复制和粘贴事件处理的属性和方法已跨界面移动。</p><h3 id="API-重大变更"><a href="#API-重大变更" class="headerlink" title="API 重大变更"></a>API 重大变更</h3><p>在 TypeScript 5.0 中，<a href="https://devblogs.microsoft.com/typescript/typescripts-migration-to-modules/">我们转向了模块</a>，删除了一些不必要的接口，并进行了一些正确性改进。有关更改内容的更多详细信息，请参阅我们的<a href="https://github.com/microsoft/TypeScript/wiki/API-Breaking-Changes">API 重大更改</a>页面。</p><h3 id="关系运算符中禁止的隐式强制转换"><a href="#关系运算符中禁止的隐式强制转换" class="headerlink" title="关系运算符中禁止的隐式强制转换"></a>关系运算符中禁止的隐式强制转换</h3><p>如果您编写的代码可能会导致隐式的字符串到数字强制转换，则 TypeScript 中的某些操作会警告您：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function func(ns: number | string) &#123;</span><br><span class="line">  return ns * 4; // Error, possible implicit coercion</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 5.0 中，这也将应用于关系运算符<code>&gt;</code>、<code>&lt;</code>、<code>&lt;=</code>和<code>&gt;=</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function func(ns: number | string) &#123;</span><br><span class="line">  return ns &gt; 4; // Now also an error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要，要允许这样做，您可以显式地将操作数强制为<code>number</code>using <code>+</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function func(ns: number | string) &#123;</span><br><span class="line">  return +ns &gt; 4; // OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此<a href="https://github.com/microsoft/TypeScript/pull/52048">正确性改进由</a> <a href="https://github.com/Andarist">Mateusz Burzyński</a> 提供。</p><h3 id="枚举大修"><a href="#枚举大修" class="headerlink" title="枚举大修"></a>枚举大修</h3><p><code>enum</code> 自从它的第一个版本以来，TypeScript 就一直存在一些关于 s 的奇怪之处。在 5.0 中，我们正在清理其中的一些问题，并减少理解 <code>enum</code> 您可以声明的各种 s 所需的概念数。</p><p>作为其中的一部分，您可能会看到两个主要的新错误。首先是将域外文字分配给类型 <code>enum</code> 现在会像人们预期的那样出错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum SomeEvenDigit &#123;</span><br><span class="line">    Zero = 0,</span><br><span class="line">    Two = 2,</span><br><span class="line">    Four = 4</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">// Now correctly an error</span><br><span class="line">let m: SomeEvenDigit = 1;</span><br></pre></td></tr></table></figure><p>另一个是用混合数字和间接字符串枚举引用声明值的枚举会错误地创建一个全数字 <code>enum</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum Letters &#123;</span><br><span class="line">    A = &quot;a&quot;</span><br><span class="line">&#125;</span><br><span class="line">enum Numbers &#123;</span><br><span class="line">    one = 1,</span><br><span class="line">    two = Letters.A</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">// Now correctly an error</span><br><span class="line">const t: number = Numbers.two;</span><br></pre></td></tr></table></figure><p>您可以<a href="https://github.com/microsoft/TypeScript/pull/50528">在相关更改中查看更多详细信息</a>。</p><h3 id="对构造函数中的参数装饰器进行更准确的类型检查-experimentalDecorators"><a href="#对构造函数中的参数装饰器进行更准确的类型检查-experimentalDecorators" class="headerlink" title="对构造函数中的参数装饰器进行更准确的类型检查--experimentalDecorators"></a>对构造函数中的参数装饰器进行更准确的类型检查<code>--experimentalDecorators</code></h3><p>TypeScript 5.0 使 <code>--experimentalDecorators</code>。这一点变得明显的一个地方是在构造函数参数上使用装饰器时。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export declare const inject:</span><br><span class="line">  (entity: any) =&gt;</span><br><span class="line">    (target: object, key: string | symbol, index?: number) =&gt; void;</span><br><span class="line">​</span><br><span class="line">export class Foo &#123;&#125;</span><br><span class="line">​</span><br><span class="line">export class C &#123;</span><br><span class="line">    constructor(@inject(Foo) private x: any) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此调用将失败，因为<code>key</code>需要一个 <code>string | symbol</code>，但构造函数参数收到一个键 <code>undefined</code>。<code>key</code> 正确的解决方法是更改 within 的类型 <code>inject</code>。如果您使用的是无法升级的库，一个合理的解决方法是包装 <code>inject</code> 一个类型更安全的装饰器函数，并在<code>key</code>.</p><p>更多详情，<a href="https://github.com/microsoft/TypeScript/issues/52435">请参阅本期</a>。</p><h3 id="弃用和默认更改"><a href="#弃用和默认更改" class="headerlink" title="弃用和默认更改"></a>弃用和默认更改</h3><p>在 TypeScript 5.0 中，我们弃用了以下设置和设置值：</p><ul><li><code>--target: ES3</code></li><li><code>--out</code></li><li><code>--noImplicitUseStrict</code></li><li><code>--keyofStringsOnly</code></li><li><code>--suppressExcessPropertyErrors</code></li><li><code>--suppressImplicitAnyIndexErrors</code></li><li><code>--noStrictGenericChecks</code></li><li><code>--charset</code></li><li><code>--importsNotUsedAsValues</code></li><li><code>--preserveValueImports</code></li><li><code>prepend</code>在项目参考中</li></ul><p>在 TypeScript 5.5 之前，这些配置将继续被允许，届时它们将被完全删除，但是，如果您正在使用这些设置，您将收到警告。在 TypeScript 5.0 以及未来版本 5.1、5.2、5.3 和 5.4 中，您可以指定 <code>&quot;ignoreDeprecations&quot;: &quot;5.0&quot;</code> 屏蔽这些警告提示。我们还将很快发布一个 4.9 补丁，以允许指定 <code>ignoreDeprecations</code> 以允许更平滑的升级。除了弃用之外，我们还更改了一些设置以更好地改进 TypeScript 中的跨平台行为。</p><p><code>--newLine</code>，它控制 JavaScript 文件中发出的行尾，如果未指定，过去常常根据当前操作系统进行推断。我们认为构建应该尽可能具有确定性，并且 Windows 记事本现在支持换行符行结尾，因此新的默认设置是 <code>LF</code>。 旧的特定于操作系统的推理行为不再可用。</p><p><code>--forceConsistentCasingInFileNames</code>, 这确保了项目中对同一文件名的所有引用都在大小写中达成一致，现在默认为 <code>true</code>。 这有助于捕获在不区分大小写的文件系统上编写的代码的差异问题。</p><p>您可以留下反馈并查看<a href="https://github.com/microsoft/TypeScript/issues/51909">有关 5.0 弃用跟踪问题的更多信息</a></p><h2 id="下一步是什么？"><a href="#下一步是什么？" class="headerlink" title="下一步是什么？"></a>下一步是什么？</h2><p>不要操之过急，TypeScript 5.1 已经在开发中了，<a href="https://github.com/microsoft/TypeScript/issues/53031">我们所有的计划都已经在 GitHub 上了</a>。如果你跃跃欲试，我们鼓励你尝试 <a href="https://www.typescriptlang.org/docs/handbook/nightly-builds.html">TypeScript 的每日构建版本</a>或针对 <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-typescript-next">VS Code 的 JavaScript 和 TypeScript Nightly 扩展</a>！</p><p>当然，如果您选择只享受 TypeScript 的新稳定版，我们也不会感到受伤。我们希望 TypeScript 5.0 让每个人的编码更快、更有趣。</p><p>Happy Hacking!</p><p>– Daniel Rosenwasser 和 TypeScript 团队</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;原文地址：&lt;/em&gt;&lt;a href=&quot;https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/&quot;&gt;Announcing TypeScript 5.0&lt;/a&gt;&lt;/</summary>
      
    
    
    
    <category term="外文翻译" scheme="http://example.com/categories/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="外文翻译" scheme="http://example.com/tags/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    
    <category term="typescript" scheme="http://example.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>[译] 尤雨溪：Vue 2022 回顾及 2023 展望</title>
    <link href="http://example.com/2023/03/01/review2022/"/>
    <id>http://example.com/2023/03/01/review2022/</id>
    <published>2023-03-01T02:09:31.000Z</published>
    <updated>2023-03-01T02:09:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/vue3-ecosystem.png" alt="vue3-ecosystem.png"></p><p><a href="https://blog.vuejs.org/posts/2022-year-in-review.html">原文: 2022 Year In Review</a></p><p><a href="https://www.youtube.com/watch?v=OrT0tHGXyqE">尤雨溪youtobe演进：Vue.js Nation 2023</a></p><p>新年快乐，Vue 社区！2023 年即将到来，我们想借此机会回顾一下 2022 年发生的事情，并讨论 2023 年的期望</p><h2 id="回顾-2022-年"><a href="#回顾-2022-年" class="headerlink" title="回顾 2022 年"></a>回顾 2022 年</h2><p>2022 年 2 月，我们<a href="https://blog.vuejs.org/posts/vue-3-as-the-new-default.html">将 Vue 的默认版本切换为 3.x</a>。这一转变标志着 v3 框架的所有官方部分都已准备就绪，包括对提供最新最佳实践指南的文档进行重大修改。</p><p>我们仍处于生态系统迁移到 Vue 3 的过渡期。因此，在转换之后，我们更专注于通过开发工具来改善 Vue 的开发人员体验。我们的团队成员一直积极参与<a href="https://vitejs.dev/"> Vite </a>的开发，我们通过发布<a href="https://blog.vuejs.org/posts/volar-1.0.html"> Volar 1.0 </a>对 Vue 的 IDE 和 TypeScript 支持进行了重大改进。</p><p>在 2022 年期间，我们看到 Vue 3 的 NPM 使用率增长了<strong>近 200%</strong> 。在社区方面，Vue 3生态系统现在已经成熟，提供了出色的解决方案，可以帮助提高你的开发效率。<a href="https://nuxt.com/">Nuxt 3</a> 和 <a href="https://vuetifyjs.com/">Vuetify 3</a> 均在 2022 年 11 月达到稳定状态，<a href="https://github.com/nativescript-vue/nativescript-vue">NativeScript for Vue 3</a> 最近推出了测试版。此外，我们想对长时间支持 Vue 3 的优秀项目表示感谢：<a href="https://quasar.dev/">Quasar</a>、<a href="https://www.naiveui.com/">NaiveUI</a>、<a href="https://ionicframework.com/docs/vue/overview">Ionic Vue</a>、<a href="https://www.primefaces.org/primevue/">PrimeVue</a>、<a href="https://www.inkline.io/">InkLine</a>、<a href="https://element-plus.org/">ElementPlus</a>、<a href="https://twitter.com/vuejs/status/1599706412086878208">更多…</a>。</p><p>尽管 Vue 3 现在是默认的，但我们知道由于迁移成本，许多用户不得不继续使用 Vue 2。为了确保 Vue 2 用户从框架的进步中受益，我们决定将 Vue 2 的源代码转移到 TypeScript，并在 <a href="https://blog.vuejs.org/posts/vue-2-7-naruto.html">Vue 2.7</a> 中向后移植了一些最重要的 Vue 3 功能。我们还确保 Vite、Vue Devtools 和 Volar 都同时支持 Vue 2 和 Vue 3。</p><h2 id="2023-年会发生什么"><a href="#2023-年会发生什么" class="headerlink" title="2023 年会发生什么"></a>2023 年会发生什么</h2><h3 id="较小和更频繁的次要版本"><a href="#较小和更频繁的次要版本" class="headerlink" title="较小和更频繁的次要版本"></a>较小和更频繁的次要版本</h3><p>随着最后一个 Vue 2 次要版本 (2.7) 的发布，我们预计将在 2023 年全速推出 Vue 3 核心的功能。我们有很长的功能列表，我们很高兴能继续努力！</p><p>我们想要改进我们的发布节奏。Vue 遵循 <a href="https://semver.org/">semver</a>，这意味着我们应该只发布次要版本的功能。过去，我们采用“大次要”方法，我们将许多功能组合在大的、不频繁的次要版本中。这导致在我们处理其他高复杂性功能时，相当多的低复杂性功能被阻止。在 2023 年，我们希望发布更小、更频繁的次要版本，以便我们能够更快地推出更多功能。</p><p>这也意味着我们将调整 3.3 中的内容。本来，我们计划在 3.3 中将 Suspense 和 Reactivity Transform 脱离实验阶段。但是，我们认为两者仍需要进一步的 RFC 讨论，并且它们不应阻碍其他更直接的功能落地。现在，3.3 的目标是明确且不需要 RFC 讨论的提议&#x2F;计划功能 - 例如，支持<code>&lt;script setup&gt;</code>宏中的外部导入类型。</p><p>与此同时，我们将：</p><ol><li>进一步评估 Suspense 和 Reactivity Transform 的准备情况。</li><li>花时间评估未完成的用户提交的 RFC 和功能请求。</li><li>发布我们打算在 3.4 及更高版本中实现的功能的 RFC，例如 SSR 懒惰水合（SSR lazy hydration）。</li></ol><p>预计本月晚些时候会有更多细节。</p><p>另一件需要注意的事情是，在可预见的未来没有重大突破性变化的计划。认识到用户在 v2 到 v3 过渡期间面临的挑战，我们希望 Vue 有一个更好的长期升级故事。</p><h3 id="Vapor模式"><a href="#Vapor模式" class="headerlink" title="Vapor模式"></a>Vapor模式</h3><p>Vapor Mode 是我们一直在试验的另一种编译策略，其灵感来自<a href="https://www.solidjs.com/">Solid</a>。给定相同的 Vue SFC，与当前基于虚拟 DOM 的输出相比，Vapor Mode 将其编译成性能更高、使用更少内存且需要更少运行时支持代码的 JavaScript 输出。它仍处于早期阶段，但这里有一些高层次的要点：</p><ul><li>Vapor 模式适用于主要关注性能的用例。它是可选的，不会影响现有的代码库。</li><li>至少，您将能够将 Vapor 组件子树嵌入到任何现有的 Vue 3 应用程序中。理想情况下，我们希望在组件级别实现精细的选择加入，这意味着在同一个应用程序中自由混合 Vapor 和非 Vapor 组件。</li><li>只使用 Vapor 组件构建应用程序允许您从包中删除虚拟 DOM 运行时，极大地减少基线运行时大小。</li><li>为了获得最佳性能，Vapor 模式将只支持 Vue 功能的一个子集。特别是，Vapor Mode 组件将仅支持 Composition API 和<code>&lt;script setup&gt;</code>。但是，这个受支持的子集在 Vapor 和非 Vapor 组件之间的工作方式完全相同。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/img/vue3-ecosystem.png&quot; alt=&quot;vue3-ecosystem.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.vuejs.org/posts/2022-year-in-review.html&quot;&gt;原文: 2</summary>
      
    
    
    
    <category term="外文翻译" scheme="http://example.com/categories/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
    <category term="外文翻译" scheme="http://example.com/tags/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>[译] 2023年JavaScript的发展趋势</title>
    <link href="http://example.com/2023/02/24/trends/"/>
    <id>http://example.com/2023/02/24/trends/</id>
    <published>2023-02-24T04:00:00.000Z</published>
    <updated>2023-02-24T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>原文地址：<a href="https://www.jamesqquick.com/blog/javascript-trends-2023/">https://www.jamesqquick.com/blog/javascript-trends-2023/</a></em></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2022年，比 Node.js 快三倍的 Bun 火速出圈，成为 JavaScript 框架中的当红炸子鸡，如何把握JavaScript 发展趋势和选择正确的技术方向对于前端开发而言至关重要。</p><p>众所周知，JavaScript 的生态系统发展非常迅速。事实上我们很难完全跟上它的发展节奏，下面让我们快速了解一下2023年应该关注的 JavaScript 发展趋势。</p><h2 id="需要写的-Javascript-代码量会更少"><a href="#需要写的-Javascript-代码量会更少" class="headerlink" title="需要写的 Javascript 代码量会更少"></a>需要写的 Javascript 代码量会更少</h2><p>下面我列了几个原因来解释：为什么今年我们不再需要写那么多 JavaScript 代码了。</p><h3 id="1-TypeScript"><a href="#1-TypeScript" class="headerlink" title="1. TypeScript"></a>1. TypeScript</h3><p>这个听起来可能有点骇人听闻，但事实确实如此。TypeScript 的增长速度非常快。每天我都会听到越来越多的人说他们离不开 TypeScript。尽管 TypeScript 很明显非常类似于 JavaScript，但从技术上层面来讲，它和 JavaScript 迥然不同。</p><h3 id="2-AI服务"><a href="#2-AI服务" class="headerlink" title="2. AI服务"></a>2. AI服务</h3><p>说实话，我一直对 AI 服务能否为我们提供建议和编写代码持怀疑态度。但是我对诸如Github <a href="https://github.com/features/copilot">Copilot</a> 和 <a href="https://openai.com/blog/chatgpt/">ChatGPT</a>这样的工具感到非常惊讶。他们所能做的真的难以令人置信。尽管我认为他们不会取代我们的工作，但是我认为他们会为我们编写越来越多的代码，以至于我们需要自己去写的代码越来越少了。</p><h3 id="3-后端即服务平台"><a href="#3-后端即服务平台" class="headerlink" title="3. 后端即服务平台"></a>3. 后端即服务平台</h3><blockquote><p>“我比较倾向于项目的构建速度，如果可以使用类似这样的平台为我处理后端，我完全赞成！”</p></blockquote><p>后端即服务平台的增长意味着我们自己编写的代码会减少，像<a href="https://supabase.com/">Supabase</a>, <a href="https://appwrite.io/">Appwrite</a>等平台可以处理数据库交互，身份认证，实时更新等等，使我们没有必要亲自去写这些代码。有些人可能更喜欢自己去编写所有代码，但我不是这样。我更喜欢快速构建项目，如果有像这样的一个平台可以为我处理后端，我完全赞成！</p><h3 id="4-我们使用-JavaScript-语言来编写工具更少了"><a href="#4-我们使用-JavaScript-语言来编写工具更少了" class="headerlink" title="4. 我们使用 JavaScript 语言来编写工具更少了"></a>4. 我们使用 JavaScript 语言来编写工具更少了</h3><blockquote><p>“也许现在是时候去学其他语言了……”</p></blockquote><p>使用JavaScript编写JavaScript开发工具的现象将会越来越少了，听起来有点奇怪，对吧？以下是一些用不同语言编写的JavaScript工具示例。</p><ul><li><a href="https://esbuild.github.io/">esbuild</a> - Go</li><li><a href="https://turbo.build/pack">Turbopack</a> - Rust</li><li><a href="https://bun.sh/">Bun</a> - Zig</li></ul><p>越来越多的开发者正在使用其他的语言编写 JavaScript 工具，因为他们的性能会更好。预计这种趋势会持续下去！</p><h3 id="5-使用更多的-JavaScript-运行环境（不仅仅是-Node-js）"><a href="#5-使用更多的-JavaScript-运行环境（不仅仅是-Node-js）" class="headerlink" title="5. 使用更多的 JavaScript 运行环境（不仅仅是 Node.js）"></a>5. 使用更多的 JavaScript 运行环境（不仅仅是 Node.js）</h3><p>长期以来，Node.js 一直是“如何在服务上使用 JavaScript ？”的默认答案，但是现在要被改变了。我认为开发者社区已经意识到 Node 的局限性，并更倾向于使用其他替代方案。现在有几种其他的 JavaScript 运行环境可供选择。</p><ul><li><a href="https://deno.land/">Deno</a></li><li><a href="https://bun.sh/">Bun</a></li><li><a href="https://blog.cloudflare.com/workerd-open-source-workers-runtime/">Workers (from Cloudflare)</a></li></ul><p>随着“边缘计算”（无论这意味这什么）的不断发展，不同的运行环境将被使用的范围也会越来越大。</p><h3 id="6-减少向浏览器发送-JavaScript"><a href="#6-减少向浏览器发送-JavaScript" class="headerlink" title="6. 减少向浏览器发送 JavaScript"></a>6. 减少向浏览器发送 JavaScript</h3><blockquote><p>“对于最大程度利用服务器性能，在我最喜欢的一些框架如Next.js 和 SvelteKit最近更新中都体现的非常明显；”</p></blockquote><p>随着 Web 应用程序性能变得越来越重要，这已经成为一种趋势。你不得不承认，网站的性能可以直接影响你的营收底线。提高应用程序的一种方法就是减少向浏览器传输 JavaScript，而各种框架都在采取这种方式。</p><p>就个人而言，我认为 Remix 对推动框架更多地关注服务器而非浏览器发挥的巨大作用。从一开始，Remix 就具有在服务器上加载数据的钩子，因此无需在浏览器中执行该操作。这种最大程度利用服务器性能，在我最喜欢的一些框架 如Next.js 和 SvelteKit 最近更新中体现也很明显；</p><p>此外，我最喜欢的新框架之一 Astro 默认情况下不向浏览器发送任何 JavaScript。它的主要目标是提高性能。如果你还没有了解过它，我强烈推荐你去了解一下。</p><h3 id="7-出现更多-JavaScript-元框架"><a href="#7-出现更多-JavaScript-元框架" class="headerlink" title="7. 出现更多 JavaScript 元框架"></a>7. 出现更多 JavaScript 元框架</h3><p>提到元框架（无论现在我们如何称呼它们）我们通常会想到诸如 Next.js、SvelteKit 等这样的框架，不过我认为我们将会看到更多框架出现。说实话，虽然目前已经有太多框架让人眼花缭乱，但就我而言不反对继续创建更多的框架</p><p>无论是新的还是现有的框架，我认为开发者将会继续选择元框架，因为它们可以为我们节省大量的时间和精力。凡事均要权衡，但是元框架正在为我们处理越来越多的样板代码，我认为 JavaScript 开发者很喜欢这一点！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;原文地址：&lt;a href=&quot;https://www.jamesqquick.com/blog/javascript-trends-2023/&quot;&gt;https://www.jamesqquick.com/blog/javascript-tren</summary>
      
    
    
    
    <category term="外文翻译" scheme="http://example.com/categories/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
    <category term="外文翻译" scheme="http://example.com/tags/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>vue组件通信及vuex原理解析</title>
    <link href="http://example.com/2020/03/20/vuex/"/>
    <id>http://example.com/2020/03/20/vuex/</id>
    <published>2020-03-20T15:47:09.000Z</published>
    <updated>2020-03-20T15:47:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="组件传值"><a href="#组件传值" class="headerlink" title="组件传值"></a>组件传值</h3><p>组件是 vue.js强大的功能之一，而组件实例的作用域是相互独立的，这就意味着不同组件之间的数据无法相互引用。一般来说，组件可以有以下几种关系：</p><h4 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h4><ol><li><code>props</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件：</span></span><br><span class="line">&lt;<span class="title class_">HelloWorld</span> msg=<span class="string">&quot;Welcome to Your Vue.js + TypeScript App&quot;</span>/&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="attr">props</span>: &#123; <span class="attr">msg</span>: <span class="title class_">String</span> &#125; </span><br></pre></td></tr></table></figure><ol start="2"><li><code>$attrs</code> 子组件未在props中声明的属性</li></ol><blockquote><p> inheritAttrs: false </p></blockquote>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">HelloWorld</span> <span class="attr">msg</span>=<span class="string">&quot;Welcome to Your Vue.js + TypeScript App&quot;</span> <span class="attr">foo</span>=<span class="string">&quot;foo&quot;</span>/&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;$attrs.foo&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span>/&gt;</span> // placeholder type ...</span><br></pre></td></tr></table></figure><ol start="3"><li><code>$refs</code>: 如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;I am hw componet&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    say () &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;<span class="title class_">HelloWorld</span> :msg=<span class="string">&quot;msg&quot;</span> foo=<span class="string">&quot;foo&quot;</span> @changeMsg=<span class="string">&quot;changeMsg&quot;</span> ref=<span class="string">&quot;hw&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"> mounted () &#123;</span><br><span class="line">      <span class="keyword">const</span> hw = <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">hw</span>;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(hw.<span class="property">title</span>);  <span class="comment">// I am hw componet</span></span><br><span class="line">      comA.<span class="title function_">sayHello</span>();  <span class="comment">// 弹窗 Hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><code>$parent</code> &#x2F; <code>$children</code>：访问父 &#x2F; 子实例</li></ol><blockquote><p>$children子元素不保证顺序</p></blockquote><h4 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h4><p>  <code>$emit</code>、<code>$on</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;changeMsg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;<span class="title class_">HelloWorld</span> :msg=<span class="string">&quot;msg&quot;</span> foo=<span class="string">&quot;foo&quot;</span> @changeMsg=<span class="string">&quot;changeMsg&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="title function_">changeMsg</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">msg</span> = <span class="string">&#x27;hello world!&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="兄弟传值：-通过共同的祖辈组件搭桥，-parent或-root"><a href="#兄弟传值：-通过共同的祖辈组件搭桥，-parent或-root" class="headerlink" title="兄弟传值： 通过共同的祖辈组件搭桥，$parent或$root"></a>兄弟传值： 通过共同的祖辈组件搭桥，$parent或$root</h4>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// brother1</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$parent</span>.$on(<span class="string">&#x27;foo&#x27;</span>, handle)</span><br><span class="line"><span class="comment">// brother2</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$parent</span>.$emit(<span class="string">&#x27;foo&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="祖代传值"><a href="#祖代传值" class="headerlink" title="祖代传值"></a>祖代传值</h4><ul><li><code>provide</code>: Object | () &#x3D;&gt; Object</li><li><code>inject</code>: Array<string> | { [key: string]: string | Symbol | Object }</li></ul><blockquote><p><code>provide</code> 和 <code>inject</code> 主要在开发高阶插件&#x2F;组件库时使用。并不推荐用于普通应用程序代码中。<a href="https://blog.csdn.net/liubangbo/article/details/101198344">原理解析</a> </p></blockquote><blockquote><p>【注意】：<strong>provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的</strong></p></blockquote>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">provide () &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">bar</span>: <span class="string">&#x27;provide value&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// inject: [&#x27;bar&#x27;]</span></span><br><span class="line"><span class="attr">inject</span>: &#123;</span><br><span class="line">    <span class="attr">bar</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: string,</span><br><span class="line">        <span class="attr">default</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>实现provide与inject响应化</p><ul><li><p><code>不推荐</code> rovide祖先组件的实例，然后在子孙组件中注入依赖，这样就可以在子孙组件中<code>直接修改祖先组件的实例的属性</code>，不过这种方法有个缺点就是这个实例上挂载很多没有必要的东西比如props，methods</p></li><li><p><code>推荐</code> 2.6.0 新增API Vue.observable 优化响应式</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="built_in">string</span> = <span class="string">&quot;Welcome to Your Vue.js + TypeScript App&quot;</span>;</span><br><span class="line">  <span class="comment">// 调用Vue.observable声明响应数据appTheme  </span></span><br><span class="line">  <span class="attr">appTheme</span>: <span class="title class_">Theme</span> = <span class="title class_">Vue</span>.<span class="title function_">observable</span>(&#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&quot;red&quot;</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="meta">@Provide</span>() <span class="attr">bar</span>: <span class="built_in">string</span> = <span class="string">&quot;root message&quot;</span>; <span class="comment">// 普通字符</span></span><br><span class="line">  <span class="meta">@Provide</span>() <span class="attr">theme</span>: <span class="built_in">object</span> = <span class="variable language_">this</span>.<span class="property">appTheme</span>; <span class="comment">// 响应数据</span></span><br><span class="line">  <span class="meta">@Provide</span>() <span class="attr">app</span>: <span class="built_in">object</span> = <span class="variable language_">this</span>; <span class="comment">// 当前组件实例</span></span><br><span class="line">    </span><br><span class="line">  <span class="title function_">changeMsg</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">msg</span> = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  <span class="meta">@Inject</span>(&#123; <span class="attr">default</span>: <span class="string">&quot;&quot;</span> &#125;) bar!: <span class="built_in">string</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Inject</span>(&#123;</span><br><span class="line">  <span class="attr">default</span>: <span class="function">() =&gt;</span> (&#123;&#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  theme!: <span class="built_in">object</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span>()</span><br><span class="line">  app!: <span class="built_in">any</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">theme</span>, <span class="variable language_">this</span>.<span class="property">app</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">app</span>.<span class="property">msg</span> = <span class="string">&#x27;hw&#x27;</span> <span class="comment">// 直接在子组件中修改父组件的属性 (父组件不能响应变化)</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">app</span>.<span class="title function_">changeMsg</span>(); <span class="comment">// 调用父组件的方法(子组件不能响应变化)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>EventBus 事件总线</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化event-bus.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">EventBus</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// comA组件: 派发add事件</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">EventBus</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./eventBus/event-bus&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">eveAdd</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">EventBus</span>.$emit(<span class="string">&#x27;add&#x27;</span>, ++<span class="variable language_">this</span>.<span class="property">count</span>)</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// comB组件：监听add事件，展示add之后的结果</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">EventBus</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./eventBus/event-bus&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">num</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">EventBus</span>.$on(<span class="string">&quot;add&quot;</span>, <span class="function"><span class="params">count</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">num</span> = count;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Vuex核心概念"><a href="#Vuex核心概念" class="headerlink" title="Vuex核心概念"></a>Vuex核心概念</h3><ol><li>state</li></ol><ul><li>管理vuex的数据（官方称之为单一状态树）</li></ul><ol start="2"><li>getter</li></ol><ul><li>state 中派生出一些状态</li></ul><ol start="3"><li>mutation</li></ol><ul><li>更改 Vuex 的 store 中的状态的<code>唯一</code>方法是提交 mutation</li><li><code>必须</code>是同步函数</li></ul><ol start="4"><li>action</li></ol><ul><li>Action 提交的是 mutation，而不是直接变更状态</li><li>Action 可以包含任意异步操作</li></ul><ol start="5"><li>module</li></ol><ul><li><p>模块化（当应用变得特别复杂时，所有状态都会集中到一个较大的对象中，就会变得非常臃肿，按照模块精心分割，每个模块都拥有自己的state、mutation、action、getter）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="attr">state</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  <span class="attr">state</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: moduleA,</span><br><span class="line">    <span class="attr">b</span>: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.<span class="property">state</span>.<span class="property">a</span> <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.<span class="property">state</span>.<span class="property">b</span> <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure></li><li><p>问题：mutation中执行异步操作会怎么样？</p><blockquote><p>事实上在 vuex 里面 actions 只是一个架构性的概念，并不是必须的，说到底只是一个函数，你在里面想干嘛都可以，只要最后触发 mutation 就行</p><p>— <a href="https://www.zhihu.com/question/48759748">尤雨溪知乎回答</a></p></blockquote></li></ul><h3 id="Vuex-源码解析"><a href="#Vuex-源码解析" class="headerlink" title="Vuex 源码解析"></a>Vuex <a href="https://github.com/vuejs/vuex">源码</a>解析</h3><ul><li>Vue.use(Vuex) 做了什么？为什么axios不用Vue.use()方法？</li><li>new Vue({store}) store 在这里做了什么？ 为什么？</li></ul> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// vuex.js 实现commit dispatch getter方法</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> <span class="title class_">Vue</span></span><br><span class="line"><span class="comment">// 实现install方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">install</span>(<span class="params">_Vue</span>) &#123;</span><br><span class="line">    <span class="title class_">Vue</span> = _Vue</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">        <span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">store</span>) &#123; <span class="comment">// vue的原型上挂载store（Store的实例）</span></span><br><span class="line">                <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$store</span> = <span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">store</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现Store类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">            <span class="comment">// 实现state响应化</span></span><br><span class="line">            <span class="attr">data</span>: options.<span class="property">state</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">mutations</span> = options.<span class="property">mutations</span> || &#123;&#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">actions</span> = options.<span class="property">actions</span> || &#123;&#125;</span><br><span class="line">        options.<span class="property">getters</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">handleGetters</span>(options.<span class="property">getters</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    commit = <span class="function">(<span class="params">type, arg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">mutations</span>[type](<span class="variable language_">this</span>.<span class="property">state</span>, arg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dispatch方法接受一个上下文执行环境，注意与commit区分</span></span><br><span class="line">    <span class="title function_">dispatch</span>(<span class="params">type, arg</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">actions</span>[type](&#123;</span><br><span class="line">            <span class="attr">state</span>: <span class="variable language_">this</span>.<span class="property">state</span>,</span><br><span class="line">            <span class="attr">commit</span>: <span class="variable language_">this</span>.<span class="property">commit</span>,</span><br><span class="line">            <span class="attr">getters</span>: <span class="variable language_">this</span>.<span class="property">getters</span></span><br><span class="line">        &#125;, arg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">handleGetters</span>(<span class="params">getters</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">getters</span> = &#123;&#125;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">keys</span>(getters).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 利用defineProtperty将getters的执行结果映射成对象</span></span><br><span class="line">            <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>.<span class="property">getters</span>, key, &#123;</span><br><span class="line">                <span class="attr">get</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> getters[key](<span class="variable language_">this</span>.<span class="property">state</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title class_">Store</span>,</span><br><span class="line">    install</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;组件传值&quot;&gt;&lt;a href=&quot;#组件传值&quot; class=&quot;headerlink&quot; title=&quot;组件传值&quot;&gt;&lt;/a&gt;组件传值&lt;/h3&gt;&lt;p&gt;组件是 vue.js强大的功能之一，而组件实例的作用域是相互独立的，这就意味着不同组件之间的数据无法相互引用。一般来说，组件</summary>
      
    
    
    
    <category term="vuex" scheme="http://example.com/categories/vuex/"/>
    
    
    <category term="vuex" scheme="http://example.com/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>js 数组方法总结 之 一道面试题引发的思考</title>
    <link href="http://example.com/2019/11/07/arr-methods/"/>
    <id>http://example.com/2019/11/07/arr-methods/</id>
    <published>2019-11-07T02:09:31.000Z</published>
    <updated>2019-11-07T02:09:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前端面试当中高频出现的一道面试题，让我产生了把js数组的方法总结一下的念头，呐，就是下面这道题目！看了解析先别撤哦，后面留了几道提升题目，你值得拥有（皮这一下很开心~~）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">map</span>(<span class="built_in">parseInt</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析：</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> <span class="built_in">parseInt</span>(item, index));</span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">2</span>, <span class="number">1</span>); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 故：结果为 [1, NaN, NaN]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 考点分析：</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>)&#123;&#125;)方法回调函数的参数</span><br><span class="line"></span><br><span class="line"><span class="comment">// currentValue 当前元素的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index 当前元素的索引值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr 原数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(string, radix) 函数的参数</span><br><span class="line"></span><br><span class="line"><span class="comment">// radix该值介于 2 ~ 36 之间,如果省略该参数或其值为 0，则数字将以 10 为基础来解析</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果它以 “0x” 或 “0X” 开头，将以 16 为基数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由此看出，主要是考察对数组方法的熟悉程度，接下来，我们一起回顾下数组的方法。特别需要是否改变原数组这一点，会对我们的变成带来意想不到的副作用。</p><h3 id="转化方法"><a href="#转化方法" class="headerlink" title="转化方法"></a>转化方法</h3><table><thead><tr><th>方法名</th><th>功能描述</th><th>是否改变原数组</th><th>返回结果</th><th>示例代码及输出</th></tr></thead><tbody><tr><td><code>.toString()</code></td><td>将数组转换为一个以逗号分隔的字符串</td><td>否</td><td>字符串</td><td><code>[1, 2, 3].toString()</code> → <code>&quot;1,2,3&quot;</code></td></tr><tr><td><code>.valueOf()</code></td><td>返回数组对象的原始值（仍为数组本身）</td><td>否</td><td>数组</td><td><code>[1, 2, &#39;3&#39;].valueOf()</code> → <code>[1, 2, &quot;3&quot;]</code></td></tr><tr><td><code>.join(separator)</code></td><td>用指定的分隔符连接数组元素成为字符串</td><td>否</td><td>字符串</td><td><code>[1, 2, 3].join(&#39;-&#39;)</code> → <code>&quot;1-2-3&quot;</code></td></tr></tbody></table><h3 id="栈方法（LIFO）"><a href="#栈方法（LIFO）" class="headerlink" title="栈方法（LIFO）"></a>栈方法（LIFO）</h3><table><thead><tr><th>方法名</th><th>功能描述</th><th>是否改变原数组</th><th>返回结果</th><th>示例代码及输出</th></tr></thead><tbody><tr><td><code>.push(element1[, ...elements])</code></td><td>在数组末尾添加元素</td><td>是</td><td>新数组长度</td><td><code>[1, 2].push(3)</code> → <code>3</code>, 数组：<code>[1, 2, 3]</code></td></tr><tr><td><code>.pop()</code></td><td>移除并返回数组的最后一个元素</td><td>是</td><td>移除的元素</td><td><code>[1, 2].pop()</code> → <code>2</code>, 数组：<code>[1]</code></td></tr></tbody></table><h3 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h3><table><thead><tr><th>方法名</th><th>功能描述</th><th>是否改变原数组</th><th>返回结果</th><th>示例代码及输出</th></tr></thead><tbody><tr><td><code>.unshift(element1[, ...elements])</code></td><td>在数组开头添加元素</td><td>是</td><td>新数组长度</td><td><code>[1, 2].unshift(0)</code> → <code>3</code>, 数组：<code>[0, 1, 2]</code></td></tr><tr><td><code>.shift()</code></td><td>移除并返回数组的第一个元素</td><td>是</td><td>移除的元素</td><td><code>[1, 2].shift()</code> → <code>1</code>, 数组：<code>[2]</code></td></tr></tbody></table><h3 id="重排方法"><a href="#重排方法" class="headerlink" title="重排方法"></a>重排方法</h3><table><thead><tr><th>方法名</th><th>功能描述</th><th>是否改变原数组</th><th>返回结果</th><th>示例代码及输出</th></tr></thead><tbody><tr><td><code>.sort([compareFunction])</code></td><td>对数组元素进行排序，可选自定义比较函数</td><td>是</td><td>排序后的数组</td><td><code>[1, 3, 11, 2].sort((a, b) =&gt; a - b)</code> → <code>[1, 2, 3, 11]</code></td></tr><tr><td><code>.reverse()</code></td><td>颠倒数组中元素的顺序</td><td>是</td><td>颠倒后的数组</td><td><code>[1, 2, 3].reverse()</code> → <code>[3, 2, 1]</code></td></tr></tbody></table><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><table><thead><tr><th>方法名</th><th>功能描述</th><th>是否改变原数组</th><th>返回结果</th><th>示例代码及输出</th></tr></thead><tbody><tr><td><code>.concat(array2[, ...arrays])</code></td><td>连接两个或更多数组，并返回新数组</td><td>否</td><td>新数组</td><td><code>[1, 2].concat([3, 4])</code> → <code>[1, 2, 3, 4]</code></td></tr><tr><td><code>.splice(start[, deleteCount[, ...items]])</code></td><td>在数组中添加&#x2F;删除项目，并返回被删除的元素数组</td><td>是</td><td>被删除的元素数组</td><td><code>[1, 2].splice(0, 1)</code> → <code>[1]</code><br><code>[1, 2].splice(0, 0, 3)</code> → <code>[]</code>, 数组：<code>[1, 2, 3]</code></td></tr><tr><td><code>.slice(start[, end])</code></td><td>提取原数组的一部分，并返回一个新的数组</td><td>否</td><td>新数组</td><td><code>[1, 2, 3, 4].slice(1, 3)</code> → <code>[2, 3]</code></td></tr></tbody></table><h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><table><thead><tr><th>方法名</th><th>功能描述</th><th>是否改变原数组</th><th>返回结果</th><th>示例代码及输出</th></tr></thead><tbody><tr><td><code>.indexOf(searchElement[, fromIndex])</code></td><td>查找数组中指定元素首次出现的位置，未找到返回-1</td><td>否</td><td>索引或-1</td><td><code>[1, 2, 3].indexOf(3)</code> → <code>2</code></td></tr><tr><td><code>.lastIndexOf(searchElement[, fromIndex])</code></td><td>从数组末尾向前查找指定元素最后一次出现的位置，未找到返回-1</td><td>否</td><td>索引或-1</td><td><code>[1, 2, 3].lastIndexOf(3)</code> → <code>2</code></td></tr></tbody></table><h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><table><thead><tr><th>方法名</th><th>功能描述</th><th>是否改变原数组</th><th>返回结果</th><th>示例代码及输出</th></tr></thead><tbody><tr><td><code>.every(callback[, thisArg])</code></td><td>判断数组的所有元素是否都满足测试函数，都满足则返回true</td><td>否</td><td>boolean</td><td><code>[1, 2, 3].every(item =&gt; item &gt; 0)</code> → <code>true</code></td></tr><tr><td><code>.some(callback[, thisArg])</code></td><td>判断数组中是否存在至少一个元素满足测试函数，存在则返回true</td><td>否</td><td>boolean</td><td><code>[1, 2, 3].some(item =&gt; item &gt; 2)</code> → <code>true</code></td></tr><tr><td><code>.filter(callback[, thisArg])</code></td><td>根据测试函数过滤数组元素，并返回符合条件的新数组</td><td>否</td><td>新数组</td><td><code>[1, 2, 3].filter(item =&gt; item &gt; 2)</code> → <code>[3]</code></td></tr><tr><td><code>.forEach(callback[, thisArg])</code></td><td>对数组中的每个元素执行给定函数，无返回值</td><td>否</td><td>无返回值</td><td>N&#x2F;A</td></tr><tr><td><code>.map(callback[, thisArg])</code></td><td>遍历数组，对每个元素执行给定函数，并返回处理后的新数组</td><td>否</td><td>新数组</td><td><code>[1, 2, 3].map(item =&gt; item * 2)</code> → <code>[2, 4, 6]</code></td></tr></tbody></table><h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><table><thead><tr><th>方法名</th><th>功能描述</th><th>是否改变原数组</th><th>返回结果</th><th>示例代码及输出</th></tr></thead><tbody><tr><td><code>.reduce(callback[, initialValue])</code></td><td>从左到右遍历数组，累积计算结果，返回单一最终值</td><td>否</td><td>累计结果</td><td><code>[1, 2, 3].reduce((prev, cur) =&gt; prev + cur)</code> → <code>6</code></td></tr><tr><td><code>.reduceRight(callback[, initialValue])</code></td><td>从右到左遍历数组，累积计算结果，返回单一最终值</td><td>否</td><td>累计结果</td><td><code>[1, 2, 3].reduceRight((prev, cur) =&gt; prev + cur)</code> → <code>6</code></td></tr></tbody></table><h3 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">map</span>(<span class="built_in">parseInt</span>);    <span class="comment">// [1, NaN, NaN]</span></span><br><span class="line"></span><br><span class="line">==&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> <span class="built_in">parseInt</span>(item, index));</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">filter</span>(<span class="built_in">parseInt</span>); <span class="comment">// [1]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">every</span>(<span class="built_in">parseInt</span>);  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">some</span>(<span class="built_in">parseInt</span>);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">reduce</span>(<span class="built_in">parseInt</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">==&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> <span class="built_in">parseInt</span>(prev, cur))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在前端面试当中高频出现的一道面试题，让我产生了把js数组的方法总结一下的念头，呐，就是下面这道题目！看了解析先别撤哦，后面留了几道提升题目，你值得拥有（皮这一下很开心~~）&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;t</summary>
      
    
    
    
    <category term="js" scheme="http://example.com/categories/js/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
    <category term="数组方法" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>虚拟DOM和原生谁更快</title>
    <link href="http://example.com/2019/03/26/virtual-dom/"/>
    <id>http://example.com/2019/03/26/virtual-dom/</id>
    <published>2019-03-26T01:52:30.000Z</published>
    <updated>2019-03-26T01:52:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="论题：-虚拟DOM和原生谁更快"><a href="#论题：-虚拟DOM和原生谁更快" class="headerlink" title="论题： 虚拟DOM和原生谁更快"></a>论题： 虚拟DOM和原生谁更快</h3><p><a href="https://www.zhihu.com/question/31809713/answer/53544875">虚拟DOM和原生谁更快？</a></p><p><a href="https://juejin.im/post/5c8e5e4951882545c109ae9c">DOM和DOM-diff</a></p><!-- ### 尤大在知乎的回复 #### --><ul><li><ol><li>原生 DOM 操作 vs. 通过框架封装操作。</li></ol></li></ul><p>这是一个性能 vs. 可维护性的取舍。框架的意义在于为你掩盖底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。针对任何一个 benchmark，我都可以写出比任何框架更快的手动优化，但是那有什么意义呢？在构建一个实际应用的时候，你难道为每一个地方都去做手动优化吗？出于可维护性的考虑，这显然不可能。框架给你的保证是，你在不需要手动优化的情况下，我依然可以给你提供过得去的性能。</p><ul><li><ol start="2"><li>对 React 的 Virtual DOM 的误解。</li></ol></li></ul><p>React 从来没有说过 “React 比原生操作 DOM 快”。React 的基本思维模式是每次有变动就整个重新渲染整个应用。如果没有 Virtual DOM，简单来想就是直接重置 innerHTML。很多人都没有意识到，在一个大型列表所有数据都变了的情况下，重置 innerHTML 其实是一个还算合理的操作… 真正的问题是在 “全部重新渲染” 的思维模式下，即使只有一行数据变了，它也需要重置整个 innerHTML，这时候显然就有大量的浪费。我们可以比较一下 innerHTML vs. Virtual DOM 的重绘性能消耗：innerHTML:  render html string O(template size) + 重新创建所有 DOM 元素 O(DOM size)Virtual DOM: render Virtual DOM + diff O(template size) + 必要的 DOM 更新 O(DOM change)Virtual DOM render + diff 显然比渲染 html 字符串要慢，但是！它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。可以看到，innerHTML 的总计算量不管是 js 计算还是 DOM 操作都是和整个界面的大小相关，但 Virtual DOM 的计算量里面，只有 js 计算和界面大小相关，DOM 操作是和数据的变动量相关的。前面说了，和 DOM 操作比起来，js 计算是极其便宜的。这才是为什么要有 Virtual DOM：它保证了 1）不管你的数据变化多少，每次重绘的性能都可以接受；2) 你依然可以用类似 innerHTML 的思路去写你的应用。</p><ul><li><ol start="3"><li>MVVM vs. Virtual DOM</li></ol></li></ul><p>相比起 React，其他 MVVM 系框架比如 Angular, Knockout 以及 Vue、Avalon 采用的都是数据绑定：通过 Directive&#x2F;Binding 对象，观察数据变化并保留对实际 DOM 元素的引用，当有数据变化时进行对应的操作。MVVM 的变化检查是数据层面的，而 React 的检查是 DOM 结构层面的。MVVM 的性能也根据变动检测的实现原理有所不同：Angular 的脏检查使得任何变动都有固定的 O(watcher count) 的代价；Knockout&#x2F;Vue&#x2F;Avalon 都采用了依赖收集，在 js 和 DOM 层面都是 O(change)：脏检查：scope digest O(watcher count) + 必要 DOM 更新 O(DOM change)依赖收集：重新收集依赖 O(data change) + 必要 DOM 更新 O(DOM change)可以看到，Angular 最不效率的地方在于任何小变动都有的和 watcher 数量相关的性能代价。但是！当所有数据都变了的时候，Angular 其实并不吃亏。依赖收集在初始化和数据变化的时候都需要重新收集依赖，这个代价在小量更新的时候几乎可以忽略，但在数据量庞大的时候也会产生一定的消耗。MVVM 渲染列表的时候，由于每一行都有自己的数据作用域，所以通常都是每一行有一个对应的 ViewModel 实例，或者是一个稍微轻量一些的利用原型继承的 “scope” 对象，但也有一定的代价。所以，MVVM 列表渲染的初始化几乎一定比 React 慢，因为创建 ViewModel &#x2F; scope 实例比起 Virtual DOM 来说要昂贵很多。这里所有 MVVM 实现的一个共同问题就是在列表渲染的数据源变动时，尤其是当数据是全新的对象时，如何有效地复用已经创建的 ViewModel 实例和 DOM 元素。假如没有任何复用方面的优化，由于数据是 “全新” 的，MVVM 实际上需要销毁之前的所有实例，重新创建所有实例，最后再进行一次渲染！这就是为什么题目里链接的 angular&#x2F;knockout 实现都相对比较慢。相比之下，React 的变动检查由于是 DOM 结构层面的，即使是全新的数据，只要最后渲染结果没变，那么就不需要做无用功。Angular 和 Vue 都提供了列表重绘的优化机制，也就是 “提示” 框架如何有效地复用实例和 DOM 元素。比如数据库里的同一个对象，在两次前端 API 调用里面会成为不同的对象，但是它们依然有一样的 uid。这时候你就可以提示 track by uid 来让 Angular 知道，这两个对象其实是同一份数据。那么原来这份数据对应的实例和 DOM 元素都可以复用，只需要更新变动了的部分。或者，你也可以直接 track by $index 来进行 “原地复用”：直接根据在数组里的位置进行复用。在题目给出的例子里，如果 angular 实现加上 track by $index 的话，后续重绘是不会比 React 慢多少的。甚至在 dbmonster 测试中，Angular 和 Vue 用了 track by $index 以后都比 React 快: dbmon (注意 Angular 默认版本无优化，优化过的在下面）顺道说一句，React 渲染列表的时候也需要提供 key 这个特殊 prop，本质上和 track-by 是一回事。</p><ul><li><ol start="4"><li>性能比较也要看场合</li></ol></li></ul><p>在比较性能的时候，要分清楚初始渲染、小量数据更新、大量数据更新这些不同的场合。Virtual DOM、脏检查 MVVM、数据收集 MVVM 在不同场合各有不同的表现和不同的优化需求。Virtual DOM 为了提升小量数据更新时的性能，也需要针对性的优化，比如 shouldComponentUpdate 或是 immutable data。初始渲染：Virtual DOM &gt; 脏检查 &gt;&#x3D; 依赖收集小量数据更新：依赖收集 &gt;&gt; Virtual DOM + 优化 &gt; 脏检查（无法优化） &gt; Virtual DOM 无优化大量数据更新：脏检查 + 优化 &gt;&#x3D; 依赖收集 + 优化 &gt; Virtual DOM（无法&#x2F;无需优化）&gt;&gt; MVVM 无优化不要天真地以为 Virtual DOM 就是快，diff 不是免费的，batching 么 MVVM 也能做，而且最终 patch 的时候还不是要用原生 API。在我看来 Virtual DOM 真正的价值从来都不是性能，而是它 1) 为函数式的 UI 编程方式打开了大门；2) 可以渲染到 DOM 以外的 backend，比如 ReactNative。</p><ul><li><ol start="5"><li>总结</li></ol></li></ul><p>以上这些比较，更多的是对于框架开发研究者提供一些参考。主流的框架 + 合理的优化，足以应对绝大部分应用的性能需求。如果是对性能有极致需求的特殊情况，其实应该牺牲一些可维护性采取手动优化：比如 Atom 编辑器在文件渲染的实现上放弃了 React 而采用了自己实现的 tile-based rendering；又比如在移动端需要 DOM-pooling 的虚拟滚动，不需要考虑顺序变化，可以绕过框架的内置实现自己搞一个。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;论题：-虚拟DOM和原生谁更快&quot;&gt;&lt;a href=&quot;#论题：-虚拟DOM和原生谁更快&quot; class=&quot;headerlink&quot; title=&quot;论题： 虚拟DOM和原生谁更快&quot;&gt;&lt;/a&gt;论题： 虚拟DOM和原生谁更快&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://w</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="virtual-dom" scheme="http://example.com/tags/virtual-dom/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="http://example.com/2018/07/13/closure/"/>
    <id>http://example.com/2018/07/13/closure/</id>
    <published>2018-07-13T06:31:27.000Z</published>
    <updated>2018-07-13T06:31:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>js 中变量分为全局变量、局部变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;  <span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>)&#123;</span><br><span class="line">  b = <span class="number">2</span>;  <span class="comment">// 全局变量（严格模式下报错）</span></span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">3</span>; <span class="comment">// 局部变量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">A</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// Error：c is not defined</span></span><br></pre></td></tr></table></figure><h3 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h3><p>js 会把带有 <code>var</code> 和 <code>function</code> 关键字的事先声明，并在存放在栈区中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;&#125;; <span class="comment">// 本质还是通过var声明</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// ƒ c()&#123;&#125;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>)&#123;&#125;;</span><br></pre></td></tr></table></figure><p>疑问？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">out</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">out</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// Error: a is not defined， 为什么这里报错了，没有预解析</span></span><br></pre></td></tr></table></figure><h3 id="解析执行环境"><a href="#解析执行环境" class="headerlink" title="解析执行环境"></a>解析执行环境</h3><p>在 js 执行之前是会预解析 <code>function</code> 和 <code>var</code> 没错，但是在本例中 它们的“解析执行环境”不同.</p><p><code>function out</code> 是在一个全局的环境中，而 <code>a</code> 是 <code>function  out</code> 中定义的一个局部变量，<code>a</code> 的“解析执行环境”是在 <code>function out</code> 这个函数里面(这里可以理解为 <code>function out</code> 里的局部环境)，所以当我们在全局这个环境中 console.log(a) 的时候，并没有定义 <code>a</code> 这个变量或者函数，所以就报错了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">out</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// undefined</span></span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">out</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// Error: a is not defined</span></span><br></pre></td></tr></table></figure><h3 id="垃圾回收机制-GC"><a href="#垃圾回收机制-GC" class="headerlink" title="垃圾回收机制-GC"></a>垃圾回收机制-GC</h3><p>原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。<br>不再使用的变量：也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>作用：局部变量常驻内存，读取函数内部的变量<br>构成：函数嵌套，内部函数调用外部函数的变量<br>缺点：造成内存泄漏</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">son</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">son</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">parent</span>()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><ul><li><ol><li>意外的全局变量引起的内存泄漏。</li></ol></li></ul><p>原因：全局变量，不会被回收。</p><p>解决：使用严格模式避免。</p><ul><li><ol start="2"><li><strong>闭包引起的内存泄漏</strong></li></ol></li></ul><p>原因：闭包可以维持函数内局部变量，使其得不到释放。</p><p><strong>解决：在退出函数之前，将不使用的局部变量全部删除，如在不用parent函数的时候，parent &#x3D; null</strong></p><ul><li><ol start="3"><li>没有清理的 <code>DOM</code> 元素引用</li></ol></li></ul><p>原因：虽然别的地方删除了，但是对象中还存在对 dom 的引用</p><p>解决：手动删除。</p><ul><li><ol start="4"><li>被遗忘的定时器或者回调</li></ol></li></ul><p>原因：定时器中有 dom 的引用，即使 dom 删除了，但是定时器还在，所以内存中还是有这个 dom。</p><p>解决：手动删除定时器和 dom。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h3&gt;&lt;p&gt;js 中变量分为全局变量、局部变量&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;</summary>
      
    
    
    
    <category term="js" scheme="http://example.com/categories/js/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
    <category term="闭包" scheme="http://example.com/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
</feed>
