{"meta":{"title":"Jason","subtitle":"鲜衣怒马少年时，一日看尽长安花","description":"光景不待人，须臾发成丝","author":"Jason xu","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2024-04-07T03:15:12.764Z","updated":"2024-04-07T03:15:12.764Z","comments":true,"path":"2024/04/07/hello-world/","permalink":"http://example.com/2024/04/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"vuex1","slug":"vuex1","date":"2024-04-07T03:01:42.000Z","updated":"2024-04-07T03:01:42.000Z","comments":true,"path":"2024/04/07/vuex1/","permalink":"http://example.com/2024/04/07/vuex1/","excerpt":"","text":"zhesasdfas","categories":[{"name":"vuex","slug":"vuex","permalink":"http://example.com/categories/vuex/"}],"tags":[{"name":"vuex 源码","slug":"vuex-源码","permalink":"http://example.com/tags/vuex-%E6%BA%90%E7%A0%81/"}]},{"title":"vue组件通信及vuex原理解析","slug":"vuex","date":"2020-03-20T15:47:09.000Z","updated":"2020-03-20T15:47:09.000Z","comments":true,"path":"2020/03/20/vuex/","permalink":"http://example.com/2020/03/20/vuex/","excerpt":"","text":"组件传值组件是 vue.js强大的功能之一，而组件实例的作用域是相互独立的，这就意味着不同组件之间的数据无法相互引用。一般来说，组件可以有以下几种关系： 父传子 props 12345// 父组件：&lt;HelloWorld msg=&quot;Welcome to Your Vue.js + TypeScript App&quot;/&gt; // 子组件props: &#123; msg: String &#125; $attrs 子组件未在props中声明的属性 inheritAttrs: false 1234567&lt;!-- 父组件 --&gt;&lt;HelloWorld msg=&quot;Welcome to Your Vue.js + TypeScript App&quot; foo=&quot;foo&quot;/&gt; &lt;!-- 子组件 --&gt;&lt;p&gt;&#123;&#123;$attrs.foo&#125;&#125;&lt;/p&gt; &lt;input v-bind=&quot;$attrs&quot;/&gt; // placeholder type ... $refs: 如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例 12345678910111213141516171819202122// 子组件export default &#123; data () &#123; return &#123; title: &#x27;I am hw componet&#x27; &#125; &#125;, methods: &#123; say () &#123; alert(&#x27;Hello&#x27;); &#125; &#125;&#125;// 父组件&lt;HelloWorld :msg=&quot;msg&quot; foo=&quot;foo&quot; @changeMsg=&quot;changeMsg&quot; ref=&quot;hw&quot; /&gt; mounted () &#123; const hw = this.$refs.hw; console.log(hw.title); // I am hw componet comA.sayHello(); // 弹窗 Hello&#125; $parent &#x2F; $children：访问父 &#x2F; 子实例 $children子元素不保证顺序 子传父 $emit、$on 123456789// 子组件this.$emit(&#x27;changeMsg&#x27;)// 父组件&lt;HelloWorld :msg=&quot;msg&quot; foo=&quot;foo&quot; @changeMsg=&quot;changeMsg&quot;/&gt;changeMsg() &#123; this.msg = &#x27;hello world!&#x27;&#125; 兄弟传值： 通过共同的祖辈组件搭桥，$parent或$root 1234// brother1this.$parent.$on(&#x27;foo&#x27;, handle)// brother2this.$parent.$emit(&#x27;foo&#x27;) 祖代传值 provide: Object | () &#x3D;&gt; Object inject: Array | { [key: string]: string | Symbol | Object } provide 和 inject 主要在开发高阶插件&#x2F;组件库时使用。并不推荐用于普通应用程序代码中。原理解析 【注意】：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的 12345678910111213provide () &#123; return &#123; bar: &#x27;provide value&#x27; &#125;&#125; // inject: [&#x27;bar&#x27;]inject: &#123; bar: &#123; type: string, default: &#x27;&#x27; &#125;&#125; 实现provide与inject响应化 不推荐 rovide祖先组件的实例，然后在子孙组件中注入依赖，这样就可以在子孙组件中直接修改祖先组件的实例的属性，不过这种方法有个缺点就是这个实例上挂载很多没有必要的东西比如props，methods 推荐 2.6.0 新增API Vue.observable 优化响应式 12345678910111213141516171819202122232425262728293031323334// 父组件export default class App extends Vue &#123; msg: string = &quot;Welcome to Your Vue.js + TypeScript App&quot;; // 调用Vue.observable声明响应数据appTheme appTheme: Theme = Vue.observable(&#123; color: &quot;red&quot; &#125;); @Provide() bar: string = &quot;root message&quot;; // 普通字符 @Provide() theme: object = this.appTheme; // 响应数据 @Provide() app: object = this; // 当前组件实例 changeMsg() &#123; this.msg = &quot;hello world!&quot;; &#125;&#125;// 子组件export default class HelloWorld extends Vue &#123; @Inject(&#123; default: &quot;&quot; &#125;) bar!: string; @Inject(&#123; default: () =&gt; (&#123;&#125;) &#125;) theme!: object; @Inject() app!: any mounted() &#123; console.log(this.theme, this.app); this.app.msg = &#x27;hw&#x27; // 直接在子组件中修改父组件的属性 (父组件不能响应变化) this.app.changeMsg(); // 调用父组件的方法(子组件不能响应变化) &#125;&#125; EventBus 事件总线 123456789101112131415161718192021222324252627282930313233// 初始化event-bus.jsimport Vue from &#x27;vue&#x27;export const EventBus = new Vue()// comA组件: 派发add事件import &#123; EventBus &#125; from &quot;./eventBus/event-bus&quot;;export default &#123; data () &#123; return &#123; count: 0 &#125; &#125;, methods: &#123; eveAdd() &#123; EventBus.$emit(&#x27;add&#x27;, ++this.count) &#125; &#125;&#125;// comB组件：监听add事件，展示add之后的结果import &#123; EventBus &#125; from &quot;./eventBus/event-bus&quot;;export default &#123; data () &#123; return &#123; num: 0 &#125; &#125;, mounted() &#123; EventBus.$on(&quot;add&quot;, count =&gt; &#123; this.num = count; &#125;); &#125;&#125; Vuex核心概念 state 管理vuex的数据（官方称之为单一状态树） getter state 中派生出一些状态 mutation 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation 必须是同步函数 action Action 提交的是 mutation，而不是直接变更状态 Action 可以包含任意异步操作 module 模块化（当应用变得特别复杂时，所有状态都会集中到一个较大的对象中，就会变得非常臃肿，按照模块精心分割，每个模块都拥有自己的state、mutation、action、getter） 12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 问题：mutation中执行异步操作会怎么样？ 事实上在 vuex 里面 actions 只是一个架构性的概念，并不是必须的，说到底只是一个函数，你在里面想干嘛都可以，只要最后触发 mutation 就行 — 尤雨溪知乎回答 Vuex 源码解析 Vue.use(Vuex) 做了什么？为什么axios不用Vue.use()方法？ new Vue({store}) store 在这里做了什么？ 为什么？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 // vuex.js 实现commit dispatch getter方法 var Vue// 实现install方法function install(_Vue) &#123; Vue = _Vue Vue.mixin(&#123; beforeCreate() &#123; if (this.$options.store) &#123; // vue的原型上挂载store（Store的实例） Vue.prototype.$store = this.$options.store &#125; &#125; &#125;)&#125;// 实现Store类class Store &#123; constructor(options) &#123; this.state = new Vue(&#123; // 实现state响应化 data: options.state &#125;) this.mutations = options.mutations || &#123;&#125; this.actions = options.actions || &#123;&#125; options.getters &amp;&amp; this.handleGetters(options.getters) &#125; commit = (type, arg) =&gt; &#123; this.mutations[type](this.state, arg) &#125; // dispatch方法接受一个上下文执行环境，注意与commit区分 dispatch(type, arg) &#123; this.actions[type](&#123; state: this.state, commit: this.commit, getters: this.getters &#125;, arg) &#125; handleGetters(getters) &#123; this.getters = &#123;&#125; Object.keys(getters).forEach(key =&gt; &#123; // 利用defineProtperty将getters的执行结果映射成对象 Object.defineProperty(this.getters, key, &#123; get: () =&gt; &#123; return getters[key](this.state) &#125; &#125;) &#125;) &#125; &#125; export default &#123; Store, install &#125;","categories":[],"tags":[]},{"title":"js 数组方法总结 之 一道面试题引发的血案","slug":"array-methods","date":"2019-11-07T02:09:31.000Z","updated":"2019-11-07T02:09:31.000Z","comments":true,"path":"2019/11/07/array-methods/","permalink":"http://example.com/2019/11/07/array-methods/","excerpt":"","text":"在前端面试当中高频出现的一道面试题，让我产生了把js数组的方法总结一下的念头，呐，就是下面这道题目引发的血案！看了解析先别撤哦，后面留了几道提升题目，你值得拥有（皮这一下很开心~~） 1234567891011121314151617181920212223242526272829303132[1, 2, 3].map(parseInt);// 解析：[1, 2, 3].map((item, index, arr) =&gt; parseInt(item, index));parseInt(1, 0); // 1parseInt(2, 1); // NaNparseInt(3, 2); // NaN// 故：结果为 [1, NaN, NaN]// 考点分析：map(function(currentValue, index, arr)&#123;&#125;)方法回调函数的参数// currentValue 当前元素的值// index 当前元素的索引值// arr 原数组parseInt(string, radix) 函数的参数// radix该值介于 2 ~ 36 之间,如果省略该参数或其值为 0，则数字将以 10 为基础来解析// 如果它以 “0x” 或 “0X” 开头，将以 16 为基数// 如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN 转化方法 toString() 返回数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串 123[1, 2, &#x27;3&#x27;].toString(); // &quot;1,2,3&quot; valueOf() 返回原数组 1[1, 2, &#x27;3&#x27;].valueOf(); // [1, 2, &quot;3&quot;] join() 通过指定的分隔符进行分隔的 12345[1, 2, &#x27;3&#x27;].join(); // &quot;1,2,3&quot;[1, 2, &#x27;3&#x27;].join(&#x27;&#x27;); // &quot;123&quot;[1, 2, &#x27;3&#x27;].join(&#x27;-&#x27;); // &quot;1-2-3&quot; 栈方法 LIFO(Last-In-First-Out,后进先出的数据结构) push() 添加到数组末尾，并返回修改后数组的长度 123456[1, 2].push(3); // 3,原数组: [1, 2, 3][1, 2].push([3, 4]); // 3, 原数组：[1, 2, [3, 4]][1, 2].push(3,4); // 4, 原数组：[1, 2, 3, 4] pop() 从数组末尾移除一项，返回移除的项 1[1, 2].pop(); // 2, 原数组： [1] 队列方法(先进先出) unshift() 在数组前添加，返回修改后数组的长度 1[1, 2].unshift(2); // 3, 原数组：[2, 1, 2] shift() 1[1, 2].shift(); // 1, 原数组：[2] 重排方法 reverse() 反转数组项的顺序，返回反转之后的数组 1[1, 2, 3].reverse(); // [3, 2, 1] sort() 排序 1234567891011121314151617181920212223242526272829303132333435// 当不带参数调用sort（）时，数组元素以字母表顺序排序（如有必要将临时转化为字符串进行比较）[1, 3, 11, 2].sort(); // [1, 11, 2, 3][&#x27;2&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;11&#x27;].sort(); // [&quot;1&quot;, &quot;11&quot;, &quot;2&quot;, &quot;3&quot;]// 给sort方法传递一个比较函数，该函数决定了它的两个参数在排好序的数组中的先后顺序：// 假设第一个参数应该在前，比较函数应该返回一个小于0的数值，反之，// 假设第一个参数应该在后，函数应该返回一个大于0的数值，// 并且，假设两个值相等，函数应该返回0[1, 11, 2, 22, 33, 3].sort((a, b) =&gt; a - b); // [1, 2, 3, 11, 22, 33]// 可以指定对象的属性进行排序[&#123;name:&#x27;zs&#x27;,age:16&#125;,&#123;name:&#x27;ls&#x27;, age:25&#125;].sort((a, b) =&gt; &#123;​ if(a[&#x27;name&#x27;] &lt; b[&#x27;name&#x27;]) &#123;​ return -1;​ &#125; else if (a[&#x27;name&#x27;] &gt; b[&#x27;name&#x27;]) &#123;​ return 1;​ &#125; else&#123;​ return 0;​ &#125;&#125;) 操作方法 concat() 连接两个或多个数组，不会改变原数组，返回连接的新数组 1[1, 2].concat([3, 4]); // [1, 2, 3, 4] slice() 从已有数组中返回选定的元素，不会改变原数组，返回截取之后的新数组 1[1, 2, 3, 4].slice(1, 3); // [2, 3] splice() 向&#x2F;从数组中添加&#x2F;删除元素，然后返回被删除的元素 123[1, 2].splice(0, 1); // [1][1, 2].splice(0, 0, 3); // [], 原数组[1, 2, 3] 位置方法 indexOf() 从数组开头（0）开始查找，返回查找项在数组中的位置，如果没有返回-1 123[1, 2, 3].indexOf(3); // 2[1, 2, 3].indexOf(4); // -1 lastIndexOf() 从数组末尾开始查找，返回查找项在数组中的位置，如果没有返回-1 1[1, 2, 3].lastIndexOf(3); // 2 迭代方法 every() 对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true 1[1, 2, 3].every(item =&gt; item &gt; 0); // true some() 对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true 1[1,2,3].some(item =&gt; item &gt; 2); // true filter() 对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的新数组数组，不改变原数组 1[1, 2, 3].filter(item =&gt; item &gt; 2); // [3] forEach() 对数组中的每一项运行给定函数, 没有返回值 map() 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的新数组，不改变原数组 123[1, 2, 3].map(item =&gt; item 2); // [2, 4, 6] 归并方法 reduce(callback,[initialValue]) 对数组中的每个元素执行一个由callback提供的reducer函数(升序执行)，将其结果汇总为单个返回值 123[1, 2, 3, 4].reduce((prev, cur) =&gt; prev + cur); // 10[1, 2, 3, 4].reduce((prev, cur) =&gt; prev + cur, 10); // 20 reduceRight(callback,[initialValue]) 和reduce方法相同，执行顺序变为从最后一项开始 测试题12345678910111213[1, 2, 3].map(parseInt); // [1, NaN, NaN]==&gt; [1, 2, 3].map((item, index, arr) =&gt; parseInt(item, index));[1, 2, 3].filter(parseInt); // [1][1, 2, 3].every(parseInt); // false[1, 2, 3].some(parseInt); // true[1, 2, 3].reduce(parseInt); // 1==&gt; [1, 2, 3].reduce((prev, cur) =&gt; parseInt(prev, cur))","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"},{"name":"数组方法","slug":"数组方法","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"}]},{"title":"virtual-dom","slug":"virtual-dom","date":"2019-03-26T01:52:30.000Z","updated":"2019-03-26T01:52:30.000Z","comments":true,"path":"2019/03/26/virtual-dom/","permalink":"http://example.com/2019/03/26/virtual-dom/","excerpt":"","text":"论题： 虚拟DOM和原生谁更快原文链接虚拟DOM和原生谁更快？ DOM和DOM-diff 尤大在知乎的回复 原生 DOM 操作 vs. 通过框架封装操作。 这是一个性能 vs. 可维护性的取舍。框架的意义在于为你掩盖底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。针对任何一个 benchmark，我都可以写出比任何框架更快的手动优化，但是那有什么意义呢？在构建一个实际应用的时候，你难道为每一个地方都去做手动优化吗？出于可维护性的考虑，这显然不可能。框架给你的保证是，你在不需要手动优化的情况下，我依然可以给你提供过得去的性能。 对 React 的 Virtual DOM 的误解。 React 从来没有说过 “React 比原生操作 DOM 快”。React 的基本思维模式是每次有变动就整个重新渲染整个应用。如果没有 Virtual DOM，简单来想就是直接重置 innerHTML。很多人都没有意识到，在一个大型列表所有数据都变了的情况下，重置 innerHTML 其实是一个还算合理的操作… 真正的问题是在 “全部重新渲染” 的思维模式下，即使只有一行数据变了，它也需要重置整个 innerHTML，这时候显然就有大量的浪费。我们可以比较一下 innerHTML vs. Virtual DOM 的重绘性能消耗：innerHTML: render html string O(template size) + 重新创建所有 DOM 元素 O(DOM size)Virtual DOM: render Virtual DOM + diff O(template size) + 必要的 DOM 更新 O(DOM change)Virtual DOM render + diff 显然比渲染 html 字符串要慢，但是！它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。可以看到，innerHTML 的总计算量不管是 js 计算还是 DOM 操作都是和整个界面的大小相关，但 Virtual DOM 的计算量里面，只有 js 计算和界面大小相关，DOM 操作是和数据的变动量相关的。前面说了，和 DOM 操作比起来，js 计算是极其便宜的。这才是为什么要有 Virtual DOM：它保证了 1）不管你的数据变化多少，每次重绘的性能都可以接受；2) 你依然可以用类似 innerHTML 的思路去写你的应用。 MVVM vs. Virtual DOM 相比起 React，其他 MVVM 系框架比如 Angular, Knockout 以及 Vue、Avalon 采用的都是数据绑定：通过 Directive&#x2F;Binding 对象，观察数据变化并保留对实际 DOM 元素的引用，当有数据变化时进行对应的操作。MVVM 的变化检查是数据层面的，而 React 的检查是 DOM 结构层面的。MVVM 的性能也根据变动检测的实现原理有所不同：Angular 的脏检查使得任何变动都有固定的 O(watcher count) 的代价；Knockout&#x2F;Vue&#x2F;Avalon 都采用了依赖收集，在 js 和 DOM 层面都是 O(change)：脏检查：scope digest O(watcher count) + 必要 DOM 更新 O(DOM change)依赖收集：重新收集依赖 O(data change) + 必要 DOM 更新 O(DOM change)可以看到，Angular 最不效率的地方在于任何小变动都有的和 watcher 数量相关的性能代价。但是！当所有数据都变了的时候，Angular 其实并不吃亏。依赖收集在初始化和数据变化的时候都需要重新收集依赖，这个代价在小量更新的时候几乎可以忽略，但在数据量庞大的时候也会产生一定的消耗。MVVM 渲染列表的时候，由于每一行都有自己的数据作用域，所以通常都是每一行有一个对应的 ViewModel 实例，或者是一个稍微轻量一些的利用原型继承的 “scope” 对象，但也有一定的代价。所以，MVVM 列表渲染的初始化几乎一定比 React 慢，因为创建 ViewModel &#x2F; scope 实例比起 Virtual DOM 来说要昂贵很多。这里所有 MVVM 实现的一个共同问题就是在列表渲染的数据源变动时，尤其是当数据是全新的对象时，如何有效地复用已经创建的 ViewModel 实例和 DOM 元素。假如没有任何复用方面的优化，由于数据是 “全新” 的，MVVM 实际上需要销毁之前的所有实例，重新创建所有实例，最后再进行一次渲染！这就是为什么题目里链接的 angular&#x2F;knockout 实现都相对比较慢。相比之下，React 的变动检查由于是 DOM 结构层面的，即使是全新的数据，只要最后渲染结果没变，那么就不需要做无用功。Angular 和 Vue 都提供了列表重绘的优化机制，也就是 “提示” 框架如何有效地复用实例和 DOM 元素。比如数据库里的同一个对象，在两次前端 API 调用里面会成为不同的对象，但是它们依然有一样的 uid。这时候你就可以提示 track by uid 来让 Angular 知道，这两个对象其实是同一份数据。那么原来这份数据对应的实例和 DOM 元素都可以复用，只需要更新变动了的部分。或者，你也可以直接 track by $index 来进行 “原地复用”：直接根据在数组里的位置进行复用。在题目给出的例子里，如果 angular 实现加上 track by $index 的话，后续重绘是不会比 React 慢多少的。甚至在 dbmonster 测试中，Angular 和 Vue 用了 track by $index 以后都比 React 快: dbmon (注意 Angular 默认版本无优化，优化过的在下面）顺道说一句，React 渲染列表的时候也需要提供 key 这个特殊 prop，本质上和 track-by 是一回事。 性能比较也要看场合 在比较性能的时候，要分清楚初始渲染、小量数据更新、大量数据更新这些不同的场合。Virtual DOM、脏检查 MVVM、数据收集 MVVM 在不同场合各有不同的表现和不同的优化需求。Virtual DOM 为了提升小量数据更新时的性能，也需要针对性的优化，比如 shouldComponentUpdate 或是 immutable data。初始渲染：Virtual DOM &gt; 脏检查 &gt;&#x3D; 依赖收集小量数据更新：依赖收集 &gt;&gt; Virtual DOM + 优化 &gt; 脏检查（无法优化） &gt; Virtual DOM 无优化大量数据更新：脏检查 + 优化 &gt;&#x3D; 依赖收集 + 优化 &gt; Virtual DOM（无法&#x2F;无需优化）&gt;&gt; MVVM 无优化不要天真地以为 Virtual DOM 就是快，diff 不是免费的，batching 么 MVVM 也能做，而且最终 patch 的时候还不是要用原生 API。在我看来 Virtual DOM 真正的价值从来都不是性能，而是它 1) 为函数式的 UI 编程方式打开了大门；2) 可以渲染到 DOM 以外的 backend，比如 ReactNative。 总结 以上这些比较，更多的是对于框架开发研究者提供一些参考。主流的框架 + 合理的优化，足以应对绝大部分应用的性能需求。如果是对性能有极致需求的特殊情况，其实应该牺牲一些可维护性采取手动优化：比如 Atom 编辑器在文件渲染的实现上放弃了 React 而采用了自己实现的 tile-based rendering；又比如在移动端需要 DOM-pooling 的虚拟滚动，不需要考虑顺序变化，可以绕过框架的内置实现自己搞一个。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"virtual-dom","slug":"virtual-dom","permalink":"http://example.com/tags/virtual-dom/"}]},{"title":"闭包","slug":"closure","date":"2018-07-13T06:31:27.000Z","updated":"2018-07-13T06:31:27.000Z","comments":true,"path":"2018/07/13/closure/","permalink":"http://example.com/2018/07/13/closure/","excerpt":"","text":"作用域js中变量分为全局变量、局部变量 123456789var a = 1; // 全局变量function A()&#123; b = 2; // 全局变量（严格模式下报错） var c = 3; // 局部变量&#125;;A();console.log(a); // 1console.log(b); // 2console.log(c); // Error：c is not defined 预解析js会把带有var和function关键字的事先声明，并在存放在栈区中 123456console.log(a); // undefinedvar a = 1;console.log(b); // undefinedvar b = function b()&#123;&#125;; // 本质还是通过var声明console.log(c); // ƒ c()&#123;&#125;function c()&#123;&#125;; 疑问？ 12345function out()&#123; var a = 1;&#125;;out();console.log(a); // Error: a is not defined， 为什么这里报错了，没有预解析 解析执行环境在js执行之前是会预解析function 和var 没错，但是在本例中 它们的“解析执行环境”不同. function out是在一个全局的环境中，而a是function out中定义的一个局部变量，a的“解析执行环境”是在function out这个函数里面(这里可以理解为function out里的局部环境)，所以当我们在全局这个环境中console.log(a) 的时候，并没有定义a这个变量或者函数，所以就报错了 123456function out()&#123; console.log(a); // undefined var a = 1;&#125;;out();console.log(a); // Error: a is not defined 垃圾回收机制-GC原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。不再使用的变量：也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。 闭包作用：局部变量常驻内存，读取函数内部的变量构成：函数嵌套，内部函数调用外部函数的变量缺点：造成内存泄漏 12345678function parent() &#123; var a = 1; function son() &#123; return a++; &#125; return son();&#125;console.log(parent()); // 1 内存泄漏 意外的全局变量引起的内存泄漏。 原因：全局变量，不会被回收。 解决：使用严格模式避免。 闭包引起的内存泄漏 原因：闭包可以维持函数内局部变量，使其得不到释放。 解决：在退出函数之前，将不使用的局部变量全部删除，如在不用parent函数的时候，parent &#x3D; null 没有清理的DOM元素引用 原因：虽然别的地方删除了，但是对象中还存在对dom的引用 解决：手动删除。 被遗忘的定时器或者回调 原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。 解决：手动删除定时器和dom。","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"},{"name":"闭包","slug":"闭包","permalink":"http://example.com/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"原型、原型链","slug":"prototype","date":"2018-07-12T07:10:06.000Z","updated":"2018-07-12T07:10:06.000Z","comments":true,"path":"2018/07/12/prototype/","permalink":"http://example.com/2018/07/12/prototype/","excerpt":"","text":"函数声明123var f1 = function()&#123;&#125;; // 1. 字面量function f2 = function()&#123;&#125;; // 2. 关键词 var f3 = new Function(); // 3. 构造函数 归根结底都是通过new Function 的方式来创建的，js中一切皆对象，对象又分函数对象和普通对象，简单来说通过new Function创建的就称之为函数对象，其他的都是普通对象 原型对象在js中每一个对象（普通对象、函数对象）都有一个__proto__ 属性，函数对象都有一个prototype属性，指向函数的原型对象 123456789101112131415161718192021var obj = &#123;&#125;;var fn = function()&#123;&#125;;console.log(obj.__proto__); // &#123;constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, …&#125;console.log(obj.prototype); // undefined console.log(fn.__proto__); // ƒ () &#123; [native code] &#125;console.log(fn.prototype); // &#123;constructor: ƒ&#125;// 其中 prototype 就是原型对象，当然原型对象也是一个普通对象，它的作用主要是用来实现继承的，举个栗子： var Animal = function()&#123; this.name = &#x27;Tom&#x27;;&#125;Animal.prototype.say = function()&#123; console.log(&#x27;I am &#x27; + this.name)&#125;var cat = new Animal();var dog = new Animal();cat.say(); // I am Tomdog.say(); // I am Tom 这里原型继承的问题，暂且按下不表（皮这一下，很开心~~） 原型链上文说到，每一个对象都有一个__proto__ 属性，那么这个属性究竟有什么用呢？先来看几个例子 123456789var Animal = function()&#123; this.name = &#x27;Tom&#x27;;&#125;var cat = new Animal();console.log(cat.__proto__ === Animal.prototype); // trueconsole.log(Animal.prototype.__proto__ === Object.prototype); // trueconsole.log(Object.prototype.__proto__ === null); // true 从这个例子中可以看出 __proto__ 属性指向构造函数的原型对象prototype，而prototype也是一个普通对象，也有__proto__属性，继续指向其构造函数，直到指向null，这样就形成了一个原型指向的链条，专业术语称之为原型链。至于为什么最终是null，如果非要解释的话，引用道德经中的一句话：有，是万物之所始；无，是万物之所母。此外，Function、Object作为js的内置函数对象，需要清楚一点，他们都是 new Function创建的 console.log(Function.constructor === Object.constructor); // true new 的实现过程通过new 一个构造函数得到一个对象，看一下内部实现过程，有助于帮助理解原型链指向 1. 声明一个对象 var obj = &#123;&#125;; 2. obj.\\_\\_proto__ = 构造函数.prototype; 3. 改变this指针，通过call、apply让this指向第一步创建的obj； 4. 返回对象obj; 12345678910111213141516171819202122function Animal(name)&#123; this.name = name;&#125;Animal.prototype.say = function()&#123; console.log(&#x27;I am &#x27; + this.name)&#125;function myNew() &#123; var obj = &#123;&#125;; // 是指还是new，不要纠结，只是模拟new的过程 var Constructor = [].shift.call(arguments); // 构造函数 Animal //constructor属性是在Animal.prototype对象中用来记录它指向的 构造函数 的属性 console.log(Constructor.prototype); // &#123;say: ƒ, constructor: ƒ&#125; say:ƒ() constructor:ƒ Animal(name) obj.__proto__ = Constructor.prototype; // 让obj.__proto__ 指向 Animal.prototype Constructor.apply(obj,arguments); // 让this指向obj return obj;&#125;var cat= myNew(Animal,&#x27;Tom&#x27;);console.log(cat.name); // Tomcat.say(); // I am Tomconsole.log(cat.constructor); // ƒ Animal(name)&#123; this.name = name; &#125; 大招如果以上内容还是不太明白，我自己做了张注解图（线条有点多而杂，见谅~~），以及代码案例帮助理解 12345678910111213141516171819202122// 几个概念： // 普通对象是new Object而来的，所以 它的构造函数就是Object// 函数对象是new Function而来的，所以 它的构造函数就是Function，Function、Object是new Function而来的// 对象的__proto__ 指向构造函数的prototypefunction Animal()&#123;&#125;var cat = new Animal();cat.constructor == Animal; // truecat.__proto__ === Animal.prototype; // trueAnimal.constructor === Function; // trueAnimal.prototype.__proto__ === Object.prototype; // true 注：prototype是对象Animal.__proto__ === Function.prototype; // trueObject.constructor === Function; // trueObject.__proto__ === Function.prototype; // trueObject.prototype.__proto__ === null; // trueFunction.constructor === Function; // trueFunction.__proto__ === Function.prototype; // trueFunction.prototype.__proto__ === Object.prototype; // true 关于面向对象、继承推荐一篇超赞的文章：javascript面向对象编程，带你认识封装、继承和多态，深度好文，值得一读！","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"},{"name":"原型","slug":"原型","permalink":"http://example.com/tags/%E5%8E%9F%E5%9E%8B/"},{"name":"new的过程","slug":"new的过程","permalink":"http://example.com/tags/new%E7%9A%84%E8%BF%87%E7%A8%8B/"}]},{"title":"hexo command","slug":"hello-world copy","date":"2017-07-24T02:09:31.000Z","updated":"2017-07-24T02:09:31.000Z","comments":true,"path":"2017/07/24/hello-world copy/","permalink":"http://example.com/2017/07/24/hello-world%20copy/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"开博缘由","slug":"begin","date":"2017-04-29T09:02:38.000Z","updated":"2017-04-29T09:02:38.000Z","comments":true,"path":"2017/04/29/begin/","permalink":"http://example.com/2017/04/29/begin/","excerpt":"","text":"缘起佛曰：一切皆有缘法，缘起缘灭缘自在 情深情浅不由人，总觉得少这么一个起因内心有愧~~对于任何一个有追求(装X)的前端攻城狮来说，拥有一个博客是追求(装X)路上的一把利刃，正所谓念念不忘必有回响，历经千辛万苦，算是给自己搭建了一个属于自己的小窝。当然，如果开博不是为了装X，那将变得毫无意义！搭建这个博客的主要原因是想把自己学习道路上get到的技能做一个梳理，好记性不如烂笔头么！其次是把自己踩得那些坑分享给更多的人，可能您要说就我的这点经验是在没有借鉴的价值。NO NO NO 且听我慢慢道来。往往看一些大神的帖子会有一种感觉就是规避掉了一些你关注的点，当然这个不是说人家考虑的不到位，而是由于我们的技术栈存在差异，可能人家在做第一步的时候就已经为后面做好了一些铺垫，规避掉了一些问题，而并没有体现到教程当中，这样对于初学者来可能就会遇到一些莫名奇妙的问题。好吧！我承认是自己强行解释了一波，来掩盖我要装的本质！ 与hexo结缘要感谢一位许姓小伙伴的极力推荐，看了整个搭建过程的文档之后就按耐不住内心的冲动，义无反顾的qrq送了一血！然后就有了… (不要想歪啊 ~~) 缘灭如若梦起缘生，梦逝缘灭，我愿一梦不起 是不是已心动不已，赶快移步到使用GitHub + hexo搭建个人博客 行动起来吧！","categories":[{"name":"心情物语","slug":"心情物语","permalink":"http://example.com/categories/%E5%BF%83%E6%83%85%E7%89%A9%E8%AF%AD/"}],"tags":[{"name":"心情物语","slug":"心情物语","permalink":"http://example.com/tags/%E5%BF%83%E6%83%85%E7%89%A9%E8%AF%AD/"}]},{"title":"使用GitHub + hexo搭建个人博客","slug":"create-hexo-blog","date":"2017-04-03T20:04:06.000Z","updated":"2017-04-03T20:04:06.000Z","comments":true,"path":"2017/04/04/create-hexo-blog/","permalink":"http://example.com/2017/04/04/create-hexo-blog/","excerpt":"","text":"本文环境 git 2.18 node v10.16.0 安装hexo1npm install -g hexo-cli github上创建仓库仓库名：username.github.io 仓库名必须为user + .github.io，这个名字也是将来博客的访问地址 博客的创建初始化1hexo init xuyz-blog 会生成一个名为xuyz-blog的文件夹，就是将来博客的配置及存放博文的地方 基础配置打开xuyz-blog&#x2F;_config.yml文件进行基础配置，以下只举几个关键的配置 123456789101112131415# Sitetitle: xuyz-blog # 博客名字subtitle: &#x27;鲜衣怒马少年时，一日看尽长安花&#x27; # 小标题可以写自己喜欢的话description: &#x27;光景不待人，须臾发成丝&#x27; # 博客描述keywords: xuyangzhouauthor: xuyangzhou # 作者名字language: zh-CN # 语言url: / # 自己购买的域名网址（没有可不写）theme: landscape # 主题的名字deploy: type: git # 使用git发布 repo: https://github.com/xuyangzhou/xuyangzhou.github.io.git # 刚刚创建的仓库地址 本地预览12hexo serverhexo s # 简写 打开localhost:4000 即可看到我们的博客界面了 发布1234hexo cleanhexo generate # hexo g 简写hexo deploy # hexo d 简写# hexo d -g === hexo g &amp; hexo d 这里如果出错，找不到repository，需要安装hexo-deployer-git插件，再执行hexo d命令 1npm install hexo-deployer-git --save 打开xuyangzhou.github.io（就是你创建的仓库名）即可看到 至此，博客已经搭建工作已大功告成了，我们已经拥有了自己的一个小窝了，但是我们还要发表博文，修改页面样式，添加一些诸如搜索、评论、浏览统计等等功能，预知后事如何，且听下文分解！ 写博客新建博文1hexo new &#x27;文件名&#x27; # 会在source/_posts创建一个文件名.md文件 编辑博文1234567---title: new // 博客标题date: 2017-04-04 04:04:06 // 创建时间tags: hexo // 标签categories: hexo // 分类--- 这里写正文（上面的---是必要的） 插入图片外网图片1![图片描述](http://www.baidu.com/1.jpg) 本地图片使用hexo-asset-image插件1npm install hexo-asset-image --save 修改xuyz-blog&#x2F;_config.yml中的post_asset_folder为true 1post_asset_folder: false 之后再使用 hexo new ‘new’ 创建新博文的时候，会在source&#x2F;_posts里面创建.md文件的同时生成一个相同的名字的文件夹，把该文章中需要使用的图片放在该文件夹下即可 1![图片描述](new/new.jpg) 在source下新建images文件夹（推荐）使用hexo-asset-image个人认为不利用图片复用，直接根目录的source下新建存放本地图片的文件夹简便有效 1![图片描述(可以不写)](/images/new.jpg) 更换主题主题这东西嘛，萝卜青菜，各有所爱，没有最好，只有合适，具体请移步hexo主题选取一款适合自己的吧！ 以next为例，下载对应主题，修改_config.yml中的theme为next即可！ 12cd xuyz-blog文件下git clone https://github.com/iissnan/hexo-theme-next themes/next 更多关于next主题下的配置问题请移步next使用文档","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]}],"categories":[{"name":"vuex","slug":"vuex","permalink":"http://example.com/categories/vuex/"},{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"},{"name":"心情物语","slug":"心情物语","permalink":"http://example.com/categories/%E5%BF%83%E6%83%85%E7%89%A9%E8%AF%AD/"}],"tags":[{"name":"vuex 源码","slug":"vuex-源码","permalink":"http://example.com/tags/vuex-%E6%BA%90%E7%A0%81/"},{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"},{"name":"数组方法","slug":"数组方法","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"name":"virtual-dom","slug":"virtual-dom","permalink":"http://example.com/tags/virtual-dom/"},{"name":"闭包","slug":"闭包","permalink":"http://example.com/tags/%E9%97%AD%E5%8C%85/"},{"name":"原型","slug":"原型","permalink":"http://example.com/tags/%E5%8E%9F%E5%9E%8B/"},{"name":"new的过程","slug":"new的过程","permalink":"http://example.com/tags/new%E7%9A%84%E8%BF%87%E7%A8%8B/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"心情物语","slug":"心情物语","permalink":"http://example.com/tags/%E5%BF%83%E6%83%85%E7%89%A9%E8%AF%AD/"}]}