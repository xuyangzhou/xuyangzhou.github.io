{"meta":{"title":"Jason","subtitle":"鲜衣怒马少年时，一日看尽长安花","description":"光景不待人，须臾发成丝","author":"Jason xu","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2024-04-07T09:24:07.000Z","updated":"2024-04-07T09:24:07.000Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2024-04-07T09:24:36.000Z","updated":"2024-04-07T09:24:36.000Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"10个让你爱不释手的一行Javascript代码","slug":"js10","date":"2023-05-08T03:01:42.000Z","updated":"2023-05-08T03:01:42.000Z","comments":true,"path":"2023/05/08/js10/","permalink":"http://example.com/2023/05/08/js10/","excerpt":"","text":"在这篇博客中，我们将分享 10+ 个实用的一行 JavaScript 代码，这些代码可以帮助你提高编码效率和代码简洁度。这些代码片段将涵盖各种用途，从操作数组和字符串，到更高级的概念，如异步编程和面向对象编程。 获取数组中的随机元素使用 Math.random() 函数和数组长度可以轻松获取数组中的随机元素： 123const arr = [1, 2, 3, 4, 5];const randomElement = arr[Math.floor(Math.random() * arr.length)];console.log(randomElement); 数组扁平化使用 reduce() 函数和 concat() 函数可以轻松实现数组扁平化： 123const arr = [[1, 2], [3, 4], [5, 6]];const flattenedArr = arr.reduce((acc, cur) =&gt; acc.concat(cur), []);console.log(flattenedArr); // [1, 2, 3, 4, 5, 6] 对象数组根据某个属性值进行排序1const sortedArray = array.sort((a, b) =&gt; (a.property &gt; b.property ? 1 : -1)); 从数组中删除特定元素1const removedArray = array.filter((item) =&gt; item !== elementToRemove); 检查数组中是否存在重复项1const hasDuplicates = (array) =&gt; new Set(array).size !== array.length; 首字母大写1const capitalized = str.charAt(0).toUpperCase() + str.slice(1); 获取随机整数1const randomInt = Math.floor(Math.random() * (max - min + 1)) + min; 获取随机字符串1const randomStr = Math.random().toString(36).substring(2, length); 使用解构和 rest 运算符交换变量的值：123let a = 1, b = 2[b, a] = [a, b]console.log(a, b) // 2, 1 将字符串转换为小驼峰式命名：123const str = &#x27;hello world&#x27;const camelCase = str.replace(/\\s(.)/g, ($1) =&gt; $1.toUpperCase()).replace(/\\s/g, &#x27;&#x27;).replace(/^(.)/, ($1) =&gt; $1.toLowerCase())console.log(camelCase) // &quot;helloWorld&quot; 计算两个日期之间的间隔1const diffInDays = (dateA, dateB) =&gt; Math.floor((dateB - dateA) / (1000 * 60 * 60 * 24)); 查找日期位于一年中的第几天1const dayOfYear = (date) =&gt; Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24); 复制内容到剪切板123const copyToClipboard = (text) =&gt; navigator.clipboard.writeText(text);copyToClipboard(&quot;Hello World&quot;); 获取变量的类型12345678910const getType = (variable) =&gt; Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();getType(&#x27;&#x27;); // stringgetType(0); // numbergetType(); // undefinedgetType(null); // nullgetType(&#123;&#125;); // objectgetType([]); // arraygetType(0); // numbergetType(() =&gt; &#123;&#125;); // function 检测对象是否为空1const isEmptyObject = (obj) =&gt; Object.keys(obj).length === 0 &amp;&amp; obj.constructor === Object;","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"10个JavaScript简洁编码技巧","slug":"js-pithy","date":"2023-05-07T03:01:42.000Z","updated":"2023-05-07T03:01:42.000Z","comments":true,"path":"2023/05/07/js-pithy/","permalink":"http://example.com/2023/05/07/js-pithy/","excerpt":"","text":"在前端开发中，代码简洁非常重要。不仅可以提高代码的可读性和可维护性，还能使代码更易于扩展和重用。下面介绍一些前端代码简洁的方法。 参数默认值12345678910// 传统写法function greeting(name) &#123; name = name || &#x27;Guest&#x27;; console.log(&#x27;Hello, &#x27; + name + &#x27;!&#x27;);&#125;// 使用默认值function greeting(name = &#x27;Guest&#x27;) &#123; console.log(&#x27;Hello, &#x27; + name + &#x27;!&#x27;);&#125; 箭头函数123456var sum = function(a, b) &#123; return a + b;&#125;// 使用箭头函数const sum = (a, b) =&gt; a + b; 模板字符串1234567// 传统写法var name = &#x27;Alice&#x27;;console.log(&#x27;Hello, &#x27; + name + &#x27;!&#x27;);// 使用模板字符串const name = &#x27;Alice&#x27;;console.log(`Hello, $&#123;name&#125;!`); 对象字面量简写123456789101112// 传统写法var firstName = &#x27;John&#x27;;var lastName = &#x27;Doe&#x27;;var user = &#123; firstName: firstName, lastName: lastName&#125;;// 使用简写const firstName = &#x27;John&#x27;;const lastName = &#x27;Doe&#x27;;const user = &#123; firstName, lastName &#125;; 解构赋值1234567891011121314// 传统写法var user = &#123; firstName: &#x27;John&#x27;, lastName: &#x27;Doe&#x27;&#125;;var firstName = user.firstName;var lastName = user.lastName;// 使用解构赋值const user = &#123; firstName: &#x27;John&#x27;, lastName: &#x27;Doe&#x27;&#125;;const &#123; firstName, lastName &#125; = user; Array.prototype.map()12345678910// 传统写法var numbers = [1, 2, 3];var doubledNumbers = [];for (var i = 0; i &lt; numbers.length; i++) &#123; doubledNumbers.push(numbers[i] * 2);&#125;// 使用map()const numbers = [1, 2, 3];const doubledNumbers = numbers.map(number =&gt; number * 2); Array.prototype.filter()123456789101112// 传统写法var numbers = [1, 2, 3, 4, 5];var evenNumbers = [];for (var i = 0; i &lt; numbers.length; i++) &#123; if (numbers[i] % 2 === 0) &#123; evenNumbers.push(numbers[i]); &#125;&#125;// 使用filter()const numbers = [1, 2, 3, 4, 5];const evenNumbers = numbers.filter(number =&gt; number % 2 === 0); Array.prototype.reduce()12345678910// 传统写法var numbers = [1, 2, 3, 4, 5];var sum = 0;for (var i = 0; i &lt; numbers.length; i++) &#123; sum += numbers[i];&#125;// 使用reduce()const numbers = [1, 2, 3, 4, 5];const sum = numbers.reduce((total, number) =&gt; total + number, 0); 避免使用全局变量全局变量会导致变量名冲突和意外的赋值，最好避免使用。可以将需要的变量定义在函数内部或使用模块化的方式管理变量。 1234567891011121314151617// 不推荐使用全局变量const name = &#x27;张三&#x27;;function getName() &#123; return name;&#125;// 推荐使用函数内部变量function getName() &#123; const name = &#x27;张三&#x27;; return name;&#125;// 推荐使用模块化// moduleA.jsexport const name = &#x27;张三&#x27;;// moduleB.jsimport &#123; name &#125; from &#x27;./moduleA.js&#x27;; 使用数组和对象解构解构可以让代码更加简洁，同时提高可读性。 1234567// 数组解构const arr = [1, 2, 3];const [first, second, third] = arr;// 对象解构const obj = &#123; name: &#x27;张三&#x27;, age: 18 &#125;;const &#123; name, age &#125; = obj; 使用函数式编程思想函数式编程思想可以让代码更加简洁，同时提高可维护性。可以使用纯函数、高阶函数、柯里化等方式。 123456789101112131415161718// 纯函数function add(a, b) &#123; return a + b;&#125;// 高阶函数function double(fn) &#123; return function(num) &#123; return fn(num) * 2; &#125;&#125;// 柯里化function add(a) &#123; return function(b) &#123; return a + b; &#125;&#125; 以上是一些简单的示例，当然还有很多其他的技巧和方法可以用来让前端代码更加简洁。总之，通过使用这些技巧和方法，我们可以让代码更加易于阅读、维护和扩展，提高开发效率。","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"[译] 动画无法动画化的元素","slug":"animatingTheUnanimatable","date":"2023-05-06T03:01:42.000Z","updated":"2023-05-06T03:01:42.000Z","comments":true,"path":"2023/05/06/animatingTheUnanimatable/","permalink":"http://example.com/2023/05/06/animatingTheUnanimatable/","excerpt":"","text":"原文 Animating the Unanimatable 在 CSS3 transitions、@keyframe动画和即将推出的 Web Animations API 等新技术的帮助下，我们在构建Web动画方面拥有了更多的控制力。 然而，仍有一件事情是这些技术不能直接处理的；即列表重新排序的动画效果。 假设你有这样一个组件： 1234567891011class ArticleList extends Component &#123; render() &#123; return ( &lt;div id=&quot;article-list&quot;&gt; &#123;this.props.articles.map(article =&gt; ( &lt;Article key=&#123;article.id&#125; &#123;...article&#125; /&gt; ))&#125; &lt;/div&gt; ); &#125;&#125; 我们有一个父级 ArticleList 组件，它以文章列表为props。 它按顺序映射它们并呈现它们。 如果列表顺序发生更改（例如：用户切换更改排序的设置，项目被点赞并更改位置，从服务器接收新数据…），React会协调两个状态，并更新 DOM，创建新节点，移动现有节点或销毁节点。 如果项目从其原始位置移除并重新插入到下方200px处，它对于元素的屏幕位置没有意识。 由于元素的CSS属性没有更改，因此无法使用CSS转换来动画显示此更改。 我们怎样才能让浏览器表现得好像这些元素已经移动了一样？这个问题的解决方案将带我们体验低级 DOM 操作、React 生命周期方法和硬件加速 CSS 实践。甚至会有一些基础数学！ 解决方案 TL:DR — 我制作了一个 React 模块来执行此操作。 来源| 演示 为了解决这个问题，我们需要一些特定时刻的信息。暂且不考虑获取这些信息的复杂性，我们假设： 我们知道 React 只是重新渲染，DOM 节点已经重新排列。 浏览器还没有绘制。尽管 DOM 节点处于新位置，但屏幕上的元素尚未更新。 我们知道元素在屏幕上的位置。 我们知道元素将在哪里重新绘制。 我们的情况可能是这样的：我们有一个包含 3 个项目的列表，它们只是被颠倒了。我们知道他们原来的位置（左侧），我们知道他们要移动到哪里（右侧）。 请忽略我缺乏艺术能力 操作顺序一个小插曲：你可能会惊讶地发现存在一个时间点，我们可以在某个时间点将项目绘制到屏幕上之前判断它的位置。 仔细想想，这是有道理的；浏览器如何在不知道确切绘制位置的情况下将新的像素绘制到屏幕上呢？ 幸运的是，这不是黑匣子；浏览器以不同的步骤更新，可以在计算布局和绘制到屏幕之间执行逻辑。 但是，我们如何访问计算后的布局？ DOMRects 来拯救！DOM 节点有一个非常有用的本地方法getBoundingClientRect。它为我们提供了目标元素相对于视口的大小和位置。在计算新布局之前，如果我们在顶部的蓝色矩形上调用它，它可能会给我们以下信息： 123456789blueItem.getBoundingClientRect();// &#123;// top: 0,// bottom: 600,// left: 0,// right: 500,// height: 60,// width: 400// &#125; 并且，在计算新布局之后： 123456789blueItem.getBoundingClientRect();// &#123;// top: 136,// bottom: 464,// left: 0,// right: 500,// height: 60,// width: 400// &#125; getBoundingClientRect 足够聪明，可以计算出元素的新布局位置，同时考虑元素的高度、边距和任何其他会影响它在视口中的位置的变量。 有了这两个数据，我们就可以计算出元素位置的变化；它的 delta 值。 Δy &#x3D; finalTop - initialTop &#x3D; 132 - 0 &#x3D; 132 所以，我们知道元素向下移动了 132px。同样，我们知道中间的项目根本没有移动（Δy &#x3D; 0px），最后一个项目向上移动了132px（Δy &#x3D; -132px）。 问题在于，虽然我们知道所有这些事实，但DOM即将更新；在眨眼间，那些盒子将瞬间处于它们的新位置！ 这是我们工具库中的下一个工具的用武之地：requestAnimationFrame。 这是 window 对象上的一个方法，它告诉浏览器“嘿，在你对屏幕进行任何更改之前，你能先运行这段代码吗？”。这是一种在更新元素之前快速进行任何所需调整的方法。 如果在浏览器绘制之前，我们应用更改的逆函数怎么办？想象一下这个 CSS： 1234567891011.blue-item &#123; top: -132px;&#125;.purple-item &#123; top: 0;&#125;.fuscia-item &#123; top: 132px;&#125; 浏览器会绘制此更新，但绘制不会改变任何东西；DOM 节点的位置发生了变化，但我们已经用 CSS 抵消了这种变化。 这是个有技巧的操作，让我们简要回顾一下刚才发生了什么： React 渲染我们的初始状态，蓝色项目在顶部。我们使用 getBoundingClientRect 来确定项目的位置。 React 收到 props：项目已被撤销！现在蓝色项目在底部。 我们使用 getBoundingClientRect 来确定项目现在的位置，并计算位置的变化。 我们使用 requestAnimationFrame 告诉 DOM 应用一些 CSS 来撤销这个新的变化；如果元素的新位置低 100px，我们应用 CSS 使其高 100px。 到了动画时间了好的，我们确实完成了某些事情；我们使得 DOM 的变化对用户完全不可见。这可能是一个很有趣的花招，但现在可能还不清楚它如何帮助我们。 问题是，我们现在处于一个情况下，普通的 CSS 过渡效果可以再次使用了。为了将这些元素动画到它们的新位置，我们可以添加一个过渡效果并撤消这些人为的位置更改。 继续使用我们上面的例子：我们的蓝色项实际上是最后一项，但它看起来像是第一项。它的 CSS 如下： 123.blue-item &#123; top: -132px;&#125; 现在，让我们更新 CSS，使其看起来像这样： 1234.blue-item &#123; transition: top 500ms; top: 0;&#125; 蓝色项目现在将在半秒内从顶部位置向下滑动到底部位置。万岁！我们已经动画化了一些东西。 这种技术由 Google 的 Paul Lewis 推广，他称之为 FLIP 技术。FLIP 是First、Last、I nverse、P lay 的首字母缩写词。 计算第一个位置。 计算最后位置。 反转位置 播放动画 我们的版本有些不同，但原理是相同的。 对DOM的简要探究在学习这项技术和编写我的模块时，我学到了很多关于 DOM 渲染的知识。虽然我学到的大部分内容超出了本文的范围，但我们应该快速了解一下：绘画和合成之间的区别，以及它对选择硬件加速 CSS 属性的影响。 最初，浏览器通过 CPU 完成所有工作。近年来，一些非常聪明的人发现可以将某些任务委托给 GPU 以大幅提高性能；具体来说，当静态内容的“纹理”没有改变时。 主要目标是加快滚动速度；当您向下滚动页面时，没有任何元素发生变化，它们只是向上滑动。浏览器的人很友善，也允许某些 css 属性以相同的方式工作。 通过使用CSS 属性的变换套件——平移、缩放、旋转、倾斜等——以及不透明度，我们不会改变元素的纹理。如果纹理没有改变，则不必在每一帧上都重新绘制；它可以由 GPU 合成。这就是实现 60+fps 动画的方法。 如果您想了解有关浏览器渲染过程的更多信息（您应该这样做！既有趣又实用），我在下面提供了一些链接。 但是，在我们的例子中，这意味着我们应该使用 transform 而不是 top： 1234.blue-item &#123; transition: transform 500ms; transform: translateY(0px);&#125; 缺失的部分：React 注意：这篇文章最初是很久以前写的，特别是这一部分的代码还没有很好地老化。使用的生命周期方法已被弃用，并且强烈建议不要使用 ReactDOM.findDOMNode。本节中的思路是可靠，但但请不要尝试重用提供的代码！ React 如何与这一技术结合？令人高兴的是，React 与这一技术完美契合。 每个子元素都需要两个重要的属性才能使其正常运作：： 每个子元素都需要一个唯一的”key”属性，这是我们用来区分它们的。 每个子元素都需要一个 ref，这样我们就可以查找 DOM 节点并计算其边界框。 获取第一个位置每当组件接收到新的 props，我们需要检查是否需要动画。最早的机会是在 componentWillReceiveProps 生命周期方法中。 12345678910111213141516171819class ArticleList extends Component &#123; componentWillReceiveProps() &#123; this.props.children.forEach(child =&gt; &#123; // Find the ref for this specific child. const ref = this.refs[child.key]; // Look up the DOM node const domNode = ReactDOM.findDOMNode(ref); // Calculate the bounding box const boundingBox = domNode.getBoundingClientRect(); // Store that box in the state, by its key. this.setState(&#123; [child.key]: boundingBox, &#125;); &#125;); &#125;&#125; 在这个过程的结尾，我们的 state 将充满 DOMRect 对象，准确地描述每个子元素在页面上的位置。 获得最后位置下一个任务是弄清楚事物的去向。 这里要做出的非常重要的区别是 React 的 *render* 方法不会立即绘制到屏幕上。我对底层细节有点模糊，但这个过程看起来有点像这样： render返回它希望 DOM 成为什么的表示， React 将这种表示与 DOM 的实际状态相协调，并应用差异， 浏览器注意到有些东西发生了变化，并计算出新的布局， React 的 componentDidUpdate 生命周期方法触发， 浏览器将更改绘制到屏幕上。 这个过程的美妙之处在于，我们有机会在计算布局之后但在屏幕更新之前连接到 DOM 的状态。 下面是代码： 12345678componentDidUpdate(previousProps) &#123; previousProps.children.forEach(child =&gt; &#123; let domNode = ReactDOM.findDOMNode(this.refs[child.key]); const newBox = domNode.getBoundingClientRect(); // ...more to come &#125;);&#125; 反转我们现在知道第一个和最后一个位置，没有一毫秒的空闲时间！DOM 即将更新！ 我们将使用 requestAnimationFrame 来确保我们的更改在该帧之前完成。 我们继续编写 componentDidUpdate 方法： 123456789101112131415161718componentDidUpdate(previousProps) &#123; previousProps.children.forEach(child =&gt; &#123; let domNode = ReactDOM.findDOMNode(this.refs[child.key]); const newBox = domNode.getBoundingClientRect(); const oldBox = this.state[key]; const deltaX = oldBox.left - newBox.left; const deltaY = oldBox.top - newBox.top; requestAnimationFrame(() =&gt; &#123; // Before the DOM paints, Invert it to its old position domNode.style.transform = `translate($&#123;deltaX&#125;px, $&#123;deltaY&#125;px)`; // Ensure it inverts it immediately domNode.style.transition = &#x27;transform 0s&#x27;; &#125;); &#125;);&#125; 此时，该方法运行后，我们的 DOM 节点将重新排列，但它们在屏幕上的位置将保持不变。太棒了！只剩下最后一步了… 播放123456789101112131415161718192021222324252627componentDidUpdate(previousProps) &#123; previousProps.children.forEach(child =&gt; &#123; let domNode = ReactDOM.findDOMNode(this.refs[child.key]); const newBox = domNode.getBoundingClientRect(); const oldBox = this.state[key]; const deltaX = oldBox.left - newBox.left; const deltaY = oldBox.top - newBox.top; requestAnimationFrame(() =&gt; &#123; domNode.style.transform = `translate($&#123;deltaX&#125;px, $&#123;deltaY&#125;px)`; domNode.style.transition = &#x27;transform 0s&#x27;; requestAnimationFrame(() =&gt; &#123; // In order to get the animation to play, we&#x27;ll need to wait for // the &#x27;invert&#x27; animation frame to finish, so that its inverted // position has propagated to the DOM. // // Then, we remove the transform, reverting it to its natural // state, and apply a transition so it does so smoothly. domNode.style.transform = &#x27;&#x27;; domNode.style.transition = &#x27;transform 500ms&#x27;; &#125;); &#125;); &#125;);&#125; 哈！我们已经完成了，我们已经为不可动画的元素添加了动画效果。","categories":[{"name":"外文翻译","slug":"外文翻译","permalink":"http://example.com/categories/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"},{"name":"动画","slug":"动画","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB/"}]},{"title":"10个超级实用的typescript使用技巧","slug":"typescript-eg","date":"2023-05-04T04:00:00.000Z","updated":"2023-05-04T04:00:00.000Z","comments":true,"path":"2023/05/04/typescript-eg/","permalink":"http://example.com/2023/05/04/typescript-eg/","excerpt":"","text":"概览：在实际的开发工作过程中，积累了一些常见又超级好用的 typescript 技巧和代码片段，包括整理的其他大神的ts使用技巧，今天筛选了 10+ 个，以供大家参考。 使用交叉类型来合并多个类型1234567891011121314type User = &#123; name: string;&#125;;type Admin = &#123; role: string;&#125;;type UserAndAdmin = User &amp; Admin;const user: UserAndAdmin = &#123; name: &quot;John&quot;, role: &quot;admin&quot;&#125;; 使用联合类型来允许多个类型1234567type Status = &quot;success&quot; | &quot;error&quot; | &quot;loading&quot;;function showMessage(status: Status, message: string) &#123; // ...&#125;showMessage(&quot;success&quot;, &quot;Operation completed successfully&quot;); 使用类型守卫来判断变量的类型12345678910111213141516type User = &#123; name: string;&#125;;type Admin = &#123; name: string; role: string;&#125;;function greet(user: User | Admin) &#123; if (&quot;role&quot; in user) &#123; console.log(`Hello, $&#123;user.name&#125;, you are an admin`); &#125; else &#123; console.log(`Hello, $&#123;user.name&#125;`); &#125;&#125; 使用optional chaining操作符(?.)和nullish coalescing操作符(??)来简化代码12345678const user = &#123; name: &quot;John&quot;, address: &#123; city: null &#125;&#125;;const cityName = user?.address?.city ?? &quot;unknown&quot;; 使用装饰器来扩展类和方法的行为12345678910111213141516171819202122function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123; const originalMethod = descriptor.value; descriptor.value = function(...args: any[]) &#123; console.log(`Calling method $&#123;propertyKey&#125; with arguments: $&#123;JSON.stringify(args)&#125;`); return originalMethod.apply(this, args); &#125;; return descriptor;&#125;class User &#123; constructor(public name: string, public age: number) &#123;&#125; @log greet() &#123; console.log(`Hello, my name is $&#123;this.name&#125; and I am $&#123;this.age&#125; years old`); &#125;&#125;const user = new User(&quot;John&quot;, 30);user.greet(); 使用 Record 来定义键值对类型1234567type AgeMap = Record&lt;string, number&gt;;const ages: AgeMap = &#123; John: 30, Mary: 25, Mike: 35,&#125;; 使用模板字符串和 keyof 来生成属性名称12345678910111213interface Person &#123; name: string; age: number;&#125;function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] &#123; return obj[key];&#125;const person: Person = &#123; name: &quot;John&quot;, age: 30 &#125;;const propertyName = &quot;name&quot;;console.log(getProperty(person, propertyName as keyof Person));console.log(getProperty(person, &quot;age&quot;)); 在上面的代码中，我们使用模板字符串和 keyof 操作符来生成属性名称，并将其作为参数传递给函数 getProperty。 使用类型保护来检查变量的类型12345678910111213141516171819interface Dog &#123; name: string; breed: string;&#125;interface Cat &#123; name: string; age: number;&#125;function isDog(pet: Dog | Cat): pet is Dog &#123; return (pet as Dog).breed !== undefined;&#125;const dog: Dog = &#123; name: &quot;Max&quot;, breed: &quot;Labrador&quot; &#125;;const cat: Cat = &#123; name: &quot;Whiskers&quot;, age: 3 &#125;;console.log(isDog(dog)); // trueconsole.log(isDog(cat)); // false 在上面的代码中，我们使用 isDog 函数来检查变量 pet 是否是 Dog 类型。 使用 Exclude 和 Extract 来过滤类型123type T1 = string | number | boolean;type T2 = Exclude&lt;T1, boolean&gt;;type T3 = Extract&lt;T1, string&gt;; 在上面的代码中，我们使用 Exclude 和 Extract 类型来过滤 T1 类型。T2 类型将移除 boolean 类型，而 T3 类型将只保留 string 类型。 使用 Partial 和 Required 来转换类型1234567interface Person &#123; name: string; age: number;&#125;type PartialPerson = Partial&lt;Person&gt;;type RequiredPerson = Required&lt;PartialPerson&gt;; 在上面的代码中，我们使用 Partial 和 Required 类型来转换类型。PartialPerson 类型将转换为可选的属性，而 RequiredPerson 类型将转换为必填的属性。 使用 Pick 和 Omit 来选择和排除属性12345678interface Person &#123; name: string; age: number; address: string;&#125;type PersonNameAge = Pick&lt;Person, &quot;name&quot; | &quot;age&quot;&gt;;type PersonWithoutAddress = Omit&lt;Person, &quot;address&quot;&gt;; 在上面的代码中，我们使用 Pick 和 Omit 类型来选择和排除属性。PersonNameAge 类型将只保留 name 和 age 属性，而 PersonWithoutAddress 类型将排除 address 属性。 使用 as const 来创建只读数组和对象12const arr = [&quot;foo&quot;, &quot;bar&quot;] as const;const obj = &#123; name: &quot;John&quot;, age: 30 &#125; as const; 在上面的代码中，我们使用 as const 来创建只读数组和对象。arr 和 obj 将不可修改。 使用 Readonly 来使对象的所有属性变为只读12345678910interface Person &#123; name: string; age: number; address: string;&#125;type ReadonlyPerson = Readonly&lt;Person&gt;;const person: ReadonlyPerson = &#123; name: &quot;John&quot;, age: 30, address: &quot;123 Main St.&quot; &#125;;person.age = 31; // Error: Cannot assign to &#x27;age&#x27; because it is a read-only property. 在上面的代码中，我们使用 Readonly 来使对象的所有属性变为只读。ReadonlyPerson 类型将具有与 Person 相同的属性，但所有属性都是只读的。 使用 Required 来使对象的所有属性变为必需的123456789interface Person &#123; name?: string; age?: number; address?: string;&#125;type RequiredPerson = Required&lt;Person&gt;;const person: RequiredPerson = &#123; name: &quot;John&quot;, age: 30, address: &quot;123 Main St.&quot; &#125;; 在上面的代码中，我们使用 Required 来使对象的所有属性变为必需的。RequiredPerson 类型将具有与 Person 相同的属性，但所有属性都是必需的。 使用 NonNullable 来移除对象的所有可空属性123456789interface Person &#123; name?: string; age?: number | null; address?: string | null;&#125;type NonNullablePerson = NonNullable&lt;Person&gt;;const person: NonNullablePerson = &#123; name: &quot;John&quot;, age: 30, address: &quot;123 Main St.&quot; &#125;;","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://example.com/tags/typescript/"}]},{"title":"[译] ECMAScript 2023有哪些新特性","slug":"javascript","date":"2023-04-20T03:01:42.000Z","updated":"2023-04-20T03:01:42.000Z","comments":true,"path":"2023/04/20/javascript/","permalink":"http://example.com/2023/04/20/javascript/","excerpt":"","text":"原文 What’s new in ECMAScript 20232023.4.18 by Pawel 在阅读了上一次 TC39 会议的记录之后，似乎已经知道了即将推出的 JavaScript 的新功能列表。ECMAScript规范的最终版本预计将在 6 月底发布。 最后而且最重要的是，我们正在削减 ES2023。我们将其冻结，或者更确切地说，我应该说我们已经将其冻结。我们不希望再有任何重大的编辑性变化。可能会有至少几个非常小的编辑性微调，但没有大的变化。 让我分享一下所有达到第4阶段的新功能列表，这些功能预计将包含在即将推出的ECMAScript版本中。就像我在2022、 2021、 2020、 2019、 2018,、2017 和 2016 年所做的那样。 从后向前查找数组元素 Hashbang语法 Symbol作为WeakMap键 通过复制改变数组 从后向前查找数组元素由Wenlu Wang提出的“从后向前查找数组元素”提案在Array和TypedArray原型上添加了findLast()和findLastIndex()方法。它们与find()和findIndex()方法具有相同的功能，但顺序相反。这两种方法很方便，让我们避免创建临时副本、突变和混淆的索引。 1234567891011121314const isEven = (number) =&gt; number % 2 === 0;const numbers = [1, 2, 3, 4];​// 从第一个到最后一个查找console.log(numbers.find(isEven));// 2console.log(numbers.findIndex(isEven));// 1​// 从最后一个到第一个查找console.log(numbers.findLast(isEven));// 4console.log(numbers.findLastIndex(isEven));// 3 Hashbang语法Hashbang，也称为shebang ，是可执行脚本开头的一系列字符，用于定义要运行的程序的解释器。当Unix内核的程序加载器执行JavaScript程序时，主机会剥离hashbang以生成有效的源代码，然后将其传递给引擎。Bradley Farias提出的Hashbang语法提案规范了这个过程。 123#!/usr/bin/env node​console.log(&#x27;hi 👋&#x27;); Symbol作为WeakMap键在JavaScript中，对象和Symbol保证是唯一的，不能重新创建，这使它们都成为WeakMap键的理想候选者。先前的版本或规范只允许使用对象作为键，但幸运的是，由Daniel Ehrenberg、Richard Button、Robin Ricard、Leo Balter、Rick Waldron和Caridy Patiño提出的Symbol作为WeakMap键提案将未注册的Symbol添加到允许的键列表中。 123456const weak = new WeakMap();const key = Symbol(&quot;ref&quot;);weak.set(key, &quot;ECMAScript 2023&quot;);​console.log(weak.get(key));// ECMAScript 2023 通过复制改变数组Array.prototype 上的 reverse()、sort() 和 splice() 方法会就地突变数组。Ashley Claymore 和 Robin Ricard 提出的 Change Array by Copy proposal 添加了 toReversed()、toSorted() 和 toSpliced() 方法的副本，它们会返回一个新的数组。此提议还添加了一个 with() 方法，该方法返回一个新数组，其中给定索引处的元素用给定值替换，以避免使用括号表示法进行就地突变。 1234567891011121314151617181920212223242526272829303132const original = [1, 2, 3, 4];const reversed = original.toReversed();​console.log(original);// [ 1, 2, 3, 4 ]​console.log(reversed);// [ 4, 3, 2, 1 ]const original = [1, 3, 2, 4];const sorted = original.toSorted();​console.log(original);// [ 1, 3, 2, 4 ]​console.log(sorted);// [ 1, 2, 3, 4 ]const original = [1, 4];const spliced = original.toSpliced(1, 0, 2, 3);​console.log(original);// [ 1, 4 ]​console.log(spliced);// [ 1, 2, 3, 4 ]const original = [1, 2, 2, 4];const withThree = original.with(2, 3);​console.log(original);// [ 1, 2, 2, 4 ]​console.log(withThree);// [ 1, 2, 3, 4 ]","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"10个超级实用的reduce使用技巧","slug":"reduce","date":"2023-04-20T03:01:42.000Z","updated":"2023-04-20T03:01:42.000Z","comments":true,"path":"2023/04/20/reduce/","permalink":"http://example.com/2023/04/20/reduce/","excerpt":"","text":"reduce 函数可以根据需要进行累加、过滤、分组、映射等操作，是一个非常强大的数组方法。在数据处理时使用的非常频繁，很多复杂的逻辑如果用reduce去处理，都非常的简洁，在实际的开发工作过程中，积累了一些常见又超级好用的 reduce 技巧的代码片段，筛选了如下 10 个，以供大家参考 reduce 介绍reduce 是数组的方法，可以对数组中的每个元素依次执行一个回调函数，从左到右依次累积计算出一个最终的值。其语法为： arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue]) 其中，callback 是每个元素执行的回调函数，其包含 4 个参数： accumulator：累积器，即上一次回调函数执行的返回值。 currentValue：当前元素的值。 index：当前元素的下标。 array：原始数组。 initialValue 是可选的，表示累积器的初始值。 reduce 函数的执行过程如下： 如果没有提供 initialValue，则将数组的第一个元素作为累积器的初始值，否则将 initialValue 作为累积器的初始值。 从数组的第二个元素开始，依次对数组中的每个元素执行回调函数。 回调函数的返回值作为下一次回调函数执行时的累积器的值。 对数组中的每个元素执行完回调函数后，reduce 函数返回最后一次回调函数的返回值，即最终的累积值。 计算数组中每个元素出现的次数123456const fruits = [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;, &#x27;apple&#x27;];const count = fruits.reduce((accumulator, currentValue) =&gt; &#123; accumulator[currentValue] = (accumulator[currentValue] || 0) + 1; return accumulator;&#125;, &#123;&#125;);console.log(count); // Output: &#123; apple: 3, banana: 2, orange: 1 &#125; 拍平嵌套数组123const nestedArray = [[1, 2], [3, 4], [5, 6]];const flattenedArray = nestedArray.reduce((accumulator, currentValue) =&gt; accumulator.concat(currentValue), []);console.log(flattenedArray); // Output: [1, 2, 3, 4, 5, 6] 按条件分组123456789101112131415161718192021const people = [ &#123; name: &#x27;Alice&#x27;, age: 25 &#125;, &#123; name: &#x27;Bob&#x27;, age: 30 &#125;, &#123; name: &#x27;Charlie&#x27;, age: 35 &#125;, &#123; name: &#x27;David&#x27;, age: 25 &#125;, &#123; name: &#x27;Emily&#x27;, age: 30 &#125;];const groupedPeople = people.reduce((accumulator, currentValue) =&gt; &#123; const key = currentValue.age; if (!accumulator[key]) &#123; accumulator[key] = []; &#125; accumulator[key].push(currentValue); return accumulator;&#125;, &#123;&#125;);console.log(groupedPeople);// Output: &#123;// 25: [&#123; name: &#x27;Alice&#x27;, age: 25 &#125;, &#123; name: &#x27;David&#x27;, age: 25 &#125;],// 30: [&#123; name: &#x27;Bob&#x27;, age: 30 &#125;, &#123; name: &#x27;Emily&#x27;, age: 30 &#125;],// 35: [&#123; name: &#x27;Charlie&#x27;, age: 35 &#125;]// &#125; 将多个数组合并为一个对象12345678const keys = [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;gender&#x27;];const values = [&#x27;Alice&#x27;, 25, &#x27;female&#x27;];const person = keys.reduce((accumulator, currentValue, index) =&gt; &#123; accumulator[currentValue] = values[index]; return accumulator; &#125;, &#123;&#125;);console.log(person); // Output: &#123; name: &#x27;Alice&#x27;, age: 25, gender: &#x27;female&#x27; &#125; 将字符串转换为对象12345678const str = &#x27;key1=value1&amp;key2=value2&amp;key3=value3&#x27;;const obj = str.split(&#x27;&amp;&#x27;).reduce((accumulator, currentValue) =&gt; &#123; const [key, value] = currentValue.split(&#x27;=&#x27;); accumulator[key] = value; return accumulator;&#125;, &#123;&#125;);console.log(obj); // Output: &#123; key1: &#x27;value1&#x27;, key2: &#x27;value2&#x27;, key3: &#x27;value3&#x27; &#125; 将对象转换为查询字符串123456const params = &#123; foo: &quot;bar&quot;, baz: 42 &#125;;const queryString = Object.entries(params).reduce((acc, [key, value]) =&gt; &#123; return `$&#123;acc&#125;$&#123;key&#125;=$&#123;value&#125;&amp;`;&#125;, &quot;?&quot;).slice(0, -1);console.log(queryString); // &quot;?foo=bar&amp;baz=42&quot; 打印斐波那契数列1234567891011const fibonacci = n =&gt; &#123; return [...Array(n)].reduce((accumulator, currentValue, index) =&gt; &#123; if (index &lt; 2) &#123; accumulator.push(index); &#125; else &#123; accumulator.push(accumulator[index - 1] + accumulator[index - 2]); &#125; return accumulator; &#125;, []);&#125;;console.log(fibonacci(10)); // Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] 检查字符串是否是回文字符串12345const str = &#x27;racecar&#x27;;const isPalindrome = str.split(&#x27;&#x27;).reduce((accumulator, currentValue, index, array) =&gt; &#123; return accumulator &amp;&amp; currentValue === array[array.length - index - 1];&#125;, true);console.log(isPalindrome); // Output: true 检查括号是否匹配12345678910const str = &quot;(()()())&quot;;const balanced = str.split(&quot;&quot;).reduce((acc, cur) =&gt; &#123; if (cur === &quot;(&quot;) &#123; acc++; &#125; else if (cur === &quot;)&quot;) &#123; acc--; &#125; return acc;&#125;, 0) === 0;console.log(balanced); // true 递归获取对象属性12345678910111213const user = &#123; info: &#123; name: &quot;Jason&quot;, address: &#123; home: &quot;Shaanxi&quot;, company: &quot;Xian&quot; &#125;, &#125;,&#125;;function get(config, path, defaultVal) &#123; return path.split(&#x27;.&#x27;).reduce((config, name) =&gt; config[name], config) || defaultVal;&#125;get(user, &quot;info.name&quot;); // Jasonget(user, &quot;info.address.home&quot;); // Shaanxiget(user, &quot;info.address.company&quot;); // Xianget(user, &quot;info.address.abc&quot;, &quot;default&quot;); // default 手写 reduce可以通过手写一个简单的 reduce 函数来更好地理解它的实现原理： 1234567function myReduce(arr, callback, initialValue) &#123; let accumulator = initialValue === undefined ? arr[0] : initialValue; for (let i = initialValue === undefined ? 1 : 0; i &lt; arr.length; i++) &#123; accumulator = callback(accumulator, arr[i], i, arr); &#125; return accumulator;&#125; 上面的代码中，myReduce 函数接受 3 个参数：要执行 reduce 操作的数组 arr、回调函数 callback 和累积器的初始值 initialValue。如果没有提供初始值，则将数组的第一个元素作为累积器的初始值。 接下来，在循环中，如果有 initialValue，则从第一个元素开始遍历 callback，此时 callabck 的第二个参数是从数组的第一项开始的；如果没有 initialValue，则从第二个元素开始遍历 callback，此时 callback 的第二个参数是从数组的第二项开始的从数组的第二个元素开始，依次对数组中的每个元素执行回调函数，并将返回值作为下一次回调函数执行时的累积器的值。 最后，myReduce 函数返回最后一次回调函数的返回值，即最终的累积值。 这个简易的 reduce 函数并没有考虑很多边界情况和复杂的应用场景，但是可以帮助我们更好地理解 reduce 函数的实现原理。","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"},{"name":"reduce","slug":"reduce","permalink":"http://example.com/tags/reduce/"}]},{"title":"10个超级实用的Set、Map使用技巧","slug":"set-map","date":"2023-04-20T03:01:42.000Z","updated":"2023-04-20T03:01:42.000Z","comments":true,"path":"2023/04/20/set-map/","permalink":"http://example.com/2023/04/20/set-map/","excerpt":"","text":"Set是一种类似于数组的数据结构，但是它的值是唯一的，即Set中的每个值只会出现一次。Set对象的实例可以用于存储任何类型的唯一值，从而使它们非常适用于去重。 Map是一种键值对集合，其中每个键都是唯一的，可以是任何类型，而值则可以是任何类型。Map对象的实例可以用于存储复杂的对象，并且可以根据键进行快速的查找和访问。 以下是Set和Map的一些常用方法： Set: new Set(): 创建一个新的Set对象 add(value): 向Set对象中添加一个新的值 delete(value): 从Set对象中删除一个值 has(value): 检查Set对象中是否存在指定的值 size: 获取Set对象中的值的数量 clear(): 从Set对象中删除所有值 Map: new Map(): 创建一个新的Map对象 set(key, value): 向Map对象中添加一个键值对 get(key): 根据键获取Map对象中的值 delete(key): 从Map对象中删除一个键值对 has(key): 检查Map对象中是否存在指定的键 size: 获取Map对象中的键值对数量 clear(): 从Map对象中删除所有键值对 Set和Map是非常有用的数据结构，它们可以提高程序的性能和可读性，并且可以简化代码的编写。 Set去重使用 Set 可以轻松地进行数组去重操作，因为 Set 只能存储唯一的值。 123const arr = [1, 2, 3, 1, 2, 4, 5];const uniqueArr = [...new Set(arr)];console.log(uniqueArr); // [1, 2, 3, 4, 5] 数组转换可以使用 Set 将数组转换为不包含重复元素的 Set 对象，再使用 Array.from() 将其转换回数组。 1234const arr = [1, 2, 3, 1, 2, 4, 5];const set = new Set(arr);const uniqueArr = Array.from(set);console.log(uniqueArr); // [1, 2, 3, 4, 5] 优化数据查找使用 Set 存储数据时，查找操作的时间复杂度为 O(1)，比数组的 O(n) 要快得多，因此可以使用 Set 来优化数据查找的效率。 1234567const dataSet = new Set([1, 2, 3, 4, 5]);if (dataSet.has(3)) &#123; console.log(&#x27;数据已经存在&#x27;);&#125; else &#123; console.log(&#x27;数据不存在&#x27;);&#125; 并集、交集、差集Set数据结构可以用于计算两个集合的并集、交集和差集。以下是一些使用Set进行集合运算的示例代码： 1234567891011121314const setA = new Set([1, 2, 3]);const setB = new Set([2, 3, 4]);// 并集const union = new Set([...setA, ...setB]);console.log(union); // Set &#123;1, 2, 3, 4&#125;// 交集const intersection = new Set([...setA].filter(x =&gt; setB.has(x)));console.log(intersection); // Set &#123;2, 3&#125;// 差集const difference = new Set([...setA].filter(x =&gt; !setB.has(x)));console.log(difference); // Set &#123;1&#125; 模糊搜索Set 还可以通过正则表达式实现模糊搜索。可以将匹配结果保存到 Set 中，然后使用 Array.from() 方法将 Set 转换成数组。 12345const data = [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;];// 搜索以 &quot;a&quot; 开头的水果const result = Array.from(new Set(data.filter(item =&gt; /^a/i.test(item))));console.log(result); // [&quot;apple&quot;] 使用 Set 替代数组实现队列和栈可以使用 Set 来模拟队列和栈的数据结构。 123456789101112131415// 使用 Set 实现队列const queue = new Set();queue.add(1);queue.add(2);queue.add(3);queue.delete(queue.values().next().value); // 删除第一个元素console.log(queue); // Set(2) &#123; 2, 3 &#125;// 使用 Set 实现栈const stack = new Set();stack.add(1);stack.add(2);stack.add(3);stack.delete([...stack][stack.size - 1]); // 删除最后一个元素console.log(stack); // Set(2) &#123; 1, 2 &#125; Map将 Map 转换为对象12const map = new Map().set(&#x27;key1&#x27;, &#x27;value1&#x27;).set(&#x27;key2&#x27;, &#x27;value2&#x27;);const obj = Object.fromEntries(map); 将 Map 转换为数组12const map = new Map().set(&#x27;key1&#x27;, &#x27;value1&#x27;).set(&#x27;key2&#x27;, &#x27;value2&#x27;);const array = Array.from(map); 记录数据的顺序如果你需要记录添加元素的顺序，那么可以使用Map来解决这个问题。当你需要按照添加顺序迭代元素时，可以使用Map来保持元素的顺序。 12345678910const map = new Map();map.set(&#x27;a&#x27;, 1);map.set(&#x27;b&#x27;, 2);map.set(&#x27;c&#x27;, 3);map.set(&#x27;d&#x27;, 4);for (const [key, value] of map) &#123; console.log(key, value);&#125;// Output: a 1, b 2, c 3, d 4 统计数组中元素出现次数可以使用 Map 统计数组中每个元素出现的次数。 12345678910const arr = [1, 2, 3, 1, 2, 4, 5];const countMap = new Map();arr.forEach(item =&gt; &#123; countMap.set(item, (countMap.get(item) || 0) + 1);&#125;);console.log(countMap.get(1)); // 2console.log(countMap.get(2)); // 2console.log(countMap.get(3)); // 1 统计字符出现次数使用Map数据结构可以方便地统计字符串中每个字符出现的次数。 123456const str = &#x27;hello world&#x27;;const charCountMap = new Map();for (let char of str) &#123; charCountMap.set(char, (charCountMap.get(char) || 0) + 1);&#125;console.log(charCountMap); // Map &#123; &#x27;h&#x27; =&gt; 1, &#x27;e&#x27; =&gt; 1, &#x27;l&#x27; =&gt; 3, &#x27;o&#x27; =&gt; 2, &#x27; &#x27; =&gt; 1, &#x27;w&#x27; =&gt; 1, &#x27;r&#x27; =&gt; 1, &#x27;d&#x27; =&gt; 1 &#125; 缓存计算结果在处理复杂的计算时，可能需要对中间结果进行缓存以提高性能。可以使用Map数据结构缓存计算结果，以避免重复计算。 12345678910111213const cache = new Map();function fibonacci(n) &#123; if (n === 0 || n === 1) &#123; return n; &#125; if (cache.has(n)) &#123; return cache.get(n); &#125; const result = fibonacci(n - 1) + fibonacci(n - 2); cache.set(n, result); return result;&#125;console.log(fibonacci(10)); // 55 使用 Map 进行数据的分组12345678910111213141516171819const students = [ &#123; name: &quot;Tom&quot;, grade: &quot;A&quot; &#125;, &#123; name: &quot;Jerry&quot;, grade: &quot;B&quot; &#125;, &#123; name: &quot;Kate&quot;, grade: &quot;A&quot; &#125;, &#123; name: &quot;Mike&quot;, grade: &quot;C&quot; &#125;,];const gradeMap = new Map();students.forEach((student) =&gt; &#123; const grade = student.grade; if (!gradeMap.has(grade)) &#123; gradeMap.set(grade, [student]); &#125; else &#123; gradeMap.get(grade).push(student); &#125;&#125;);console.log(gradeMap.get(&quot;A&quot;)); // [&#123; name: &quot;Tom&quot;, grade: &quot;A&quot; &#125;, &#123; name: &quot;Kate&quot;, grade: &quot;A&quot; &#125;] 使用 Map 过滤符合条件的对象在实际开发中，我们常常需要在一个对象数组中查找符合某些条件的对象。此时，我们可以结合使用 Map 和 filter 方法来实现。比如： 12345678const users = [ &#123; name: &#x27;Alice&#x27;, age: 22 &#125;, &#123; name: &#x27;Bob&#x27;, age: 18 &#125;, &#123; name: &#x27;Charlie&#x27;, age: 25 &#125;];const userMap = new Map(users.map(user =&gt; [user.name, user]));const result = users.filter(user =&gt; userMap.has(user.name) &amp;&amp; user.age &gt; 20);console.log(result); // [&#123; name: &#x27;Alice&#x27;, age: 22 &#125;, &#123; name: &#x27;Charlie&#x27;, age: 25 &#125;] 首先，我们将对象数组转换为 Map，以便快速查找。然后，我们使用 filter 方法来过滤符合条件的对象。 这里我们列举了一些使用Set和Map的实用技巧，它们可以大大简化你的代码，并使你更有效地处理数据。Set和Map是JavaScript中非常有用的数据结构，值得我们在编写代码时好好利用。","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"},{"name":"set","slug":"set","permalink":"http://example.com/tags/set/"},{"name":"map","slug":"map","permalink":"http://example.com/tags/map/"}]},{"title":"Vuex 3 vs Vuex 4：差异对比","slug":"vuex3-4","date":"2023-04-18T03:01:42.000Z","updated":"2023-04-18T03:01:42.000Z","comments":true,"path":"2023/04/18/vuex3-4/","permalink":"http://example.com/2023/04/18/vuex3-4/","excerpt":"","text":"Vuex 是 Vue.js 的官方状态管理库，用于在 Vue.js 应用中管理应用状态。Vuex 3 是用于 Vue 2 的版本，而 Vuex 4 是用于 Vue 3 的版本。下面是 Vuex 3 和 Vuex 4 在一些重要方面的异同点： 创建 Store 的方式 Vuex 3：使用 new Vuex.Store() 创建 store 实例 import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; ​ Vue.use(Vuex) ​ const store = new Vuex.Store(&#123; // 配置项 &#125;) ​ export default store Vuex 4：使用 createStore 函数创建 store 实例 import &#123; createStore &#125; from &#39;vuex&#39; ​ const store = createStore(&#123; // 配置项 &#125;) ​ export default store Vuex 4 中使用 createStore 函数来创建 store 实例，而不是直接在 Vue 实例上挂载。 在组件中使用 Store Vuex 3：使用 this.$store 访问 store 实例，通过 this.$store.state 访问状态，通过 this.$store.commit() 进行提交 mutation，通过 this.$store.dispatch() 进行分发 action。 export default &#123; computed: &#123; count() &#123; return this.$store.state.count &#125; &#125;, methods: &#123; increment() &#123; this.$store.commit(&#39;increment&#39;) &#125;, incrementAsync() &#123; this.$store.dispatch(&#39;incrementAsync&#39;) &#125; &#125; &#125; Vuex 4：使用 useStore 函数来获取 store 实例，通过 store.state 访问状态，通过 store.commit() 进行提交 mutation，通过 store.dispatch() 进行分发 action。 import &#123; useStore &#125; from &#39;vuex&#39; ​ export default &#123; setup() &#123; const store = useStore() const count = computed(() =&gt; store.state.count) ​ const increment = () =&gt; &#123; store.commit(&#39;increment&#39;) &#125; ​ const incrementAsync = () =&gt; &#123; store.dispatch(&#39;incrementAsync&#39;) &#125; ​ return &#123; count, increment, incrementAsync &#125; &#125; &#125; 虽然 Vuex4 推荐使用更符合 Composition API 风格的 useStore() 来获取 store 实例。但是并没有移除 this.$store，但是在 &lt;template&gt; 和 Vue2 选项式写法中还是支持使用 $store 的。 辅助函数的用法 Vuex 3：使用 mapState、mapGetters、mapMutations 和 mapActions 辅助函数来进行映射，简化在组件中对 store 的访问。 import &#123; mapState, mapGetters, mapMutations, mapActions &#125; from &#39;vuex&#39; ​ export default &#123; computed: &#123; ...mapState([&#39;count&#39;]), ...mapGetters([&#39;doubleCount&#39;]), &#125;, methods: &#123; ...mapMutations([&#39;increment&#39;]), ...mapActions([&#39;incrementAsync&#39;]), &#125; &#125; Vuex 4：使用 Composition API 中的 computed 函数和普通的 JavaScript 函数来实现类似的功能。 import &#123; computed, useStore &#125; from &#39;vuex&#39; ​ export default &#123; setup() &#123; const store = useStore() ​ const count = computed(() =&gt; store.state.count) const doubleCount = computed(() =&gt; store.getters.doubleCount) ​ const increment = () =&gt; &#123; store.commit(&#39;increment&#39;) &#125; ​ const incrementAsync = () =&gt; &#123; store.dispatch(&#39;incrementAsync&#39;) &#125; ​ return &#123; count, doubleCount, increment, incrementAsync &#125; &#125; &#125; Vuex4 支持选项式写法的辅助函数，在使用时和 Vuex3 一模一样的。但是需要注意辅助函数不能在组合式写法 setup 中使用。 响应式的改进 Vuex 3：使用 Vue 2 的响应式系统 ( Object.defineProperty ) 进行状态的监听和更新。 Vuex 4：使用 Vue 3 的响应式系统 ( proxy ) 进行状态的监听和更新，可以利用 Composition API 中的 reactive 和 computed 函数进行更加灵活和高效的状态管理。 实质上这是 Vue2 和 Vue3 的区别，只是由于 Vue 2 匹配的 Vuex 3，Vue 3 匹配的 Vuex 4 的原因，严格来说不能算作 Vuex3 与 Vuex4 的不同。 Vuex4 支持多例模式Vuex 3 是单例模式的，即整个应用只能有一个全局的 Vuex Store 实例。而在 Vuex 4 中，你可以通过 useStore 函数在不同组件中创建多个独立的 Vuex Store 实例，从而支持多例模式。 以下是一个示例展示了如何在 Vuex 4 中使用 useStore 辅助函数创建多个独立的 Vuex Store 实例： &lt;template&gt; &lt;div&gt; &lt;p&gt;Counter 1: &#123;&#123; counter1 &#125;&#125;&lt;/p&gt; &lt;p&gt;Counter 2: &#123;&#123; counter2 &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;incrementCounter1&quot;&gt;Increment Counter 1&lt;/button&gt; &lt;button @click=&quot;incrementCounter2&quot;&gt;Increment Counter 2&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; ​ &lt;script&gt; import &#123; useStore &#125; from &#39;vuex&#39; ​ export default &#123; setup() &#123; // 使用 useStore 辅助函数创建 Vuex Store 实例 const store1 = useStore(&#39;store1&#39;) const store2 = useStore(&#39;store2&#39;) ​ // 通过 store1.state.count 获取第一个 Store 的状态 const count1 = store1.state.count // 通过 store2.state.count 获取第二个 Store 的状态 const count2 = store2.state.count ​ // 通过 store1.commit() 提交 mutations 到第一个 Store const incrementCounter1 = () =&gt; &#123; store1.commit(&#39;increment&#39;) &#125; ​ // 通过 store2.commit() 提交 mutations 到第二个 Store const incrementCounter2 = () =&gt; &#123; store2.commit(&#39;increment&#39;) &#125; ​ return &#123; count1, count2, incrementCounter1, incrementCounter2 &#125; &#125; &#125; &lt;/script&gt; 上述示例展示了如何在 Vue 组件中使用 useStore 辅助函数创建多个独立的 Vuex Store 实例，并通过这些实例分别访问和修改各自的状态和 mutations。这是 Vuex 4 相对于 Vuex 3 的一个重要的改进，使得 Vuex 在支持多例模式的场景下更加灵活和可扩展。 参考链接： Vuex 4 官方文档：https://vuex.vuejs.org/zh/ Vuex 3 官方文档：https://v3.vuex.vuejs.org/zh/","categories":[{"name":"vuex","slug":"vuex","permalink":"http://example.com/categories/vuex/"}],"tags":[{"name":"vuex","slug":"vuex","permalink":"http://example.com/tags/vuex/"}]},{"title":"[译] javascript 检测剪贴板中的内容类型","slug":"plate","date":"2023-04-14T03:01:42.000Z","updated":"2023-04-14T03:01:42.000Z","comments":true,"path":"2023/04/14/plate/","permalink":"http://example.com/2023/04/14/plate/","excerpt":"","text":"原文地址：Detect the Content Type in the Clipboard 2023.03.06 By David Walsh 用户的剪贴板是操作系统和应用程序之间的“万能收集器”。当你使用网页浏览器时，你可以选择文本并复制，也可以右键点击图像并选择“复制图像”。这让我想到开发人员如何检测剪贴板中的内容类型。 你可以使用 navigator.clipboard API 获取用户剪贴板的内容。由于剪贴板可能包含敏感数据，因此该 API 需要用户权限。你可以使用以下 JavaScript 代码获取使用剪贴板 API 的权限： 1234const result = await navigator.permissions.query(&#123;name: &quot;clipboard-write&quot;&#125;);if (result.state === &quot;granted&quot; || result.state === &quot;prompt&quot;) &#123; // 权限已授予&#125; 授予剪贴板权限后，你可以查询剪贴板以获取 ClipboardItem 实例，其中包含已复制的详细信息： 1234567const [item] = await navigator.clipboard.read();// 当文本被复制到剪贴板时...item.types // [&quot;text/plain&quot;]// 当从网站复制图像时...item.types // [&quot;text/html&quot;, &quot;image/png&quot;] 一旦你知道了剪贴板中的内容和MIME类型，就可以使用 readText() 获取剪贴板中的文本： 1const content = await navigator.clipboard.readText(); 对于图像，如果你有MIME类型和内容，你可以使用数据URI的 &lt;img&gt; 进行显示。了解用户剪贴板的内容对于展示他们复制的内容非常有帮助！","categories":[{"name":"外文翻译","slug":"外文翻译","permalink":"http://example.com/categories/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"手写 Vuex(三)","slug":"vuex3","date":"2023-04-13T03:01:42.000Z","updated":"2023-04-13T03:01:42.000Z","comments":true,"path":"2023/04/13/vuex3/","permalink":"http://example.com/2023/04/13/vuex3/","excerpt":"","text":"map 辅助函数是 Vuex 提供的一种方便的方式，用于将 Vuex 中的状态、getters、mutations 和 actions 映射到 Vue 组件中的本地状态、计算属性、方法和动作。 map 辅助函数使用方法 mapState(namespace?: string, map: Array&lt;string&gt; | Object&lt;string | function&gt;): Object 这里以 mapState 为例，简单看下 map 辅助函数的三种使用方法，如下： 123456789101112131415export default &#123; // ... computed: mapState(&#123; // 箭头函数可使代码更简练 count: state =&gt; state.count, // 传字符串参数 &#x27;count&#x27; 等同于 `state =&gt; state.count` countAlias: &#x27;count&#x27;, // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) &#123; return state.count + this.localCount &#125; &#125;)&#125; 如果不考虑 namespace，以数组为例，可以很简单的实现实现 mapState 方法： 123456789const mapState = args =&gt; &#123; let states = &#123;&#125; args.forEach(item =&gt; &#123; states[item] = function () &#123; return this.$store.state[item] &#125; &#125;) return states&#125; normalizeMap由于用户传入可能为数组或对象，首先需要格式化参数格式 12345function normalizeMap(map) &#123; return Array.isArray(map) ? map.map(key =&gt; (&#123; key, val: key &#125;)) : Object.keys(map).map(key =&gt; (&#123; key, val: map[key] &#125;))&#125; normalizeNamespace根据 namespace 配置，对开启命名空间的模块，拼接路径参数 1234567891011function normalizeNamespace(fn) &#123; return (namespace, map) =&gt; &#123; if (typeof namespace !== &#x27;string&#x27;) &#123; map = namespace namespace = &#x27;&#x27; &#125; else if (namespace.charAt(namespace.length - 1) !== &#x27;/&#x27;) &#123; namespace += &#x27;/&#x27; &#125; return fn(namespace, map) &#125;&#125; getModuleByNamespace获取 namespace 对应的 module 模块，注：这里可以参考 namespace 一节中的数据结构，就很容易理解 1234567function getModuleByNamespace(store, helper, namespace) &#123; const module = store._modulesNamespaceMap[namespace] if (!module) &#123; console.error(`[vuex] module namespace not found in $&#123;helper&#125;(): $&#123;namespace&#125;`) &#125; return module&#125; mapState12345678910111213141516171819202122232425262728export const mapState = normalizeNamespace((namespace, states) =&gt; &#123; const res = &#123;&#125; normalizeMap(states).forEach((&#123; key, val &#125;) =&gt; &#123; res[key] = function mappedState() &#123; // 根模块 state、getters let state = this.$store.state let getters = this.$store.getters if (namespace) &#123; // 通过 namespace 拿到相应的模块 const module = getModuleByNamespace(this.$store, &#x27;mapState&#x27;, namespace) if (!module) &#123; return &#125; // 子模块 state、getter state = module.state getters = module.getters &#125; // 如：以下场景的配置项，需要执行函数，得到最终结果在返回 // countPlusLocalState (state) &#123; // return state.count + this.localCount //&#125; return typeof val === &#x27;function&#x27; ? val.call(this, state, getters) : state[val] &#125; &#125;) return res&#125;) 同理可依次实现 mapGetters、mapMutations、mapActions 辅助函数 mapGetters123456789101112131415export const mapGetters = normalizeNamespace((namespace, getters) =&gt; &#123; const res = &#123;&#125; normalizeMap(getters).forEach((&#123; key, val &#125;) =&gt; &#123; // The namespace has been mutated by normalizeNamespace val = namespace + val res[key] = function mappedGetter() &#123; if (namespace &amp;&amp; !getModuleByNamespace(this.$store, &#x27;mapGetters&#x27;, namespace)) &#123; return &#125; return this.$store.getters[val] &#125; &#125;) return res&#125;) mapMutations12345678910111213141516171819202122export const mapMutations = normalizeNamespace((namespace, mutations) =&gt; &#123; const res = &#123;&#125; normalizeMap(mutations).forEach((&#123; key, val &#125;) =&gt; &#123; res[key] = function mappedMutation(...args) &#123; // Get the commit method from store let commit = this.$store.commit if (namespace) &#123; const module = getModuleByNamespace(this.$store, &#x27;mapMutations&#x27;, namespace) if (!module) &#123; return &#125; const _type = namespace + val commit = () =&gt; &#123; this.$store.commit(_type) &#125; &#125; return typeof val === &#x27;function&#x27; ? val.apply(this, [commit].concat(args)) : commit.apply(this.$store, [val].concat(args)) &#125; &#125;) return res&#125;) mapActions1234567891011121314151617181920212223export const mapActions = normalizeNamespace((namespace, actions) =&gt; &#123; const res = &#123;&#125; normalizeMap(actions).forEach((&#123; key, val &#125;) =&gt; &#123; res[key] = function mappedAction(...args) &#123; // get dispatch function from store let dispatch = this.$store.dispatch if (namespace) &#123; const module = getModuleByNamespace(this.$store, &#x27;mapActions&#x27;, namespace) if (!module) &#123; return &#125; const _type = namespace + val dispatch = () =&gt; &#123; return this.$store.dispatch(_type) &#125; &#125; return typeof val === &#x27;function&#x27; ? val.apply(this, [dispatch].concat(args)) : dispatch.apply(this.$store, [val].concat(args)) &#125; &#125;) return res&#125;) 至此，手写 Vuex 基础功能、模块化、命名空间、严格模式等已完结，以源码为例，实现了一个简易的Vuex3，帮助我们理解其原理，希望这篇文章对你有所帮助！更多详细信息请参考 vuex 源码。 完整代码系列文章 【造轮子系列】面试官问：你能手写Vuex吗(一) 【造轮子系列】面试官问：你能手写Vuex吗(二)","categories":[{"name":"vuex","slug":"vuex","permalink":"http://example.com/categories/vuex/"}],"tags":[{"name":"vuex 源码","slug":"vuex-源码","permalink":"http://example.com/tags/vuex-%E6%BA%90%E7%A0%81/"}]},{"title":"手写 Vuex(二)","slug":"vuex2","date":"2023-04-11T03:01:42.000Z","updated":"2023-04-11T03:01:42.000Z","comments":true,"path":"2023/04/11/vuex2/","permalink":"http://example.com/2023/04/11/vuex2/","excerpt":"","text":"书接上文：【造轮子系列】面试官问：你能手写Vuex吗(一)？ 中，实现了 Vuex 的基础功能，现在继续对其进行完善，实现模块化的状态管理。模块化可以帮助我们更好地组织和管理复杂的应用状态，使得状态的结构更加清晰和可维护。 格式化参数将参数模块格式化为模块嵌套的树形结构（如下），方便我们后续的操作。 1234567891011121314151617//根模块this.root = &#123; // 模块的配置：包含当前模块的 state、getters、mutations、actions _raw: xxx, _children: &#123; // 子模块 a模块: &#123; _raw: xxx, _children: &#123;&#125;, state: xxx.state &#125;, b模块: &#123; _raw: xxx, _children: &#123;&#125;, state: xxx.state &#125; &#125;, state: xxx.state&#125; Module 类创建 Module 类，通过 new Module 便可以得到格式化后的树形数据结构。 12345678// module.jsexport default class Module &#123; constructor(rootModule) &#123; this._raw = rootModule, this._children = &#123;&#125; this.state = rootModule.state &#125;&#125; ModuleCollection 类在这个类中，实现将用户传入的参数转化为格式化后的结果，代码如下： 12345678910111213141516171819202122232425262728// module-collection.jsimport forEachValue from &quot;./utils&quot;;import Module from &#x27;./module.js&#x27;export default class ModlueCollection &#123; constructor(options) &#123; // 注册模块 []表示路径 递归注册模块 this.register([], options) &#125; register(path, rootModule) &#123; const newModlue = new Module(rootModule) if (path.length == 0) &#123; // 根模块 this.root = newModlue &#125; else &#123; const parent = path.slice(0, -1).reduce((pre, next) =&gt; &#123; return pre.getChild(next) &#125;, this.root) parent.addChild(path[path.length - 1], newModlue) &#125; // 注册子模块 if (rootModule.modules) &#123; forEachValue(rootModule.modules, (moduleValue, moduleName) =&gt; &#123; // 递归 this.register([...path, moduleName], moduleValue) &#125;) &#125; &#125;&#125; forEachValue其中 forEachValue 方法提取为工具方法，方便后续复用 123456const forEachValue = (obj = &#123;&#125;, fn) =&gt; &#123; Object.keys(obj).forEach(key =&gt; &#123; fn(obj[key], key) &#125;)&#125;export default forEachValue getChild、addChild增加获取子模块和追加子模块方法，便于调用 123456789101112// module.jsexport default class Module &#123; ... // 获取子模块 getChild(key) &#123; return this._children[key] &#125; // 追加子模块 addChild(key, module) &#123; this._children[key] = module &#125;&#125; 至此完成模块格式化为模块嵌套的树形结构，接下来重构 Store，实现 state、getter、commit、dispatch等 installModuleinstallModlue方法：将创建的树形结构上的状态、方法安装到 Store 实例上，就可以通过$store方式获取到对应的数据。 12345678910111213141516171819202122232425import ModuleCollection from &#x27;./module-collection.js&#x27;import forEachValue from &#x27;./utils&#x27;let Vuefunction installModule(store, rootState, path, module) &#123; // 收集所有模块的状态 if (path.length &gt; 0) &#123; // 如果是子模块 就需要将子模块的状态定义到根模块上 let parent = path.slice(0, -1).reduce((pre, next) =&gt; &#123; return pre[next] &#125;, rootState) // 将属性设置为响应式 可以新增属性 Vue.set(parent, path[path.length - 1], module.state) &#125; module.forEachChild((child, key) =&gt; &#123; installModule(store, rootState, path.concat(key), child) &#125;)&#125;class Store &#123; constructor(options) &#123; this._modules = new ModuleCollection(options) // 注册所有模块到Store实例上 // this当前实例、根状态、路径、根模块 const state = this._modules.root.state installModule(this, state, [], this._modules.root) &#125;&#125; forEachChild遍历安装当前模块的子模块 12345678// module.jsexport default class Module &#123; ... // 遍历当前模块的child forEachChild(fn) &#123; forEachValue(this._children, fn) &#125;&#125; resetStoreVm实现 state 数据响应式响应式 123456789101112131415161718192021222324252627282930313233343536373839function resetStoreVm(store, state) &#123; const wrappedGetters = store._wrappedGetters const computed = &#123;&#125; store.getters = Object.create(null) // 通过使用vue的computed实现缓存 forEachValue(wrappedGetters, (fn, key) =&gt; &#123; computed[key] = () =&gt; &#123; return fn() &#125; // 代理 Object.defineProperty(store.getters, key, &#123; get: () =&gt; &#123; return store._vm[key] &#125; &#125;) &#125;) // 将状态实现响应式 store._vm = new Vue(&#123; data() &#123; return &#123; $$state: state &#125; &#125;, computed &#125;)&#125;class Store &#123; constructor(options) &#123; ... let state = this._modules.root.state ... //实现state响应式 resetStoreVm(this, state) &#125; get state() &#123; return this._vm._data.$$state &#125; ...&#125; forEachGetters扩展 Module 类，遍历 getters 1234567891011// module.jsexport default class Module &#123; ... // 遍历当前模块的getters forEachGetters(fn) &#123; if (this._raw.getters) &#123; forEachValue(this._raw.getters, fn) &#125; &#125;&#125; getter123456789101112131415161718function installModule(store, rootState, path, module) &#123; ... module.forEachGetters((getters, key) =&gt; &#123; // 同名计算属性会覆盖 所以不用存储 store._wrappedGetters[key] = () =&gt; &#123; return getters(module.state) &#125; &#125;) ...&#125;class Store &#123; constructor(options) &#123; ... this._wrappedGetters = Object.create(null) // 存放所有模块的getters ... &#125;&#125; commit（mutations）1234567891011121314151617181920212223242526function installModule(store, rootState, path, module) &#123; ... module.forEachMutations((mutations, type) =&gt; &#123; // 收集所有模块的mutations 存放到 实例的store._mutations上 // 同名的mutations和 actions 并不会覆盖 所以要有一个数组存储 &#123;changeAge: [fn,fn,fn]&#125; store._mutations[type] = (store._mutations[type] || []) store._mutations[type].push((payload) =&gt; &#123; // 函数包装 包装传参是灵活的 // 使this 永远指向实例 当前模块状态 入参数 mutations.call(store, module.state, payload) &#125;) &#125;) ...&#125;class Store &#123; constructor(options) &#123; ... this._mutations = Object.create(null) // 存放所有模块的mutation ... &#125; commit = (type, payload) =&gt; &#123; // 触发commit会触发_mutations里面的方法 this._mutations[type].forEach(fn =&gt; fn(payload)) &#125;&#125; forEachMutations1234567891011// module.jsexport default class Module &#123; ... // 遍历当前模块的mutations forEachMutations(fn) &#123; if (this._raw.mutations) &#123; forEachValue(this._raw.mutations, fn) &#125; &#125;&#125; dispatch（actions）1234567891011121314151617181920212223function installModule(store, rootState, path, module) &#123; ... module.forEachActions((actions, type) =&gt; &#123; store._actions[type] = (store._actions[type] || []) store._actions[type].push((payload) =&gt; &#123; actions.call(store, store, payload) &#125;) &#125;) ...&#125;class Store &#123; constructor(options) &#123; ... this._actions = Object.create(null) // 存放所有模块的actions ... &#125; // dispatch dispatch = (type, payload) =&gt; &#123; this._actions[type].forEach(fn =&gt; fn(payload)) &#125;&#125; forEachActions1234567891011// module.jsexport default class Module &#123; ... // 遍历当前模块的actions forEachActions(fn) &#123; if (this._raw.actions) &#123; forEachValue(this._raw.actions, fn) &#125; &#125;&#125; namespace默认情况下（或 namespace: false），模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。 如果想要模块具有更高的封装度和复用性，可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名 getNamespaced1234567891011121314// module-collection.jsexport default class ModlueCollection &#123; ... // 获取命名空间 getNamespaced(path) &#123; let root = this.root return path.reduce((pre, next)=&gt;&#123; // 获取子模块 查看是否有namespaced属性 root = root.getChild(next) // 拼接上有namespace属性的路径 return pre + (root.namespaced ? next + &#x27;/&#x27; :&#x27;&#x27;) &#125;, &#x27;&#x27;) &#125;&#125; 1234567// module.jsexport default class Module &#123; ... get namespaced () &#123; return this._raw.namespaced &#125;&#125; 添加 namespace12345678910111213141516171819202122232425function installModule(store, rootState, path, module) &#123; // 获取命名空间 const namespaced = store._modules.getNamespaced(path) module.forEachMutations((mutations, type) =&gt; &#123; // 添加 namespace store._mutations[namespaced + type] = (store._mutations[namespaced + type] || []) store._mutations[namespaced + type].push((payload) =&gt; &#123; mutations.call(store, module.state, payload) &#125;) &#125;) module.forEachActions((actions, type) =&gt; &#123; // 添加 namespace store._actions[namespaced + type] = (store._actions[namespaced + type] || []) store._actions[namespaced + type].push((payload) =&gt; &#123; actions.call(store, store, payload) &#125;) &#125;) module.forEachGetters((getters, key) =&gt; &#123; store._wrappedGetters[namespaced + key] = () =&gt; &#123; return getters(module.state) &#125; &#125;) ...&#125; 严格模式在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。 接收 strict 配置项，添加 mutation 提交状态标识123456789101112131415161718192021222324252627282930313233343536373839class Store &#123; constructor(options) &#123; ... // strict mode const &#123; strict = false &#125; = options this.strict = strict // 添加 committing 状态 this._committing = false //实现状态响应式 resetStoreVm(this, state) &#125; // 在 mutation 之前，设置 _committing = true, 调用 mutation 之后更改状态 // 如此当状态变化时，_committing 为 true，说明是同步更改，false 说明是非 mutation 提交 _withCommit = (fn) =&gt; &#123; var committing = this._committing; this._committing = true; fn(); this._committing = committing; &#125; // 修改 commit 方法，使用 _withCommit 调用 mutation commit = (type, payload) =&gt; &#123; if (!this._mutations[type]) &#123; throw new Error(`Mutation &quot;$&#123;type&#125;&quot; not found`); &#125; const entry = this._mutations[type] this._withCommit(() =&gt; &#123; entry.forEach((handler) =&gt; &#123; handler(payload) &#125;) &#125;) &#125;&#125;function resetStoreVm(store, state) &#123; ... // 如果开启了严格模式，则调用 enableStrictMode if (store.strict) &#123; enableStrictMode(store) &#125;&#125; enableStrictMode监听 state 数据变化，判断 _committing 如果是 true 表示是同步执行，如果为 false，则会抛出错误提示 12345function enableStrictMode(store) &#123; store._vm.$watch(function () &#123; return this._data.$$state &#125;, () =&gt; &#123; console.assert(store._committing, `[vuex] do not mutate vuex store state outside mutation handlers.`) &#125;, &#123; deep: true, sync: true &#125;)&#125; 以上只是基于vuex源码实现了最核心的功能，但它帮助我们更好地理解了 Vuex 的模块化的实现原理。本来计划在这篇中实现 map辅助函数，但发现模块化的写起来实在太多了，所以将 mapState、 mapGetters、 mapMutations、 mapActions 放到下篇讲解。希望这篇文章对你有所帮助！更多详细信息请参考 vuex 源码。 完整代码系列文章 【造轮子系列】面试官问：你能手写Vuex吗(一) 【造轮子系列】面试官问：你能手写Vuex吗(三)","categories":[{"name":"vuex","slug":"vuex","permalink":"http://example.com/categories/vuex/"}],"tags":[{"name":"vuex 源码","slug":"vuex-源码","permalink":"http://example.com/tags/vuex-%E6%BA%90%E7%A0%81/"}]},{"title":"手写 Vuex(一)","slug":"vuex1","date":"2023-04-10T03:01:42.000Z","updated":"2023-04-10T03:01:42.000Z","comments":true,"path":"2023/04/10/vuex1/","permalink":"http://example.com/2023/04/10/vuex1/","excerpt":"","text":"Vuex 是 Vue.js 的状态管理模式，它主要解决了组件之间共享状态时的问题。在本文中，我们将实现一个简单的状态管理器，来帮助我们更好地理解 Vuex 的实现原理。 使用 vue.use 启用 vuex 插件vue.use 是 vue 提供的安装插件 API。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象。 即需要导出 install 方法，同时导出一个类 Store ，于是可以写出以下代码： let Vue = null ​ class Store &#123; constructor(options) &#123;&#125; &#125; ​ function install(_Vue) &#123; Vue = _Vue &#125; ​ export default &#123; Store, install, &#125; 实现 install 方法function install(_Vue) &#123; Vue = _Vue // install 方法调用时，会将 Vue 作为参数传入 // 实现每一个组件，都能通过 this 调用 $store Vue.mixin(&#123; beforeCreate() &#123; // 通过 this.$options 可以获取 new Vue(&#123;参数&#125;) 传递的参数 if (this.$options &amp;&amp; this.$options.store) &#123; // vue的原型上挂载 store（ Store 的实例 ） this.$store = this.$options.store // 等同于 Vue.prototype.$store = this.$options.store &#125; &#125; &#125;) &#125; Store在 Vuex 中，Store 是一个对象，它是一个容器，用于存储和管理状态( state )，包含了以下几个主要部分： state：存储状态的数据，也就是全局要共享的数据。 getters：包含一些函数，用于对 state 进行计算操作。 mutations：包含一些函数，用于改变 state 的值。 actions：包含一些函数，用于处理异步操作或者一些逻辑处理。 state首先，我们需要定义一个存储对象，用于保存应用程序的所有状态。我们可以创建一个名为 Store 的类，并在其中定义一个状态对象。我们还可以将 state 对象定义为响应式的，以便在状态更改时通知 Vue 更新视图。这可以通过使用 Vue.observable 方法来实现 class Store &#123; constructor(options) &#123; const &#123; state = &#123;&#125; &#125; = options; // 使用 observable 响应化处理 this.state = Vue.observable(state); &#125; &#125; getter接下来，我们需要实现 getters，以便从状态中派生计算属性。我们将 getters 添加到 Store 类中： class Store &#123; constructor(options) &#123; const &#123; getters = &#123;&#125; &#125; = options; this.getters = &#123;&#125;; for (const [key, value] of Object.entries(getters)) &#123; Object.defineProperty(this.getters, key, &#123; get: () =&gt; value(this.state), &#125;); &#125; &#125; &#125; commit最后，我们需要实现 mutations 和 actions，以便更改状态和处理异步操作。mutations 是唯一可以更改状态的方法，而 actions 则是处理异步操作的地方，它们可以触发 mutations 来更改状态。我们将 mutations 和 actions 添加到 Store 类中： 在下面的代码中，我们添加了一个 commit 方法，它接受一个类型和有效载荷参数，并调用与类型匹配的 mutation 函数来更改状态。 class Store &#123; constructor(options) &#123; const &#123; mutations = &#123;&#125; &#125; = options; this.mutations = mutations; commit(type, payload) &#123; if (!this.mutations[type]) &#123; throw new Error(`Mutation &quot;$&#123;type&#125;&quot; not found`); &#125; this.mutations[type](this.state, payload); &#125; &#125; &#125; dispatch还需要添加了一个 dispatch 方法，它接受一个类型和有效载荷参数，并调用与类型匹配的 action 函数。注意，我们将 commit 和 state 作为参数传递给 action 函数，以便在需要更改状态时使用。 class Store &#123; constructor(options) &#123; const &#123; actions = &#123;&#125; &#125; = options; this.actions = actions; dispatch(type, payload) &#123; if (!this.actions[type]) &#123; throw new Error(`Action &quot;$&#123;type&#125;&quot; not found`); &#125; return this.actions[type](&#123; commit: this.commit, state: this.state &#125;, payload); &#125; &#125; &#125; 这个简单的状态管理器只是 Vuex 的一部分实现，但它帮助我们更好地理解了 Vuex 的概念和实现原理。你会发现还没有实现 map辅助函数、模块化以及严格模式等，后续将一步步完善，对比与 vuex4、pinia 的差异化等。希望这篇文章对你有所帮助！ 完整代码系列文章 【造轮子系列】面试官问：你能手写Vuex吗(二) 【造轮子系列】面试官问：你能手写Vuex吗(三)","categories":[{"name":"vuex","slug":"vuex","permalink":"http://example.com/categories/vuex/"}],"tags":[{"name":"vuex 源码","slug":"vuex-源码","permalink":"http://example.com/tags/vuex-%E6%BA%90%E7%A0%81/"}]},{"title":"[译] Volar: 一个新的开始","slug":"volar","date":"2023-04-06T04:00:00.000Z","updated":"2023-04-06T04:00:00.000Z","comments":true,"path":"2023/04/06/volar/","permalink":"http://example.com/2023/04/06/volar/","excerpt":"","text":"原文 https://blog.vuejs.org/posts/volar-a-new-beginning.html 大多数 Volar 用户都知道它是的 Vue.js 的 VSCode 扩展。它最初是一个个人项目，当时官方推荐的还是 Vetur ，随着时间的推移，由于改进的架构和性能而被采纳为新的官方扩展。 作为一个旨在改善开发人员开发质量的项目，我们花了两年多的时间才发布 1.0 版本，并且一直在不断改进稳定性。 但我们还有更多工作要做，2023 年有令人兴奋的计划。 Volar.js：嵌入式语言工具框架尽管最初是为 Vue 单文件组件的特定需求而设计的，但 Volar 的代码库包含许多不特定于 Vue 的部分，例如： 嵌入式编程语言的处理（多元框架的通病） Vue 语言服务器实际上是一个成熟的 TypeScript 语言服务器 处理与 LSP &#x2F; Web &#x2F; 嵌入式语言服务等交互的代码 我们现在已经将这些通用部分提取到一组与框架无关的工具中。这些工具现在作为一个新的独立项目进行维护：Volar.js。 Volar.js 的架构支持任何涉及嵌入式语言的文件格式——不仅是 Vue，还包括 Astro、Svelte，甚至 Angular。它还能够实现常规的单语言 LSP 服务器，例如 TypeScript、CSS 和 HTML。 Volar.js 的另一个主要关注点是性能。它旨在最大限度地减少实现本地嵌入式语言服务性能的开销。有许多问题和优化机会只能在相当大的用户基础上慢慢发现，而 Volar.js 的优化是基于我们从数百万次下载中积累的经验。 例如，字节跳动的 Lynx 团队是 Volar.js 的早期采用者，一个开发人员用两周的时间交付了一整套支持其内部框架的语言工具。如果从头开始构建，即使是一个团队，也需要几个月的时间。 旧的 Volar 现在是 vuejs&#x2F;language-tools提取核心后，原始 Volar 扩展的代码库vue-tsc已移至vuejs/language-tools存储库。这个 repo 现在依赖于 Volar.js 并包含 Vue 特定支持的代码。 我们还将把一些 npm 包从@volar npm 组织移到@vue- 但这些更改不应该影响最终用户。 团队与组织类似于 Vite 诞生于 Vue 生态系统，并最终发展成自己的社区，连接整个 Web 开发生态系统的用户，Volar.js 希望遵循同样的道路。 我 ( @johnsoncodehk ) 已经与Astro 核心团队成员Erika ( @erika )建立了 Volar.js 核心团队。Erika 与我一样，致力于改善人们的开发体验。我们将共同努力，为所有网络开发者改进 DX，而不仅仅是 Vue 和 Astro。 我们已经创建了 volarjs 组织来维护框架和相关的回购协议。 volar.js : 框架的核心 plugins : 可以在volar.config.js框架中或插件中使用 volarjs.github.io : 官方网站 language-tools-starter：开始使用 Volar.js 构建语言服务器的模板 ecosystem-ci：用于运行 volar 生态系统项目的集成测试 pug-language-tools : 基于 language-tools-starter 的 Pug 工具 angular-language-tools：基于 language-tools-starter 的 Angular 示例 svelte-language-tools：基于 language-tools-starter 的 Svelte 示例 此外，我很高兴地宣布： StackBlitz将全职支持我在 Volar.js 上工作！ 我们对未来感到兴奋，迫不及待地想看看在接下来的几个月里我们能取得什么成就！ 下一步我们才刚刚起步，所以我们还没有明确的长期路线图，但这里有一些我们计划接下来探索和努力的主要方向。 Monaco支持Monaco 对 Vue 的支持目前由 实现 monaco-volar 实现，我们计划在框架中支持它，因此所有基于 Volar.js 的语言服务器都可以轻松利用它。 支持 VSCode 以外的 IDE除了 VSCode 之外，许多慷慨的贡献者还为 Volar 实现了其他IDE的语言客户端，如 Vim、Sublime、Atom、Emacs、Nova、Lapce 。 拥有一整套的IDE支持可以有很大的参考价值，因为很少有人能够精通所有这些IDE。 我们将寻找方法来利用这些贡献者的努力来减少框架采用者在 VSCode 之外实现语言客户端的工作量。 此外，虽然 IntelliJ 没有一流的 LSP 支持，但我们将研究是否可以将其与框架集成。 Bun 基础语言服务器理论上，Volar 的性能只能无限接近，但不会快于 vanilla TS 语言服务器。但是，如果 Volar 语言服务器可以通过在 Bun 中运行来获得性能提升，它可能会改变游戏规则。 以前 Bun 的运行时还不兼容基于 Node.js 的 LSP 服务器。我们会持续关注相关问题，待问题解决后重试。 同样，所有基于 Volar.js 的语言服务器都将能够直接从中受益。 单体服务器想象这样一个场景，每一种语言都需要支持一些 TypeScript 特性，那么每一种语言的语言服务器都会运行自己昂贵的 TypeScript Language Service 实例，这让事情变得有点可怕，因为内存和 CPU 使用率都会成倍增加，而这种情况今天已经发生了。 如果这些语言服务器中的一些是基于 Volar.js 的，我们可能有一些方法让他们决定只激活一个语言服务器，然后将其余语言服务器的功能共享给激活的服务器，这样在最终我们只需要在一个语言服务器实例而不是多个语言服务器中运行 TypeScript 语言服务。 这也可以解决 TypeScript 插件无法支持的一些用例。 基于 Volar.js 架构，我们已经非常接近这个目标，我和 Erika 将为 Vue 和 Astro 语言服务器探索这个特性。 规则 API（内置 Linter）你可能在 ESLint 和 Prettier 一起使用时遇到各种问题，而我们过去基于 Plugin API 的尝试并没有很好地避免这个问题。 Rules API 是避免不同 linting 工具之间冲突的另一种尝试，同时也确保性能和特性与 IDE 完美集成。 对于元框架，他们需要为 ESLint 和 Prettier 实现自己的解析器，但是有了 Rules API，他们甚至不需要这样做，因为我们可以复用 Volar 语言服务器的解析器。 因此，如果您编写了一个 TS 规则，它将直接通过 Rules API 用于 Vue&lt;script&gt;和模板中的 TypeScript 代码，而无需额外的解析器。 这并不意味着您需要重写所有规则；Rules API 只是一个 API，而不是一个单独的 linter，因此仍然可以复用 ESLint、TSLint 甚至 Rome 中的一些规则。 脚本API对于 Vue 我们有vue-tsc检查 TS 代码，有时我们也想在 CI 中同时检查 CSS 和 Vue Template 代码。 Scripts API 旨在公开语言服务器的格式化和 linting 功能，以便它们可以在脚本中使用，允许您在 CI 或 git 预提交钩子中使用它并获得与在 IDE 中相同的结果。","categories":[{"name":"外文翻译","slug":"外文翻译","permalink":"http://example.com/categories/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"},{"name":"外文翻译","slug":"外文翻译","permalink":"http://example.com/tags/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/"},{"name":"Volar","slug":"Volar","permalink":"http://example.com/tags/Volar/"}]},{"title":"[译] TypeScript 5.0 发布","slug":"typescript","date":"2023-03-19T04:00:00.000Z","updated":"2023-03-19T04:00:00.000Z","comments":true,"path":"2023/03/19/typescript/","permalink":"http://example.com/2023/03/19/typescript/","excerpt":"","text":"原文地址：Announcing TypeScript 5.0 2023.3.16 by Daniel Rosenwasser and the TypeScript Team 今天，我们很高兴地宣布 TypeScript 5.0 的发布！ 此版本带来了许多新功能，同时旨在使 TypeScript 更小、更简单、更快。我们已经实施了新的装饰器标准，添加了更好地支持 Node 和 bundlers 中的 ESM 项目的功能，为库作者提供了控制泛型推理的新方法，扩展了我们的 JSDoc 功能，简化了配置，并进行了许多其他改进。 如果您还不熟悉 TypeScript，它是一种基于 JavaScript 的语言，通过添加类型语法来进行类型检查。类型检查可以帮助发现许多常见错误，从错别字到逻辑错误。将类型引入 JavaScript 还使我们能够构建出色的工具，因为类型可以在您喜欢的编辑器中支持代码补全、直接定义和重构等功能。事实上，如果您使用过 Visual Studio 或 VS Code 等编辑器，TypeScript 已经提供了 JavaScript 体验！您可以在 https://typescriptlang.org 上了解这门语言。 但是，如果您已经熟悉 TypeScript，也不用担心！5.0 不是破坏性版本，你所知道的一切仍然适用。虽然 TypeScript 5.0 包括正确性更改和一些不常用选项的弃用，但我们相信大多数开发人员都会有与以前版本类似的升级体验。 要开始使用 TypeScript 5.0，您可以通过 NuGet获取它，或者使用 npm 和下面的命令： 1npm install -D typescript 你也可以按照指示在 Visual Studio Code 中使用新版本的 TypeScript 的说明进行操作。 这是 TypeScript 5.0 中新功能的快速列表！ 装饰器 const 泛型参数 extends 支持多个配置文件 所有的枚举都是联合枚举 --moduleResolution 配置新增 bundler 支持 自定义解析标志 --verbatimModuleSyntax 支持 export type * JSDoc 支持 @satisfies JSDoc 支持 @overload 运行 tsc --build 可以传入的新指令 编辑器中不区分大小写的导入排序 switch&#x2F;case 语法补足 速度、内存和包大小优化 重大更改和弃用 下一步是什么？ 自 Beta 和 RC 以来有什么新功能？自 beta 版发布以来， TypeScript 5.0 有几个显著的变化。 自 TypeScript 5.0 Beta 以来，一个新区别是 TypeScript 允许将装饰器放置在 export 和 export default 之前或之后。这一变化反映了 TC39（ECMAScript&#x2F;JavaScript 的标准机构）内部的讨论和共识。 另一个是新的 bundler 模块解析选项只能在 --module 选项设置为 esnext 时使用。这样做是为了确保在输入文件中写入的 import 语句不会在捆绑器解析它们之前转换为 require 调用，无论捆绑器或加载器是否遵从 TypeScript 的 module 选项。我们还在这些发布说明中提供了一些上下文，建议大多数库作者坚持使用 node16 or nodenext。 虽然 TypeScript 5.0 Beta 附带了此功能，但我们没有记录我们在编辑器场景中支持不区分大小写的导入排序的工作。这部分是因为用于自定义的 UX 仍在讨论中，但默认情况下，TypeScript 现在应该可以更好地与您的其他工具一起使用。 自我们的 RC 以来，我们最显著的变化是 TypeScript 5.0 现在在 package.json 中指定了 Node.js 的最低版本为 12.20。 我们还发布了一篇关于 TypeScript 5.0 向 modules 迁移的文章，并提供了链接。 自 TypeScript 5.0 Beta 和 RC 发布以来，速度基准和包大小增量的具体数字也进行了调整，尽管噪音一直是运行过程中的一个因素。为了清晰起见，还对一些基准的名称进行了调整，包大小的改进也被移至单独的图表中。 装饰器装饰器是即将推出的 ECMAScript 功能，它允许我们以可重用的方式自定义类及其成员。 让我们思考以下代码： 12345678910111213class Person &#123; name: string; constructor(name: string) &#123; this.name = name; &#125;​ greet() &#123; console.log(`Hello, my name is $&#123;this.name&#125;.`); &#125;&#125;​const p = new Person(&quot;Ron&quot;);p.greet(); greet 这里很简单，但让我们想象它更复杂——也许它执行一些异步逻辑，它是递归的，它有副作用等等。不管你想象的是哪种场景，假设你抛出了一些 console.log 调用来帮助调试 greet。 1234567891011121314class Person &#123; name: string; constructor(name: string) &#123; this.name = name; &#125;​ greet() &#123; console.log(&quot;LOG: Entering method.&quot;);​ console.log(`Hello, my name is $&#123;this.name&#125;.`);​ console.log(&quot;LOG: Exiting method.&quot;) &#125;&#125; 这种模式相当普遍。如果有一种方法我们可以为每种方法做到这一点，那就太好了！ 这就是装饰器的用武之地。我们可以编写一个 loggedMethod 的函数，如下所示： 1234567891011function loggedMethod(originalMethod: any, _context: any) &#123;​ function replacementMethod(this: any, ...args: any[]) &#123; console.log(&quot;LOG: Entering method.&quot;) const result = originalMethod.call(this, ...args); console.log(&quot;LOG: Exiting method.&quot;) return result; &#125;​ return replacementMethod;&#125; “这些 any 都是怎么回事？这是什么，anyScript！？” 请耐心等待——我们暂时保持简单，以便我们可以专注于此函数在做什么。请注意，loggedMethod 接收原始方法 ( originalMethod) 并返回一个函数 输出“Entering…”日志 this 将其所有参数传递给原始方法 输出一条“Exiting…”日志，并且 返回原始方法返回的任何内容。 现在我们可以使用 loggedMethod 来装饰方法 greet ： 1234567891011121314151617181920class Person &#123; name: string; constructor(name: string) &#123; this.name = name; &#125;​ @loggedMethod greet() &#123; console.log(`Hello, my name is $&#123;this.name&#125;.`); &#125;&#125;​const p = new Person(&quot;Ron&quot;);p.greet();​// Output://// LOG: Entering method.// Hello, my name is Ron.// LOG: Exiting method. 我们只是在 greet 上面使用了 loggedMethod 作为装饰器 ——注意我们把它写成了 @loggedMethod。当我们这样做时，它会被 target 方法和 context 对象调用。因为 loggedMethod 返回了一个新函数，该函数替换了greet. 我们还没有提到它，而是 loggedMethod 用第二个参数定义的。它被称为“上下文对象”，它有一些关于如何声明修饰方法的有用信息——比如它是 #private 成员还是静态成员，或者方法的名称是什么。让我们重写 loggedMethod 以利用它并打印出被装饰的方法的名称。 123456789101112function loggedMethod(originalMethod: any, context: ClassMethodDecoratorContext) &#123; const methodName = String(context.name);​ function replacementMethod(this: any, ...args: any[]) &#123; console.log(`LOG: Entering method &#x27;$&#123;methodName&#125;&#x27;.`) const result = originalMethod.call(this, ...args); console.log(`LOG: Exiting method &#x27;$&#123;methodName&#125;&#x27;.`) return result; &#125;​ return replacementMethod;&#125; 我们现在使用 context 参数——它是 loggedMethod 中第一个具有比 any 和 any[] 更严格的参数类型。TypeScript 提供了一个名为 ClassMethodDecoratorContext 的类型，他对方法装饰器所接收的上下文对象进行建模。 除了元数据之外，方法的上下文对象还有一个有用的函数，称为 addInitializer。 这是一种挂钩到构造函数开头的方法（如果我们使用static，则挂钩到类本身的初始化）。 例如——在 JavaScript 中，通常会编写类似以下模式的内容： 123456789101112class Person &#123; name: string; constructor(name: string) &#123; this.name = name;​ this.greet = this.greet.bind(this); &#125;​ greet() &#123; console.log(`Hello, my name is $&#123;this.name&#125;.`); &#125;&#125; 或者，greet 可以声明为初始化为箭头函数的属性。 12345678910class Person &#123; name: string; constructor(name: string) &#123; this.name = name; &#125;​ greet = () =&gt; &#123; console.log(`Hello, my name is $&#123;this.name&#125;.`); &#125;;&#125; 编写此代码是为了确保在 greet 作为独立函数调用或作为回调传递 this 时不会重新绑定。 1234const greet = new Person(&quot;Ron&quot;).greet;​// We don&#x27;t want this to fail!greet(); 我们可以编写一个装饰器，使用 addInitializer 在构造函数中调用 bind 。 123456789function bound(originalMethod: any, context: ClassMethodDecoratorContext) &#123; const methodName = context.name; if (context.private) &#123; throw new Error(`&#x27;bound&#x27; cannot decorate private properties like $&#123;methodName as string&#125;.`); &#125; context.addInitializer(function () &#123; this[methodName] = this[methodName].bind(this); &#125;);&#125; bound 不返回任何东西——所以当它装饰一个方法时，它会保留原来的方法。相反，它将在任何其他字段初始化之前添加逻辑。 123456789101112131415161718class Person &#123; name: string; constructor(name: string) &#123; this.name = name; &#125;​ @bound @loggedMethod greet() &#123; console.log(`Hello, my name is $&#123;this.name&#125;.`); &#125;&#125;​const p = new Person(&quot;Ron&quot;);const greet = p.greet;​// Works!greet(); 请注意，我们堆叠了两个装饰器—— @bound 和 @loggedMethod。这些装饰以“相反的顺序”运行。即 @loggedMethod 装饰原始方法 greet，@bound 装饰 @loggedMethod 的结果 。在此示例中，这并不重要——但如果您的装饰器有副作用或期望特定顺序，则可能会发生这种情况。 同样值得注意的是：根据你喜欢代码风格，可以将这些装饰器放在同一行。 123@bound @loggedMethod greet() &#123; console.log(`Hello, my name is $&#123;this.name&#125;.`);&#125; 可能不太明显的是，我们甚至可以创建返回装饰器函数的函数。这使得定制最终的装饰器成为可能。如果我们愿意，我们可以让 loggedMethod 返回一个装饰器并自定义它记录消息的方式。 1234567891011121314function loggedMethod(headMessage = &quot;LOG:&quot;) &#123; return function actualDecorator(originalMethod: any, context: ClassMethodDecoratorContext) &#123; const methodName = String(context.name);​ function replacementMethod(this: any, ...args: any[]) &#123; console.log(`$&#123;headMessage&#125; Entering method &#x27;$&#123;methodName&#125;&#x27;.`) const result = originalMethod.call(this, ...args); console.log(`$&#123;headMessage&#125; Exiting method &#x27;$&#123;methodName&#125;&#x27;.`) return result; &#125;​ return replacementMethod; &#125;&#125; 如果我们这样做，我们必须在使用 loggedMethod 作为装饰器之前调用它。然后我们可以传入任何字符串作为输出到控制台的日志的前缀。 1234567891011121314151617181920class Person &#123; name: string; constructor(name: string) &#123; this.name = name; &#125;​ @loggedMethod(&quot;&quot;) greet() &#123; console.log(`Hello, my name is $&#123;this.name&#125;.`); &#125;&#125;​const p = new Person(&quot;Ron&quot;);p.greet();​// Output://// Entering method &#x27;greet&#x27;.// Hello, my name is Ron.// Exiting method &#x27;greet&#x27;. 装饰器不仅仅可以用在方法上！它们可用于属性&#x2F;字段、getter、setter 和自动访问器。甚至类本身也可以为子类化和注册之类的事情进行装饰。 要深入了解有关装饰器的更多信息，您可以阅读 Axel Rauschmayer 的详尽摘要。 有关涉及的更改的更多信息，您可以查看原始 pull request。 与实验性遗留装饰器的差异如果您已经使用 TypeScript 一段时间，您可能会意识到它多年来一直支持“实验性”装饰器。虽然这些实验性装饰器非常有用，但它们模拟了一个更旧版本的装饰器提案，并且始终需要一个名为 --experimentalDecorators。 任何在没有此标志的情况下尝试在 TypeScript 中使用装饰器都会提示错误消息。 --experimentalDecorators 在可预见的未来将继续存在；然而，如果没有这个标志，装饰器现在将成为所有新代码的有效语法。在之外--experimentalDecorators，它们将以不同方式进行类型检查和释放。类型检查规则和 emit 完全不同，虽然可以编写装饰器来支持旧的和新的装饰器行为，但任何现有的装饰器函数都不太可能这样做。 这个新的装饰器提案与 --emitDecoratorMetadata 不兼容，它不允许装饰参数。未来的 ECMAScript 提案可能会帮助弥合这一差距。 最后一点：除了允许将装饰器放在 export 关键字之前，装饰器提案现在还提供了在 export 或 export default 之后放置装饰器的选项。唯一的例外是不允许混合使用这两种样式。 1234567891011121314// allowed@register export default class Foo &#123; // ...&#125;​// also allowedexport default @register class Bar &#123; // ...&#125;​// error - before *and* after is not allowed@before export @after class Bar &#123; // ...&#125; 编写类型良好的装饰器上面的 loggedMethod 和 bound 装饰器示例有意简单化并省略了很多关于类型的细节。 键入装饰器可能相当复杂。例如，上面的类型正确的版本 loggedMethod 可能看起来像这样： 123456789101112131415function loggedMethod&lt;This, Args extends any[], Return&gt;( target: (this: This, ...args: Args) =&gt; Return, context: ClassMethodDecoratorContext&lt;This, (this: This, ...args: Args) =&gt; Return&gt;) &#123; const methodName = String(context.name);​ function replacementMethod(this: This, ...args: Args): Return &#123; console.log(`LOG: Entering method &#x27;$&#123;methodName&#125;&#x27;.`) const result = target.call(this, ...args); console.log(`LOG: Exiting method &#x27;$&#123;methodName&#125;&#x27;.`) return result; &#125;​ return replacementMethod;&#125; 我们必须使用类型参数 This、Args 和 Return 分别定义 this 的类型、参数和原始方法的返回类型。 装饰器函数定义的具体复杂程度取决于您要保证的内容。请记住，您的装饰器将被使用的次数多于它们被编写的次数，因此类型良好的版本通常更可取——但显然需要与可读性进行权衡，因此请尽量保持简单。 将来会提供更多关于编写装饰器的文档——但这篇文章应该有大量关于装饰器机制的细节。 const 泛型参数在推断对象的类型时，TypeScript 通常会选择一种通用的类型。例如，在本例中，names 的推断类型是 string[] ： 1234567type HasNames = &#123; readonly names: string[] &#125;;function getNamesExactly&lt;T extends HasNames&gt;(arg: T): T[&quot;names&quot;] &#123; return arg.names;&#125;​// Inferred type: string[]const names = getNamesExactly(&#123; names: [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;]&#125;); 通常这样做的目的是使突变成为可能。 但是，根据 getNamesExactly 的具体功能和用途，通常需要更具体的类型。 到目前为止，API 作者通常不得不建在某些地方添加 as const 以实现所需的推理： 123456789// The type we wanted:// readonly [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;]// The type we got:// string[]const names1 = getNamesExactly(&#123; names: [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;]&#125;);​// Correctly gets what we wanted:// readonly [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;]const names2 = getNamesExactly(&#123; names: [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;]&#125; as const); 这可能很麻烦且容易忘记。在 TypeScript 5.0 中，您现在可以将 const 修饰符添加到类型参数声明中，以使const-like 推理成为默认值： 123456789type HasNames = &#123; names: readonly string[] &#125;;function getNamesExactly&lt;const T extends HasNames&gt;(arg: T): T[&quot;names&quot;] &#123;// ^^^^^ return arg.names;&#125;​// Inferred type: readonly [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;]// Note: Didn&#x27;t need to write &#x27;as const&#x27; hereconst names = getNamesExactly(&#123; names: [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;] &#125;); 请注意，const 修饰符不拒绝可变值，也不需要不可变约束。使用可变类型约束可能会产生令人惊讶的结果。例如： 1234declare function fnBad&lt;const T extends string[]&gt;(args: T): void;​// &#x27;T&#x27; is still &#x27;string[]&#x27; since &#x27;readonly [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#x27; is not assignable to &#x27;string[]&#x27;fnBad([&quot;a&quot;, &quot;b&quot; ,&quot;c&quot;]); 在这里，推断的候选项 T 是 readonly [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]，并且 readonly 不能在需要可变数组的地方使用数组。在这种情况下，推理回退到约束条件，数组被视为 string[]，并且调用仍然成功进行。 此函数的更好定义应该使用 readonly string[]： 1234declare function fnGood&lt;const T extends readonly string[]&gt;(args: T): void;​// T is readonly [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]fnGood([&quot;a&quot;, &quot;b&quot; ,&quot;c&quot;]); 同样，请记住修饰符 const 仅影响在调用中编写的对象、数组和原始表达式的推断，因此不会（或不能）修改的参数不会看到 as const 任何行为变化: 12345declare function fnGood&lt;const T extends readonly string[]&gt;(args: T): void;const arr = [&quot;a&quot;, &quot;b&quot; ,&quot;c&quot;];​// &#x27;T&#x27; is still &#x27;string[]&#x27;-- the &#x27;const&#x27; modifier has no effect herefnGood(arr); 有关更多详细信息，请参阅拉取请求和（第一个和第二个）激励问题。 extends 支持多个配置文件tsconfig.json 管理多个项目时，拥有一个其他文件可以扩展的“基本”配置文件会很有帮助。这就是为什么 TypeScript 支持 extends从 compilerOptions. 12345678// packages/front-end/src/tsconfig.json&#123; &quot;extends&quot;: &quot;../../../tsconfig.base.json&quot;, &quot;compilerOptions&quot;: &#123; &quot;outDir&quot;: &quot;../lib&quot;, // ... &#125;&#125; 但是，在某些情况下，您可能希望从多个配置文件进行扩展。例如，假设使用发送到 npm 的 TypeScript 基本配置文件。如果您希望所有项目也使用 npm 包中的选项 @tsconfig/strictest，那么有一个简单的解决方案：扩展 tsconfig.base.json 自@tsconfig/strictest： 1234567// tsconfig.base.json&#123; &quot;extends&quot;: &quot;@tsconfig/strictest/tsconfig.json&quot;, &quot;compilerOptions&quot;: &#123; // ... &#125;&#125; 这在一定程度上起作用。如果您有任何项目不想使用 @tsconfig/strictest，他们必须手动禁用这些选项，或者创建一个短度的 tsconfig.base.json 版本，该版本不扩展 @tsconfig/strictest 为了在此处提供更多灵活性，Typescript 5.0 现在允许该 extends 字段采用多个条目。例如，在这个配置文件中： 123456&#123; &quot;extends&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;compilerOptions&quot;: &#123; // ... &#125;&#125; 写这个有点像 c 直接扩展，其中 c extends b 和 b extends a。如果任何字段“冲突”，则后一个条目获胜。 所以在下面的例子中， 和 strictNullChecks 都 noImplicitAny在最终的 tsconfig.json. 12345678910111213141516171819// tsconfig1.json&#123; &quot;compilerOptions&quot;: &#123; &quot;strictNullChecks&quot;: true &#125;&#125;​// tsconfig2.json&#123; &quot;compilerOptions&quot;: &#123; &quot;noImplicitAny&quot;: true &#125;&#125;​// tsconfig.json&#123; &quot;extends&quot;: [&quot;./tsconfig1.json&quot;, &quot;./tsconfig2.json&quot;], &quot;files&quot;: [&quot;./index.ts&quot;]&#125; 再举一个例子，我们可以用下面的方式重写我们原来的例子。 12345678// packages/front-end/src/tsconfig.json&#123; &quot;extends&quot;: [&quot;@tsconfig/strictest/tsconfig.json&quot;, &quot;../../../tsconfig.base.json&quot;], &quot;compilerOptions&quot;: &#123; &quot;outDir&quot;: &quot;../lib&quot;, // ... &#125;&#125; 有关更多详细信息，请阅读有关原始拉取请求的更多信息。 所有枚举都是联合枚举当 TypeScript 最初引入枚举时，它们只不过是一组具有相同类型的数字常量。 1234enum E &#123; Foo = 10, Bar = 20,&#125; E.Foo 和 E.Bar 的唯一特别之处在于它们可以赋值给除 E 类型之外的任何类型。除此之外，他们几乎只是 numbers。 1234function takeValue(e: E) &#123;&#125;​takeValue(E.Foo); // workstakeValue(123); // error! 直到 TypeScript 2.0 引入了枚举文字类型，枚举才变得更加特殊。枚举文字类型为每个枚举成员提供了自己的类型，并将枚举本身变成了每个成员类型的联合。它们还允许我们仅引用枚举类型的一个子集，并缩小这些类型的范围。 123456789101112131415// Color is like a union of Red | Orange | Yellow | Green | Blue | Violetenum Color &#123; Red, Orange, Yellow, Green, Blue, /* Indigo */, Violet&#125;​// Each enum member has its own type that we can refer to!type PrimaryColor = Color.Red | Color.Green | Color.Blue;​function isPrimaryColor(c: Color): c is PrimaryColor &#123; // Narrowing literal types can catch bugs. // TypeScript will error here because // we&#x27;ll end up comparing &#x27;Color.Red&#x27; to &#x27;Color.Green&#x27;. // We meant to use ||, but accidentally wrote &amp;&amp;. return c === Color.Red &amp;&amp; c === Color.Green &amp;&amp; c === Color.Blue;&#125; 为每个枚举成员赋予其自己的类型的一个问题是，这些类型在某些部分与成员的实际值相关联。在某些情况下，无法计算该值——例如，枚举成员可以通过函数调用进行初始化。 123enum E &#123; Blah = Math.random()&#125; 每当 TypeScript 遇到这些问题时，它都会悄悄退出并使用旧的枚举策略。这意味着放弃联合和文字类型的所有优势。 TypeScript 5.0 通过为每个计算成员创建唯一类型，设法将所有枚举变成联合枚举。这意味着现在可以缩小所有枚举的范围，并将其成员也作为类型引用。 有关此更改的更多详细信息，您可以阅读 GitHub 上的详细信息。 --moduleResolution 新增 bundler 支持TypeScript 4.7 在 --module 和 --moduleResolution 设置中引入了 node16 和 nodenext 选项。这些选项的目的是更好地模拟 Node.js 中 ECMAScript 模块的精确查找规则；然而，这种模式有很多限制，其他工具并没有真正强制执行。 例如，在 Node.js 的 ECMAScript 模块中，任何相对导入都需要包含文件扩展名。 1234// entry.mjsimport * as utils from &quot;./utils&quot;; // wrong - we need to include the file extension.​import * as utils from &quot;./utils.mjs&quot;; // works 在 Node.js 和浏览器中这样做有一定的原因——它使文件查找更快，并且更适合原始文件服务器。但是对于许多使用捆绑器等工具的开发人员来说，node16&#x2F;nodenext设置很麻烦，因为捆绑器没有这些限制中的大部分。在某些方面，node解析模式对任何使用捆绑器的人来说都更好。 但在某些方面，原有的 node 解决模式已经落伍了。大多数现代捆绑器在 Node.js 中使用 ECMAScript 模块和 CommonJS 查找规则的融合。例如，无扩展名的导入就像在 CommonJS 中一样工作得很好，但是在查看包的 export条件时，他们会更喜欢 ECMAScript 文件中的 import 条件。 为了模拟打包器的工作方式，TypeScript 现在引入了一种新策略：--moduleResolution bundler。 123456&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;esnext&quot;, &quot;moduleResolution&quot;: &quot;bundler&quot; &#125;&#125; 如果您正在使用像 Vite、esbuild、swc、Webpack、Parcel 和其他实施混合查找策略的现代捆绑器，那么新选项 bundler 应该非常适合您。 另一方面，如果您正在编写一个打算在 npm 上发布的库，则使用该 bundler 选项可以隐藏兼容性问题，这些问题可能会出现在您不使用捆绑器的用户身上。因此，在这些情况下，使用 node16 或 nodenext 解决方案可能是更好的途径。 要了解更多信息 --moduleResolution bundler，请查看实施拉取请求。 自定义解析标志JavaScript 工具现在可以模拟“混合”解析规则，就像 bundler 我们上面描述的模式一样。由于工具的支持可能略有不同，TypeScript 5.0 提供了启用或禁用一些功能的方法，这些功能可能适用于您的配置，也可能不适用于您的配置。 allowImportingTsExtensions--allowImportingTsExtensions 允许使用特定于 TypeScript 的扩展名（如.ts、.mts或.tsx）。 此标志仅在 --noEmit 或 --emitDeclarationOnly 启用时才被允许，因为这些导入路径在运行时无法在 JavaScript 输出文件中解析。这里的期望是您的解析器（例如您的捆绑器、运行时或其他一些工具）将使这些 .ts 文件之间的导入工作。 resolvePackageJsonExports--resolvePackageJsonExports 强制 TypeScript 解析 package.json的 exports 字段，如果曾经从 node_modules 中的读取过json文件。 当配置项 --modulerresolve 为 node16、nodenext 和 bundler 时，该选项默认为true。 resolvePackageJsonImports--resolvePackageJsonImports 强制 TypeScript 在从其祖先目录包含 package.json 的文件执行以 # 开头的查找时查询 package.json 文件的导入字段。 当配置项 --modulerresolve 为 node16、nodenext 和 bundler 时，该选项默认为true。 allowArbitraryExtensions在 TypeScript 5.0 中，当导入路径以不是已知 JavaScript 或 TypeScript 文件扩展名的扩展名结尾时，编译器将以 &#123;file basename&#125;.d.&#123;extension&#125;.ts。 例如，如果您在捆绑项目中使用 CSS 加载器，您可能希望为这些样式表编写（或生成）声明文件： 12345678910111213/* app.css */.cookie-banner &#123; display: none;&#125;// app.d.css.tsdeclare const css: &#123; cookieBanner: string;&#125;;export default css;// App.tsximport styles from &quot;./app.css&quot;;​styles.cookieBanner; // string 默认情况下，此导入会引发错误，让您知道 TypeScript 不理解此文件类型，并且您的运行时可能不支持导入它。但是，如果您已配置运行时或捆绑程序来处理它，则可以使用新的 --allowArbitraryExtensions 编译器选项来抑制错误。 请注意，从历史上看，通过添加名为 app.css.d.ts 的声明文件而不是 app.d.css.ts ，通常可以达到类似的效果 ——然而，这只是通过 Node 对 CommonJS 的 require 解析规则起作用。严格来说，前者被解释为一个名为app.css.js 的 JavaScript 文件的声明文件 。因为相对文件导入需要在 Node 的 ESM 支持中包含扩展名，所以 TypeScript 会在我们的示例中 --moduleResolution node16 在或 nodenext 下的 ESM 文件中出错 。 有关更多信息，请阅读此功能的提案及其相应的拉取请求。 customConditions--customConditions 接收一个附加条件列表，当 TypeScript 从 package.json的 exports 或 imports 字段解析时，这些条件将添加到解析器默认使用的任何现有条件中。 例如，当在 tsconfig.json 中设置此字段时： 1234567&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;es2022&quot;, &quot;moduleResolution&quot;: &quot;bundler&quot;, &quot;customConditions&quot;: [&quot;my-condition&quot;] &#125;&#125; 任何时候在 package.json 中引用 exports 或 imports 字段时，TypeScript 都会考虑调用 my-condition 的条件。 因此，当从具有以下内容的包中导入时 package.json 1234567891011&#123; // ... &quot;exports&quot;: &#123; &quot;.&quot;: &#123; &quot;my-condition&quot;: &quot;./foo.mjs&quot;, &quot;node&quot;: &quot;./bar.mjs&quot;, &quot;import&quot;: &quot;./baz.mjs&quot;, &quot;require&quot;: &quot;./biz.mjs&quot; &#125; &#125;&#125; TypeScript 将尝试查找与 foo.mjs 对应的文件。 该字段仅在 --moduleResolution 的 node16、nodenext 和 bundler 选项下有效 --verbatimModuleSyntax默认情况下，TypeScript 会做一些叫做 import elision 的事情。基本上，如果你写类似 12345import &#123; Car &#125; from &quot;./car&quot;;​export function drive(car: Car) &#123; // ...&#125; TypeScript 检测到您只对类型使用导入，所以输出结果会将此导入代码删除。您的输出 JavaScript 可能看起来像这样： 123export function drive(car) &#123; // ...&#125; 大多数时候这很好，因为如果 Car 不是从 ./car 导出的值，我们将收到运行时错误。 但它确实为某些边缘情况增加了一层复杂性。例如，请注意没有像这样的语句 import &quot;./car&quot;;——导入被完全删除。这实际上对有无副作用的模块产生影响。 TypeScript 针对 JavaScript 的 emit 策略还有另外几层复杂性——导入省略并不总是由导入的使用方式驱动——它通常还会参考值的声明方式。所以并不总是很清楚是否像下面这样的代码 1export &#123; Car &#125; from &quot;./car&quot;; 应该保留或丢弃。如果 Car 用 class 之类的东西声明，那么它可以保存在生成的 JavaScript 文件中。但如果 Car 仅声明为 type 别名或 interface，则 JavaScript 文件 Car 根本不应导出。 虽然 TypeScript 可能能够根据来自跨文件的信息做出这些发出决定，但并非每个编译器都可以。 imports 和 exports 的修饰符 type 对这些情况有点帮助。我们可以明确指出导入或导出是否仅用于类型分析，并且可以通过使用修饰符将其完全删除到 JavaScript 文件中 type。 123456// This statement can be dropped entirely in JS outputimport type * as car from &quot;./car&quot;;​// The named import/export &#x27;Car&#x27; can be dropped in JS outputimport &#123; type Car &#125; from &quot;./car&quot;;export &#123; type Car &#125; from &quot;./car&quot;; type 修饰符本身并不是很有用——默认情况下，模块省略仍然会删除导入，并且没有什么强制您区分 type 普通导入和导出。所以 TypeScript 有标志 --importsNotUsedAsValues 来确保你使用 type 修饰符，--preserveValueImports以防止某些模块省略行为，并 --isolatedModules 确保你的 TypeScript 代码适用于不同的编译器。不幸的是，很难理解这 3 个标志的细节，并且仍然存在一些具有意外行为的边缘情况。 --verbatimModuleSyntaxTypeScript 5.0 引入了一个名为简化情况的新选项。规则要简单得多——任何没有 type 修饰符的导入或导出都会被保留。任何使用 type 修饰符的东西都会被完全丢弃。 12345678// Erased away entirely.import type &#123; A &#125; from &quot;a&quot;;​// Rewritten to &#x27;import &#123; b &#125; from &quot;bcd&quot;;&#x27;import &#123; b, type c, type d &#125; from &quot;bcd&quot;;​// Rewritten to &#x27;import &#123;&#125; from &quot;xyz&quot;;&#x27;import &#123; type xyz &#125; from &quot;xyz&quot;; 有了这个新选项，所见即所得。 不过，当涉及到模块互操作时，这确实有一些影响。在此标志下，当您的设置或文件扩展名暗示不同的模块系统时，ECMAScript imports 和 exports 不会被重写为 require 调用。相反，你会得到一个错误。如果您需要发出使用 require 和 module.exports 的代码，则必须使用早于 ES2015 的 TypeScript 模块语法： 输入TypeScript 输出 JavaScript import foo = require(&quot;foo&quot;); const foo = require(&quot;foo&quot;); function foo() &#123;&#125; function bar() &#123;&#125; function baz() &#123;&#125; export = &#123; foo, bar, baz &#125;; function foo() &#123;&#125; function bar() &#123;&#125; function baz() &#123;&#125; module.exports = &#123; foo, bar, baz &#125;; 虽然这是一个限制，但它确实有助于使一些问题更加明显。例如，忘记在 package.json 中设置 type 字段 是很常见的。--module node16。因此，开发人员会在没有意识到的情况下开始编写 CommonJS 模块而不是 ES 模块，从而提供令人惊讶的查找规则和 JavaScript 输出。这个新标志确保您有意使用您正在使用的文件类型，因为语法是有意不同的。 因为 --verbatimModuleSyntax 提供了比 --importsNotUsedAsValues 和 --preserveValueImports 更一致的故事，所以这两个现有的标志已被弃用。 有关更多详细信息，请阅读原始拉取请求及其提案问题。 支持 export type *当 TypeScript 3.8 引入纯类型导入时，新语法不允许用于 export * from &quot;module&quot; 或 export * as ns from &quot;module&quot; 重新导出。TypeScript 5.0 添加了对这两种形式的支持： 1234567891011121314151617181920// models/vehicles.tsexport class Spaceship &#123; // ...&#125;​// models/index.tsexport type * as vehicles from &quot;./vehicles&quot;;​// main.tsimport &#123; vehicles &#125; from &quot;./models&quot;;​function takeASpaceship(s: vehicles.Spaceship) &#123; // ok - `vehicles` only used in a type position&#125;​function makeASpaceship() &#123; return new vehicles.Spaceship(); // ^^^^^^^^ // &#x27;vehicles&#x27; cannot be used as a value because it was exported using &#x27;export type&#x27;.&#125; 您可以在此处阅读有关实施的更多信息。 JSDoc 支持 @satisfiesTypeScript 4.9 引入了 satisfies 运算符。它确保表达式的类型兼容，而不影响类型本身。例如，让我们看下面的代码： 12345678910111213141516171819202122232425interface CompilerOptions &#123; strict?: boolean; outDir?: string; // ...&#125;​interface ConfigSettings &#123; compilerOptions?: CompilerOptions; extends?: string | string[]; // ...&#125;​let myConfigSettings = &#123; compilerOptions: &#123; strict: true, outDir: &quot;../lib&quot;, // ... &#125;,​ extends: [ &quot;@tsconfig/strictest/tsconfig.json&quot;, &quot;../../../tsconfig.base.json&quot; ],​&#125; satisfies ConfigSettings; 在这里，TypeScript 知道它 myConfigSettings.extends 是用数组声明的——因为在 satisfies 验证我们对象的类型时，它并没有直接将其更改为 ConfigSettings 并丢失信息。所以如果我们想映射过来 extends，那很好。 123declare function resolveConfig(configPath: string): CompilerOptions;​let inheritedConfigs = myConfigSettings.extends.map(resolveConfig); 这对 TypeScript 用户很有帮助，但是很多人使用 TypeScript 来使用 JSDoc 注释对他们的 JavaScript 代码进行类型检查。这就是为什么 TypeScript 5.0 支持一个名为 JSDoc 的新标签，@satisfies它做的事情完全一样。 /** @satisfies */ 可以捕获类型不匹配： 123456789101112131415// @ts-check​/** * @typedef CompilerOptions * @prop &#123;boolean&#125; [strict] * @prop &#123;string&#125; [outDir] */​/** * @satisfies &#123;CompilerOptions&#125; */let myCompilerOptions = &#123; outdir: &quot;../lib&quot;,// ~~~~~~ oops! we meant outDir&#125;; 但它会保留我们表达式的原始类型，允许我们稍后在代码中更精确地使用我们的值。 123456789101112131415161718192021222324252627282930// @ts-check​/** * @typedef CompilerOptions * @prop &#123;boolean&#125; [strict] * @prop &#123;string&#125; [outDir] */​/** * @typedef ConfigSettings * @prop &#123;CompilerOptions&#125; [compilerOptions] * @prop &#123;string | string[]&#125; [extends] */​​/** * @satisfies &#123;ConfigSettings&#125; */let myConfigSettings = &#123; compilerOptions: &#123; strict: true, outDir: &quot;../lib&quot;, &#125;, extends: [ &quot;@tsconfig/strictest/tsconfig.json&quot;, &quot;../../../tsconfig.base.json&quot; ],&#125;;​let inheritedConfigs = myConfigSettings.extends.map(resolveConfig); /** @satisfies */也可以在任何带括号的表达式上内联使用。我们可以 myConfigSettings这样写： 12345678910let myConfigSettings = /** @satisfies &#123;ConfigSettings&#125; */ (&#123; compilerOptions: &#123; strict: true, outDir: &quot;../lib&quot;, &#125;, extends: [ &quot;@tsconfig/strictest/tsconfig.json&quot;, &quot;../../../tsconfig.base.json&quot; ],&#125;); 为什么？好吧，当您更深入地了解其他一些代码（例如函数调用）时，它通常更有意义。 123compileCode(/** @satisfies &#123;ConfigSettings&#125; */ (&#123; // ...&#125;)); 此功能由Oleksandr Tarasiuk提供！ JSDoc 支持 @overload在 TypeScript 中，您可以为函数指定重载。重载为我们提供了一种方式，可以用不同的参数调用一个函数，并可能返回不同的结果。他们可以限制调用者实际使用我们函数的方式，并优化他们将返回的结果。 123456789101112131415// Our overloads:function printValue(str: string): void;function printValue(num: number, maxFractionDigits?: number): void;​// Our implementation:function printValue(value: string | number, maximumFractionDigits?: number) &#123; if (typeof value === &quot;number&quot;) &#123; const formatter = Intl.NumberFormat(&quot;en-US&quot;, &#123; maximumFractionDigits, &#125;); value = formatter.format(value); &#125;​ console.log(value);&#125; 在这里，我们说过 printValue 将 string或 number 作为其第一个参数。如果它需要一个 number，它可以使用第二个参数来确定我们可以打印多少个小数位。 TypeScript 5.0 现在允许 JSDoc 使用新标签声明重载 @overload。每个带有标记的 JSDoc 注释都 @overload 被视为以下函数声明的不同重载。 1234567891011121314151617181920212223242526272829// @ts-check​/** * @overload * @param &#123;string&#125; value * @return &#123;void&#125; */​/** * @overload * @param &#123;number&#125; value * @param &#123;number&#125; [maximumFractionDigits] * @return &#123;void&#125; */​/** * @param &#123;string | number&#125; value * @param &#123;number&#125; [maximumFractionDigits] */function printValue(value, maximumFractionDigits) &#123; if (typeof value === &quot;number&quot;) &#123; const formatter = Intl.NumberFormat(&quot;en-US&quot;, &#123; maximumFractionDigits, &#125;); value = formatter.format(value); &#125;​ console.log(value);&#125; 现在，无论我们是在 TypeScript 还是 JavaScript 文件中编写，TypeScript 都可以让我们知道我们是否错误地调用了我们的函数。 123456// all allowedprintValue(&quot;hello!&quot;);printValue(123.45);printValue(123.45, 2);​printValue(&quot;hello!&quot;, 123); // error! 这个新标签的实现要归功于Tomasz Lenarcik。 在tsc --build 时可以传入的新指令TypeScript 现在允许在 --build 模式下传递以下指令 --declaration --emitDeclarationOnly --declarationMap --sourceMap --inlineSourceMap 这使得自定义构建的某些部分变得更加容易，您可能有不同的开发和生产构建。 例如，库的开发构建可能不需要生成声明文件，但生产构建需要。项目可以将声明发射配置为默认关闭，只需使用 1tsc --build -p ./my-project-dir 一旦在内循环中完成迭代，“生产”构建就可以传递指令 --declaration。 1tsc --build -p ./my-project-dir --declaration 有关此更改的更多信息，请参见此处。 编辑器中不区分大小写的导入排序在 Visual Studio 和 VS Code 等编辑器中，TypeScript 支持组织和排序导入和导出的体验。但是，对于列表何时“排序”，通常会有不同的解释。 例如，下面的导入列表是否排序？ 12345import &#123; Toggle, freeze, toBoolean,&#125; from &quot;./utils&quot;; 答案可能令人惊讶地是“视情况而定”。如果我们不关心区分大小写，那么这个列表显然没有排序。这封信 f 出现在 t 和之前 T。 但在大多数编程语言中，排序默认是比较字符串的字节值。JavaScript 比较字符串的方式意味着 &quot;Toggle&quot; 总是在前面 &quot;freeze&quot; ，因为根据 ASCII 字符编码，大写字母在小写字母之前。所以从这个角度来看，导入列表是排序的。 TypeScript 之前考虑对导入列表进行排序，因为它正在进行基本的区分大小写的排序。对于喜欢不区分大小写排序的开发人员，或者使用像 ESLint 这样默认需要不区分大小写排序的工具的开发人员来说，这可能是一个令人沮丧的地方。 TypeScript 现在默认检测区分大小写。这意味着 TypeScript 和 ESLint 等工具通常不会就如何最好地对导入进行排序而相互“争吵”。 我们的团队也一直在试验进一步的排序策略，您可以在此处阅读有关内容。这些选项最终可能由编辑器配置。目前，它们仍然不稳定且处于试验阶段，您现在可以通过使用 typescript.unstable JSON 选项中的条目在 VS Code 中选择加入它们。以下是您可以尝试的所有选项（设置为默认值）： 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; &quot;typescript.unstable&quot;: &#123; // Should sorting be case-sensitive? Can be: // - true // - false // - &quot;auto&quot; (auto-detect) &quot;organizeImportsIgnoreCase&quot;: &quot;auto&quot;,​ // Should sorting be &quot;ordinal&quot; and use code points or consider Unicode rules? Can be: // - &quot;ordinal&quot; // - &quot;unicode&quot; &quot;organizeImportsCollation&quot;: &quot;ordinal&quot;,​ // Under `&quot;organizeImportsCollation&quot;: &quot;unicode&quot;`, // what is the current locale? Can be: // - [any other locale code] // - &quot;auto&quot; (use the editor&#x27;s locale) &quot;organizeImportsLocale&quot;: &quot;en&quot;,​ // Under `&quot;organizeImportsCollation&quot;: &quot;unicode&quot;`, // should upper-case letters or lower-case letters come first? Can be: // - false (locale-specific) // - &quot;upper&quot; // - &quot;lower&quot; &quot;organizeImportsCaseFirst&quot;: false,​ // Under `&quot;organizeImportsCollation&quot;: &quot;unicode&quot;`, // do runs of numbers get compared numerically (i.e. &quot;a1&quot; &lt; &quot;a2&quot; &lt; &quot;a100&quot;)? Can be: // - true // - false &quot;organizeImportsNumericCollation&quot;: true,​ // Under `&quot;organizeImportsCollation&quot;: &quot;unicode&quot;`, // do letters with accent marks/diacritics get sorted distinctly // from their &quot;base&quot; letter (i.e. is é different from e)? Can be // - true // - false &quot;organizeImportsAccentCollation&quot;: true &#125;, &quot;javascript.unstable&quot;: &#123; // same options valid here... &#125;,&#125; 您可以阅读有关自动检测和指定不区分大小写的原始工作的更多详细信息，然后是更广泛的选项集。 switch&#x2F;case 语法补足在编写 switch 语句时，TypeScript 现在会检测被检查的值何时具有文字类型。如果是这样，它将提供一个完成每个未发现的脚手架 case。 您可以在 GitHub 上查看实施细节。 速度、内存和包大小优化TypeScript 5.0 在我们的代码结构、数据结构和算法实现中包含许多强大的变化。这些都意味着你的整个体验应该更快——不仅仅是运行 TypeScript，甚至安装它。 以下是我们相对于 TypeScript 4.9 在速度和大小方面取得的一些有趣的胜利。 设想 时间或大小相对于 TS 4.9 material-ui 构建时间 90% TypeScript 编译器启动时间 89% 编剧建造时间 88% TypeScript Compiler 自建时间 87% Outlook Web 构建时间 82% VS 代码构建时间 80% 打字稿 npm 包大小 59% 如何？有一些显着的改进，我们希望在未来提供更多细节。但我们不会让您等待那篇博文。 首先，我们最近将 TypeScript 从命名空间迁移到模块，使我们能够利用现代构建工具来执行范围提升等优化。使用此工具、重新审视我们的打包策略并删除一些已弃用的代码，已将 TypeScript 4.9 的 63.8 MB 包大小减少了约 26.4 MB。它还通过直接函数调用为我们带来了显着的加速。我们在这里整理了一份关于我们迁移到模块的详细文章。 TypeScript 还为编译器中的内部对象类型增加了更多的统一性，并且还精简了存储在其中一些对象类型上的数据。这减少了多态操作，同时平衡了因使我们的对象形状更统一而增加的内存使用量。 在将信息序列化为字符串时，我们还执行了一些缓存。类型显示可能作为错误报告、声明发出、代码完成等的一部分发生，最终可能会相当昂贵。TypeScript 现在缓存了一些常用的机制以在这些操作中重用。 我们做出的另一个改进解析器的显着变化是利用 var 偶尔回避使用 let 和 const 跨闭包的成本。这提高了我们的一些解析性能。 总的来说，我们预计大多数代码库应该会看到 TypeScript 5.0 的速度提升，并且始终能够重现 10% 到 20% 之间的胜利。当然，这将取决于硬件和代码库特性，但我们鼓励您今天就在您的代码库上尝试一下！ 有关详细信息，请参阅我们的一些显着优化： 迁移到模块 Node 单体化 Symbol 单体化 Identifier 缩小尺寸 Printer 缓存 限制使用 var 重大更改和弃用运行时要求TypeScript 现在以 ECMAScript 2018 为目标。TypeScript 包还设置了最低预期引擎 12.20。对于 Node 用户，这意味着 TypeScript 5.0 的最低版本要求至少为 Node.js 12.20 及更高版本。 lib.d.ts变化更改 DOM 类型的生成方式可能会对现有代码产生影响。值得注意的是，某些属性已从 number 数字文字类型转换为数字文字类型，并且用于剪切、复制和粘贴事件处理的属性和方法已跨界面移动。 API 重大变更在 TypeScript 5.0 中，我们转向了模块，删除了一些不必要的接口，并进行了一些正确性改进。有关更改内容的更多详细信息，请参阅我们的API 重大更改页面。 关系运算符中禁止的隐式强制转换如果您编写的代码可能会导致隐式的字符串到数字强制转换，则 TypeScript 中的某些操作会警告您： 123function func(ns: number | string) &#123; return ns * 4; // Error, possible implicit coercion&#125; 在 5.0 中，这也将应用于关系运算符&gt;、&lt;、&lt;=和&gt;=： 123function func(ns: number | string) &#123; return ns &gt; 4; // Now also an error&#125; 如果需要，要允许这样做，您可以显式地将操作数强制为numberusing +： 123function func(ns: number | string) &#123; return +ns &gt; 4; // OK&#125; 此正确性改进由 Mateusz Burzyński 提供。 枚举大修enum 自从它的第一个版本以来，TypeScript 就一直存在一些关于 s 的奇怪之处。在 5.0 中，我们正在清理其中的一些问题，并减少理解 enum 您可以声明的各种 s 所需的概念数。 作为其中的一部分，您可能会看到两个主要的新错误。首先是将域外文字分配给类型 enum 现在会像人们预期的那样出错： 12345678enum SomeEvenDigit &#123; Zero = 0, Two = 2, Four = 4&#125;​// Now correctly an errorlet m: SomeEvenDigit = 1; 另一个是用混合数字和间接字符串枚举引用声明值的枚举会错误地创建一个全数字 enum： 12345678910enum Letters &#123; A = &quot;a&quot;&#125;enum Numbers &#123; one = 1, two = Letters.A&#125;​// Now correctly an errorconst t: number = Numbers.two; 您可以在相关更改中查看更多详细信息。 对构造函数中的参数装饰器进行更准确的类型检查--experimentalDecoratorsTypeScript 5.0 使 --experimentalDecorators。这一点变得明显的一个地方是在构造函数参数上使用装饰器时。 12345678910export declare const inject: (entity: any) =&gt; (target: object, key: string | symbol, index?: number) =&gt; void;​export class Foo &#123;&#125;​export class C &#123; constructor(@inject(Foo) private x: any) &#123; &#125;&#125; 此调用将失败，因为key需要一个 string | symbol，但构造函数参数收到一个键 undefined。key 正确的解决方法是更改 within 的类型 inject。如果您使用的是无法升级的库，一个合理的解决方法是包装 inject 一个类型更安全的装饰器函数，并在key. 更多详情，请参阅本期。 弃用和默认更改在 TypeScript 5.0 中，我们弃用了以下设置和设置值： --target: ES3 --out --noImplicitUseStrict --keyofStringsOnly --suppressExcessPropertyErrors --suppressImplicitAnyIndexErrors --noStrictGenericChecks --charset --importsNotUsedAsValues --preserveValueImports prepend在项目参考中 在 TypeScript 5.5 之前，这些配置将继续被允许，届时它们将被完全删除，但是，如果您正在使用这些设置，您将收到警告。在 TypeScript 5.0 以及未来版本 5.1、5.2、5.3 和 5.4 中，您可以指定 &quot;ignoreDeprecations&quot;: &quot;5.0&quot; 屏蔽这些警告提示。我们还将很快发布一个 4.9 补丁，以允许指定 ignoreDeprecations 以允许更平滑的升级。除了弃用之外，我们还更改了一些设置以更好地改进 TypeScript 中的跨平台行为。 --newLine，它控制 JavaScript 文件中发出的行尾，如果未指定，过去常常根据当前操作系统进行推断。我们认为构建应该尽可能具有确定性，并且 Windows 记事本现在支持换行符行结尾，因此新的默认设置是 LF。 旧的特定于操作系统的推理行为不再可用。 --forceConsistentCasingInFileNames, 这确保了项目中对同一文件名的所有引用都在大小写中达成一致，现在默认为 true。 这有助于捕获在不区分大小写的文件系统上编写的代码的差异问题。 您可以留下反馈并查看有关 5.0 弃用跟踪问题的更多信息 下一步是什么？不要操之过急，TypeScript 5.1 已经在开发中了，我们所有的计划都已经在 GitHub 上了。如果你跃跃欲试，我们鼓励你尝试 TypeScript 的每日构建版本或针对 VS Code 的 JavaScript 和 TypeScript Nightly 扩展！ 当然，如果您选择只享受 TypeScript 的新稳定版，我们也不会感到受伤。我们希望 TypeScript 5.0 让每个人的编码更快、更有趣。 Happy Hacking! – Daniel Rosenwasser 和 TypeScript 团队","categories":[{"name":"外文翻译","slug":"外文翻译","permalink":"http://example.com/categories/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"外文翻译","slug":"外文翻译","permalink":"http://example.com/tags/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/"},{"name":"typescript","slug":"typescript","permalink":"http://example.com/tags/typescript/"}]},{"title":"[译] 尤雨溪：Vue 2022 回顾及 2023 展望","slug":"review2022","date":"2023-03-01T02:09:31.000Z","updated":"2023-03-01T02:09:31.000Z","comments":true,"path":"2023/03/01/review2022/","permalink":"http://example.com/2023/03/01/review2022/","excerpt":"","text":"原文 尤雨溪youtobe演进：Vue.js Nation 2023 新年快乐，Vue 社区！2023 年即将到来，我们想借此机会回顾一下 2022 年发生的事情，并讨论 2023 年的期望 回顾 2022 年2022 年 2 月，我们将 Vue 的默认版本切换为 3.x。这一转变标志着 v3 框架的所有官方部分都已准备就绪，包括对提供最新最佳实践指南的文档进行重大修改。 我们仍处于生态系统迁移到 Vue 3 的过渡期。因此，在转换之后，我们更专注于通过开发工具来改善 Vue 的开发人员体验。我们的团队成员一直积极参与 Vite 的开发，我们通过发布 Volar 1.0 对 Vue 的 IDE 和 TypeScript 支持进行了重大改进。 在 2022 年期间，我们看到 Vue 3 的 NPM 使用率增长了近 200% 。在社区方面，Vue 3生态系统现在已经成熟，提供了出色的解决方案，可以帮助提高你的开发效率。Nuxt 3 和 Vuetify 3 均在 2022 年 11 月达到稳定状态，NativeScript for Vue 3 最近推出了测试版。此外，我们想对长时间支持 Vue 3 的优秀项目表示感谢：Quasar、NaiveUI、Ionic Vue、PrimeVue、InkLine、ElementPlus、更多…。 尽管 Vue 3 现在是默认的，但我们知道由于迁移成本，许多用户不得不继续使用 Vue 2。为了确保 Vue 2 用户从框架的进步中受益，我们决定将 Vue 2 的源代码转移到 TypeScript，并在 Vue 2.7 中向后移植了一些最重要的 Vue 3 功能。我们还确保 Vite、Vue Devtools 和 Volar 都同时支持 Vue 2 和 Vue 3。 2023 年会发生什么较小和更频繁的次要版本随着最后一个 Vue 2 次要版本 (2.7) 的发布，我们预计将在 2023 年全速推出 Vue 3 核心的功能。我们有很长的功能列表，我们很高兴能继续努力！ 我们想要改进我们的发布节奏。Vue 遵循 semver，这意味着我们应该只发布次要版本的功能。过去，我们采用“大次要”方法，我们将许多功能组合在大的、不频繁的次要版本中。这导致在我们处理其他高复杂性功能时，相当多的低复杂性功能被阻止。在 2023 年，我们希望发布更小、更频繁的次要版本，以便我们能够更快地推出更多功能。 这也意味着我们将调整 3.3 中的内容。本来，我们计划在 3.3 中将 Suspense 和 Reactivity Transform 脱离实验阶段。但是，我们认为两者仍需要进一步的 RFC 讨论，并且它们不应阻碍其他更直接的功能落地。现在，3.3 的目标是明确且不需要 RFC 讨论的提议&#x2F;计划功能 - 例如，支持&lt;script setup&gt;宏中的外部导入类型。 与此同时，我们将： 进一步评估 Suspense 和 Reactivity Transform 的准备情况。 花时间评估未完成的用户提交的 RFC 和功能请求。 发布我们打算在 3.4 及更高版本中实现的功能的 RFC，例如 SSR 懒惰水合（SSR lazy hydration）。 预计本月晚些时候会有更多细节。 另一件需要注意的事情是，在可预见的未来没有重大突破性变化的计划。认识到用户在 v2 到 v3 过渡期间面临的挑战，我们希望 Vue 有一个更好的长期升级故事。 Vapor模式Vapor Mode 是我们一直在试验的另一种编译策略，其灵感来自Solid。给定相同的 Vue SFC，与当前基于虚拟 DOM 的输出相比，Vapor Mode 将其编译成性能更高、使用更少内存且需要更少运行时支持代码的 JavaScript 输出。它仍处于早期阶段，但这里有一些高层次的要点： Vapor 模式适用于主要关注性能的用例。它是可选的，不会影响现有的代码库。 至少，您将能够将 Vapor 组件子树嵌入到任何现有的 Vue 3 应用程序中。理想情况下，我们希望在组件级别实现精细的选择加入，这意味着在同一个应用程序中自由混合 Vapor 和非 Vapor 组件。 只使用 Vapor 组件构建应用程序允许您从包中删除虚拟 DOM 运行时，极大地减少基线运行时大小。 为了获得最佳性能，Vapor 模式将只支持 Vue 功能的一个子集。特别是，Vapor Mode 组件将仅支持 Composition API 和&lt;script setup&gt;。但是，这个受支持的子集在 Vapor 和非 Vapor 组件之间的工作方式完全相同。","categories":[{"name":"外文翻译","slug":"外文翻译","permalink":"http://example.com/categories/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"},{"name":"外文翻译","slug":"外文翻译","permalink":"http://example.com/tags/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/"}]},{"title":"[译] 2023年JavaScript的发展趋势","slug":"trends","date":"2023-02-24T04:00:00.000Z","updated":"2023-02-24T04:00:00.000Z","comments":true,"path":"2023/02/24/trends/","permalink":"http://example.com/2023/02/24/trends/","excerpt":"","text":"原文地址：https://www.jamesqquick.com/blog/javascript-trends-2023/ 前言2022年，比 Node.js 快三倍的 Bun 火速出圈，成为 JavaScript 框架中的当红炸子鸡，如何把握JavaScript 发展趋势和选择正确的技术方向对于前端开发而言至关重要。 众所周知，JavaScript 的生态系统发展非常迅速。事实上我们很难完全跟上它的发展节奏，下面让我们快速了解一下2023年应该关注的 JavaScript 发展趋势。 需要写的 Javascript 代码量会更少下面我列了几个原因来解释：为什么今年我们不再需要写那么多 JavaScript 代码了。 1. TypeScript这个听起来可能有点骇人听闻，但事实确实如此。TypeScript 的增长速度非常快。每天我都会听到越来越多的人说他们离不开 TypeScript。尽管 TypeScript 很明显非常类似于 JavaScript，但从技术上层面来讲，它和 JavaScript 迥然不同。 2. AI服务说实话，我一直对 AI 服务能否为我们提供建议和编写代码持怀疑态度。但是我对诸如Github Copilot 和 ChatGPT这样的工具感到非常惊讶。他们所能做的真的难以令人置信。尽管我认为他们不会取代我们的工作，但是我认为他们会为我们编写越来越多的代码，以至于我们需要自己去写的代码越来越少了。 3. 后端即服务平台 “我比较倾向于项目的构建速度，如果可以使用类似这样的平台为我处理后端，我完全赞成！” 后端即服务平台的增长意味着我们自己编写的代码会减少，像Supabase, Appwrite等平台可以处理数据库交互，身份认证，实时更新等等，使我们没有必要亲自去写这些代码。有些人可能更喜欢自己去编写所有代码，但我不是这样。我更喜欢快速构建项目，如果有像这样的一个平台可以为我处理后端，我完全赞成！ 4. 我们使用 JavaScript 语言来编写工具更少了 “也许现在是时候去学其他语言了……” 使用JavaScript编写JavaScript开发工具的现象将会越来越少了，听起来有点奇怪，对吧？以下是一些用不同语言编写的JavaScript工具示例。 esbuild - Go Turbopack - Rust Bun - Zig 越来越多的开发者正在使用其他的语言编写 JavaScript 工具，因为他们的性能会更好。预计这种趋势会持续下去！ 5. 使用更多的 JavaScript 运行环境（不仅仅是 Node.js）长期以来，Node.js 一直是“如何在服务上使用 JavaScript ？”的默认答案，但是现在要被改变了。我认为开发者社区已经意识到 Node 的局限性，并更倾向于使用其他替代方案。现在有几种其他的 JavaScript 运行环境可供选择。 Deno Bun Workers (from Cloudflare) 随着“边缘计算”（无论这意味这什么）的不断发展，不同的运行环境将被使用的范围也会越来越大。 6. 减少向浏览器发送 JavaScript “对于最大程度利用服务器性能，在我最喜欢的一些框架如Next.js 和 SvelteKit最近更新中都体现的非常明显；” 随着 Web 应用程序性能变得越来越重要，这已经成为一种趋势。你不得不承认，网站的性能可以直接影响你的营收底线。提高应用程序的一种方法就是减少向浏览器传输 JavaScript，而各种框架都在采取这种方式。 就个人而言，我认为 Remix 对推动框架更多地关注服务器而非浏览器发挥的巨大作用。从一开始，Remix 就具有在服务器上加载数据的钩子，因此无需在浏览器中执行该操作。这种最大程度利用服务器性能，在我最喜欢的一些框架 如Next.js 和 SvelteKit 最近更新中体现也很明显； 此外，我最喜欢的新框架之一 Astro 默认情况下不向浏览器发送任何 JavaScript。它的主要目标是提高性能。如果你还没有了解过它，我强烈推荐你去了解一下。 7. 出现更多 JavaScript 元框架提到元框架（无论现在我们如何称呼它们）我们通常会想到诸如 Next.js、SvelteKit 等这样的框架，不过我认为我们将会看到更多框架出现。说实话，虽然目前已经有太多框架让人眼花缭乱，但就我而言不反对继续创建更多的框架 无论是新的还是现有的框架，我认为开发者将会继续选择元框架，因为它们可以为我们节省大量的时间和精力。凡事均要权衡，但是元框架正在为我们处理越来越多的样板代码，我认为 JavaScript 开发者很喜欢这一点！","categories":[{"name":"外文翻译","slug":"外文翻译","permalink":"http://example.com/categories/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"},{"name":"外文翻译","slug":"外文翻译","permalink":"http://example.com/tags/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/"}]},{"title":"vue组件通信及vuex原理解析","slug":"vuex","date":"2020-03-20T15:47:09.000Z","updated":"2020-03-20T15:47:09.000Z","comments":true,"path":"2020/03/20/vuex/","permalink":"http://example.com/2020/03/20/vuex/","excerpt":"","text":"组件传值组件是 vue.js强大的功能之一，而组件实例的作用域是相互独立的，这就意味着不同组件之间的数据无法相互引用。一般来说，组件可以有以下几种关系： 父传子 props 12345// 父组件：&lt;HelloWorld msg=&quot;Welcome to Your Vue.js + TypeScript App&quot;/&gt; // 子组件props: &#123; msg: String &#125; $attrs 子组件未在props中声明的属性 inheritAttrs: false 1234567&lt;!-- 父组件 --&gt;&lt;HelloWorld msg=&quot;Welcome to Your Vue.js + TypeScript App&quot; foo=&quot;foo&quot;/&gt; &lt;!-- 子组件 --&gt;&lt;p&gt;&#123;&#123;$attrs.foo&#125;&#125;&lt;/p&gt; &lt;input v-bind=&quot;$attrs&quot;/&gt; // placeholder type ... $refs: 如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例 12345678910111213141516171819202122// 子组件export default &#123; data () &#123; return &#123; title: &#x27;I am hw componet&#x27; &#125; &#125;, methods: &#123; say () &#123; alert(&#x27;Hello&#x27;); &#125; &#125;&#125;// 父组件&lt;HelloWorld :msg=&quot;msg&quot; foo=&quot;foo&quot; @changeMsg=&quot;changeMsg&quot; ref=&quot;hw&quot; /&gt; mounted () &#123; const hw = this.$refs.hw; console.log(hw.title); // I am hw componet comA.sayHello(); // 弹窗 Hello&#125; $parent &#x2F; $children：访问父 &#x2F; 子实例 $children子元素不保证顺序 子传父 $emit、$on 123456789// 子组件this.$emit(&#x27;changeMsg&#x27;)// 父组件&lt;HelloWorld :msg=&quot;msg&quot; foo=&quot;foo&quot; @changeMsg=&quot;changeMsg&quot;/&gt;changeMsg() &#123; this.msg = &#x27;hello world!&#x27;&#125; 兄弟传值： 通过共同的祖辈组件搭桥，$parent或$root 1234// brother1this.$parent.$on(&#x27;foo&#x27;, handle)// brother2this.$parent.$emit(&#x27;foo&#x27;) 祖代传值 provide: Object | () &#x3D;&gt; Object inject: Array | { [key: string]: string | Symbol | Object } provide 和 inject 主要在开发高阶插件&#x2F;组件库时使用。并不推荐用于普通应用程序代码中。原理解析 【注意】：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的 12345678910111213provide () &#123; return &#123; bar: &#x27;provide value&#x27; &#125;&#125; // inject: [&#x27;bar&#x27;]inject: &#123; bar: &#123; type: string, default: &#x27;&#x27; &#125;&#125; 实现provide与inject响应化 不推荐 rovide祖先组件的实例，然后在子孙组件中注入依赖，这样就可以在子孙组件中直接修改祖先组件的实例的属性，不过这种方法有个缺点就是这个实例上挂载很多没有必要的东西比如props，methods 推荐 2.6.0 新增API Vue.observable 优化响应式 12345678910111213141516171819202122232425262728293031323334// 父组件export default class App extends Vue &#123; msg: string = &quot;Welcome to Your Vue.js + TypeScript App&quot;; // 调用Vue.observable声明响应数据appTheme appTheme: Theme = Vue.observable(&#123; color: &quot;red&quot; &#125;); @Provide() bar: string = &quot;root message&quot;; // 普通字符 @Provide() theme: object = this.appTheme; // 响应数据 @Provide() app: object = this; // 当前组件实例 changeMsg() &#123; this.msg = &quot;hello world!&quot;; &#125;&#125;// 子组件export default class HelloWorld extends Vue &#123; @Inject(&#123; default: &quot;&quot; &#125;) bar!: string; @Inject(&#123; default: () =&gt; (&#123;&#125;) &#125;) theme!: object; @Inject() app!: any mounted() &#123; console.log(this.theme, this.app); this.app.msg = &#x27;hw&#x27; // 直接在子组件中修改父组件的属性 (父组件不能响应变化) this.app.changeMsg(); // 调用父组件的方法(子组件不能响应变化) &#125;&#125; EventBus 事件总线 123456789101112131415161718192021222324252627282930313233// 初始化event-bus.jsimport Vue from &#x27;vue&#x27;export const EventBus = new Vue()// comA组件: 派发add事件import &#123; EventBus &#125; from &quot;./eventBus/event-bus&quot;;export default &#123; data () &#123; return &#123; count: 0 &#125; &#125;, methods: &#123; eveAdd() &#123; EventBus.$emit(&#x27;add&#x27;, ++this.count) &#125; &#125;&#125;// comB组件：监听add事件，展示add之后的结果import &#123; EventBus &#125; from &quot;./eventBus/event-bus&quot;;export default &#123; data () &#123; return &#123; num: 0 &#125; &#125;, mounted() &#123; EventBus.$on(&quot;add&quot;, count =&gt; &#123; this.num = count; &#125;); &#125;&#125; Vuex核心概念 state 管理vuex的数据（官方称之为单一状态树） getter state 中派生出一些状态 mutation 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation 必须是同步函数 action Action 提交的是 mutation，而不是直接变更状态 Action 可以包含任意异步操作 module 模块化（当应用变得特别复杂时，所有状态都会集中到一个较大的对象中，就会变得非常臃肿，按照模块精心分割，每个模块都拥有自己的state、mutation、action、getter） 12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 问题：mutation中执行异步操作会怎么样？ 事实上在 vuex 里面 actions 只是一个架构性的概念，并不是必须的，说到底只是一个函数，你在里面想干嘛都可以，只要最后触发 mutation 就行 — 尤雨溪知乎回答 Vuex 源码解析 Vue.use(Vuex) 做了什么？为什么axios不用Vue.use()方法？ new Vue({store}) store 在这里做了什么？ 为什么？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 // vuex.js 实现commit dispatch getter方法 var Vue// 实现install方法function install(_Vue) &#123; Vue = _Vue Vue.mixin(&#123; beforeCreate() &#123; if (this.$options.store) &#123; // vue的原型上挂载store（Store的实例） Vue.prototype.$store = this.$options.store &#125; &#125; &#125;)&#125;// 实现Store类class Store &#123; constructor(options) &#123; this.state = new Vue(&#123; // 实现state响应化 data: options.state &#125;) this.mutations = options.mutations || &#123;&#125; this.actions = options.actions || &#123;&#125; options.getters &amp;&amp; this.handleGetters(options.getters) &#125; commit = (type, arg) =&gt; &#123; this.mutations[type](this.state, arg) &#125; // dispatch方法接受一个上下文执行环境，注意与commit区分 dispatch(type, arg) &#123; this.actions[type](&#123; state: this.state, commit: this.commit, getters: this.getters &#125;, arg) &#125; handleGetters(getters) &#123; this.getters = &#123;&#125; Object.keys(getters).forEach(key =&gt; &#123; // 利用defineProtperty将getters的执行结果映射成对象 Object.defineProperty(this.getters, key, &#123; get: () =&gt; &#123; return getters[key](this.state) &#125; &#125;) &#125;) &#125; &#125; export default &#123; Store, install &#125;","categories":[{"name":"vuex","slug":"vuex","permalink":"http://example.com/categories/vuex/"}],"tags":[{"name":"vuex","slug":"vuex","permalink":"http://example.com/tags/vuex/"}]},{"title":"js 数组方法总结 之 一道面试题引发的思考","slug":"arr-methods","date":"2019-11-07T02:09:31.000Z","updated":"2019-11-07T02:09:31.000Z","comments":true,"path":"2019/11/07/arr-methods/","permalink":"http://example.com/2019/11/07/arr-methods/","excerpt":"","text":"在前端面试当中高频出现的一道面试题，让我产生了把js数组的方法总结一下的念头，呐，就是下面这道题目！看了解析先别撤哦，后面留了几道提升题目，你值得拥有（皮这一下很开心~~） 1234567891011121314151617181920212223242526272829303132[1, 2, 3].map(parseInt);// 解析：[1, 2, 3].map((item, index, arr) =&gt; parseInt(item, index));parseInt(1, 0); // 1parseInt(2, 1); // NaNparseInt(3, 2); // NaN// 故：结果为 [1, NaN, NaN]// 考点分析：map(function(currentValue, index, arr)&#123;&#125;)方法回调函数的参数// currentValue 当前元素的值// index 当前元素的索引值// arr 原数组parseInt(string, radix) 函数的参数// radix该值介于 2 ~ 36 之间,如果省略该参数或其值为 0，则数字将以 10 为基础来解析// 如果它以 “0x” 或 “0X” 开头，将以 16 为基数// 如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN 由此看出，主要是考察对数组方法的熟悉程度，接下来，我们一起回顾下数组的方法。特别需要是否改变原数组这一点，会对我们的变成带来意想不到的副作用。 转化方法 方法名 功能描述 是否改变原数组 返回结果 示例代码及输出 .toString() 将数组转换为一个以逗号分隔的字符串 否 字符串 [1, 2, 3].toString() → &quot;1,2,3&quot; .valueOf() 返回数组对象的原始值（仍为数组本身） 否 数组 [1, 2, &#39;3&#39;].valueOf() → [1, 2, &quot;3&quot;] .join(separator) 用指定的分隔符连接数组元素成为字符串 否 字符串 [1, 2, 3].join(&#39;-&#39;) → &quot;1-2-3&quot; 栈方法（LIFO） 方法名 功能描述 是否改变原数组 返回结果 示例代码及输出 .push(element1[, ...elements]) 在数组末尾添加元素 是 新数组长度 [1, 2].push(3) → 3, 数组：[1, 2, 3] .pop() 移除并返回数组的最后一个元素 是 移除的元素 [1, 2].pop() → 2, 数组：[1] 队列方法 方法名 功能描述 是否改变原数组 返回结果 示例代码及输出 .unshift(element1[, ...elements]) 在数组开头添加元素 是 新数组长度 [1, 2].unshift(0) → 3, 数组：[0, 1, 2] .shift() 移除并返回数组的第一个元素 是 移除的元素 [1, 2].shift() → 1, 数组：[2] 重排方法 方法名 功能描述 是否改变原数组 返回结果 示例代码及输出 .sort([compareFunction]) 对数组元素进行排序，可选自定义比较函数 是 排序后的数组 [1, 3, 11, 2].sort((a, b) =&gt; a - b) → [1, 2, 3, 11] .reverse() 颠倒数组中元素的顺序 是 颠倒后的数组 [1, 2, 3].reverse() → [3, 2, 1] 操作方法 方法名 功能描述 是否改变原数组 返回结果 示例代码及输出 .concat(array2[, ...arrays]) 连接两个或更多数组，并返回新数组 否 新数组 [1, 2].concat([3, 4]) → [1, 2, 3, 4] .splice(start[, deleteCount[, ...items]]) 在数组中添加&#x2F;删除项目，并返回被删除的元素数组 是 被删除的元素数组 [1, 2].splice(0, 1) → [1][1, 2].splice(0, 0, 3) → [], 数组：[1, 2, 3] .slice(start[, end]) 提取原数组的一部分，并返回一个新的数组 否 新数组 [1, 2, 3, 4].slice(1, 3) → [2, 3] 位置方法 方法名 功能描述 是否改变原数组 返回结果 示例代码及输出 .indexOf(searchElement[, fromIndex]) 查找数组中指定元素首次出现的位置，未找到返回-1 否 索引或-1 [1, 2, 3].indexOf(3) → 2 .lastIndexOf(searchElement[, fromIndex]) 从数组末尾向前查找指定元素最后一次出现的位置，未找到返回-1 否 索引或-1 [1, 2, 3].lastIndexOf(3) → 2 迭代方法 方法名 功能描述 是否改变原数组 返回结果 示例代码及输出 .every(callback[, thisArg]) 判断数组的所有元素是否都满足测试函数，都满足则返回true 否 boolean [1, 2, 3].every(item =&gt; item &gt; 0) → true .some(callback[, thisArg]) 判断数组中是否存在至少一个元素满足测试函数，存在则返回true 否 boolean [1, 2, 3].some(item =&gt; item &gt; 2) → true .filter(callback[, thisArg]) 根据测试函数过滤数组元素，并返回符合条件的新数组 否 新数组 [1, 2, 3].filter(item =&gt; item &gt; 2) → [3] .forEach(callback[, thisArg]) 对数组中的每个元素执行给定函数，无返回值 否 无返回值 N&#x2F;A .map(callback[, thisArg]) 遍历数组，对每个元素执行给定函数，并返回处理后的新数组 否 新数组 [1, 2, 3].map(item =&gt; item * 2) → [2, 4, 6] 归并方法 方法名 功能描述 是否改变原数组 返回结果 示例代码及输出 .reduce(callback[, initialValue]) 从左到右遍历数组，累积计算结果，返回单一最终值 否 累计结果 [1, 2, 3].reduce((prev, cur) =&gt; prev + cur) → 6 .reduceRight(callback[, initialValue]) 从右到左遍历数组，累积计算结果，返回单一最终值 否 累计结果 [1, 2, 3].reduceRight((prev, cur) =&gt; prev + cur) → 6 测试题12345678910111213[1, 2, 3].map(parseInt); // [1, NaN, NaN]==&gt; [1, 2, 3].map((item, index, arr) =&gt; parseInt(item, index));[1, 2, 3].filter(parseInt); // [1][1, 2, 3].every(parseInt); // false[1, 2, 3].some(parseInt); // true[1, 2, 3].reduce(parseInt); // 1==&gt; [1, 2, 3].reduce((prev, cur) =&gt; parseInt(prev, cur))","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"},{"name":"数组方法","slug":"数组方法","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"}]},{"title":"虚拟DOM和原生谁更快","slug":"virtual-dom","date":"2019-03-26T01:52:30.000Z","updated":"2019-03-26T01:52:30.000Z","comments":true,"path":"2019/03/26/virtual-dom/","permalink":"http://example.com/2019/03/26/virtual-dom/","excerpt":"","text":"论题： 虚拟DOM和原生谁更快原文链接虚拟DOM和原生谁更快？ DOM和DOM-diff 尤大在知乎的回复 原生 DOM 操作 vs. 通过框架封装操作。 这是一个性能 vs. 可维护性的取舍。框架的意义在于为你掩盖底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。针对任何一个 benchmark，我都可以写出比任何框架更快的手动优化，但是那有什么意义呢？在构建一个实际应用的时候，你难道为每一个地方都去做手动优化吗？出于可维护性的考虑，这显然不可能。框架给你的保证是，你在不需要手动优化的情况下，我依然可以给你提供过得去的性能。 对 React 的 Virtual DOM 的误解。 React 从来没有说过 “React 比原生操作 DOM 快”。React 的基本思维模式是每次有变动就整个重新渲染整个应用。如果没有 Virtual DOM，简单来想就是直接重置 innerHTML。很多人都没有意识到，在一个大型列表所有数据都变了的情况下，重置 innerHTML 其实是一个还算合理的操作… 真正的问题是在 “全部重新渲染” 的思维模式下，即使只有一行数据变了，它也需要重置整个 innerHTML，这时候显然就有大量的浪费。我们可以比较一下 innerHTML vs. Virtual DOM 的重绘性能消耗：innerHTML: render html string O(template size) + 重新创建所有 DOM 元素 O(DOM size)Virtual DOM: render Virtual DOM + diff O(template size) + 必要的 DOM 更新 O(DOM change)Virtual DOM render + diff 显然比渲染 html 字符串要慢，但是！它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。可以看到，innerHTML 的总计算量不管是 js 计算还是 DOM 操作都是和整个界面的大小相关，但 Virtual DOM 的计算量里面，只有 js 计算和界面大小相关，DOM 操作是和数据的变动量相关的。前面说了，和 DOM 操作比起来，js 计算是极其便宜的。这才是为什么要有 Virtual DOM：它保证了 1）不管你的数据变化多少，每次重绘的性能都可以接受；2) 你依然可以用类似 innerHTML 的思路去写你的应用。 MVVM vs. Virtual DOM 相比起 React，其他 MVVM 系框架比如 Angular, Knockout 以及 Vue、Avalon 采用的都是数据绑定：通过 Directive&#x2F;Binding 对象，观察数据变化并保留对实际 DOM 元素的引用，当有数据变化时进行对应的操作。MVVM 的变化检查是数据层面的，而 React 的检查是 DOM 结构层面的。MVVM 的性能也根据变动检测的实现原理有所不同：Angular 的脏检查使得任何变动都有固定的 O(watcher count) 的代价；Knockout&#x2F;Vue&#x2F;Avalon 都采用了依赖收集，在 js 和 DOM 层面都是 O(change)：脏检查：scope digest O(watcher count) + 必要 DOM 更新 O(DOM change)依赖收集：重新收集依赖 O(data change) + 必要 DOM 更新 O(DOM change)可以看到，Angular 最不效率的地方在于任何小变动都有的和 watcher 数量相关的性能代价。但是！当所有数据都变了的时候，Angular 其实并不吃亏。依赖收集在初始化和数据变化的时候都需要重新收集依赖，这个代价在小量更新的时候几乎可以忽略，但在数据量庞大的时候也会产生一定的消耗。MVVM 渲染列表的时候，由于每一行都有自己的数据作用域，所以通常都是每一行有一个对应的 ViewModel 实例，或者是一个稍微轻量一些的利用原型继承的 “scope” 对象，但也有一定的代价。所以，MVVM 列表渲染的初始化几乎一定比 React 慢，因为创建 ViewModel &#x2F; scope 实例比起 Virtual DOM 来说要昂贵很多。这里所有 MVVM 实现的一个共同问题就是在列表渲染的数据源变动时，尤其是当数据是全新的对象时，如何有效地复用已经创建的 ViewModel 实例和 DOM 元素。假如没有任何复用方面的优化，由于数据是 “全新” 的，MVVM 实际上需要销毁之前的所有实例，重新创建所有实例，最后再进行一次渲染！这就是为什么题目里链接的 angular&#x2F;knockout 实现都相对比较慢。相比之下，React 的变动检查由于是 DOM 结构层面的，即使是全新的数据，只要最后渲染结果没变，那么就不需要做无用功。Angular 和 Vue 都提供了列表重绘的优化机制，也就是 “提示” 框架如何有效地复用实例和 DOM 元素。比如数据库里的同一个对象，在两次前端 API 调用里面会成为不同的对象，但是它们依然有一样的 uid。这时候你就可以提示 track by uid 来让 Angular 知道，这两个对象其实是同一份数据。那么原来这份数据对应的实例和 DOM 元素都可以复用，只需要更新变动了的部分。或者，你也可以直接 track by $index 来进行 “原地复用”：直接根据在数组里的位置进行复用。在题目给出的例子里，如果 angular 实现加上 track by $index 的话，后续重绘是不会比 React 慢多少的。甚至在 dbmonster 测试中，Angular 和 Vue 用了 track by $index 以后都比 React 快: dbmon (注意 Angular 默认版本无优化，优化过的在下面）顺道说一句，React 渲染列表的时候也需要提供 key 这个特殊 prop，本质上和 track-by 是一回事。 性能比较也要看场合 在比较性能的时候，要分清楚初始渲染、小量数据更新、大量数据更新这些不同的场合。Virtual DOM、脏检查 MVVM、数据收集 MVVM 在不同场合各有不同的表现和不同的优化需求。Virtual DOM 为了提升小量数据更新时的性能，也需要针对性的优化，比如 shouldComponentUpdate 或是 immutable data。初始渲染：Virtual DOM &gt; 脏检查 &gt;&#x3D; 依赖收集小量数据更新：依赖收集 &gt;&gt; Virtual DOM + 优化 &gt; 脏检查（无法优化） &gt; Virtual DOM 无优化大量数据更新：脏检查 + 优化 &gt;&#x3D; 依赖收集 + 优化 &gt; Virtual DOM（无法&#x2F;无需优化）&gt;&gt; MVVM 无优化不要天真地以为 Virtual DOM 就是快，diff 不是免费的，batching 么 MVVM 也能做，而且最终 patch 的时候还不是要用原生 API。在我看来 Virtual DOM 真正的价值从来都不是性能，而是它 1) 为函数式的 UI 编程方式打开了大门；2) 可以渲染到 DOM 以外的 backend，比如 ReactNative。 总结 以上这些比较，更多的是对于框架开发研究者提供一些参考。主流的框架 + 合理的优化，足以应对绝大部分应用的性能需求。如果是对性能有极致需求的特殊情况，其实应该牺牲一些可维护性采取手动优化：比如 Atom 编辑器在文件渲染的实现上放弃了 React 而采用了自己实现的 tile-based rendering；又比如在移动端需要 DOM-pooling 的虚拟滚动，不需要考虑顺序变化，可以绕过框架的内置实现自己搞一个。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"virtual-dom","slug":"virtual-dom","permalink":"http://example.com/tags/virtual-dom/"}]},{"title":"闭包","slug":"closure","date":"2018-07-13T06:31:27.000Z","updated":"2018-07-13T06:31:27.000Z","comments":true,"path":"2018/07/13/closure/","permalink":"http://example.com/2018/07/13/closure/","excerpt":"","text":"作用域js 中变量分为全局变量、局部变量 123456789var a = 1; // 全局变量function A()&#123; b = 2; // 全局变量（严格模式下报错） var c = 3; // 局部变量&#125;;A();console.log(a); // 1console.log(b); // 2console.log(c); // Error：c is not defined 预解析js 会把带有 var 和 function 关键字的事先声明，并在存放在栈区中 123456console.log(a); // undefinedvar a = 1;console.log(b); // undefinedvar b = function b()&#123;&#125;; // 本质还是通过var声明console.log(c); // ƒ c()&#123;&#125;function c()&#123;&#125;; 疑问？ 12345function out()&#123; var a = 1;&#125;;out();console.log(a); // Error: a is not defined， 为什么这里报错了，没有预解析 解析执行环境在 js 执行之前是会预解析 function 和 var 没错，但是在本例中 它们的“解析执行环境”不同. function out 是在一个全局的环境中，而 a 是 function out 中定义的一个局部变量，a 的“解析执行环境”是在 function out 这个函数里面(这里可以理解为 function out 里的局部环境)，所以当我们在全局这个环境中 console.log(a) 的时候，并没有定义 a 这个变量或者函数，所以就报错了 123456function out()&#123; console.log(a); // undefined var a = 1;&#125;;out();console.log(a); // Error: a is not defined 垃圾回收机制-GC原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。不再使用的变量：也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。 闭包作用：局部变量常驻内存，读取函数内部的变量构成：函数嵌套，内部函数调用外部函数的变量缺点：造成内存泄漏 12345678function parent() &#123; var a = 1; function son() &#123; return a++; &#125; return son();&#125;console.log(parent()); // 1 内存泄漏 意外的全局变量引起的内存泄漏。 原因：全局变量，不会被回收。 解决：使用严格模式避免。 闭包引起的内存泄漏 原因：闭包可以维持函数内局部变量，使其得不到释放。 解决：在退出函数之前，将不使用的局部变量全部删除，如在不用parent函数的时候，parent &#x3D; null 没有清理的 DOM 元素引用 原因：虽然别的地方删除了，但是对象中还存在对 dom 的引用 解决：手动删除。 被遗忘的定时器或者回调 原因：定时器中有 dom 的引用，即使 dom 删除了，但是定时器还在，所以内存中还是有这个 dom。 解决：手动删除定时器和 dom。","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"},{"name":"闭包","slug":"闭包","permalink":"http://example.com/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"原型、原型链","slug":"prototype","date":"2018-07-12T07:10:06.000Z","updated":"2018-07-12T07:10:06.000Z","comments":true,"path":"2018/07/12/prototype/","permalink":"http://example.com/2018/07/12/prototype/","excerpt":"","text":"函数声明123var f1 = function()&#123;&#125;; // 1. 字面量function f2 = function()&#123;&#125;; // 2. 关键词 var f3 = new Function(); // 3. 构造函数 归根结底都是通过new Function 的方式来创建的，js中一切皆对象，对象又分函数对象和普通对象，简单来说通过new Function创建的就称之为函数对象，其他的都是普通对象 原型对象在js中每一个对象（普通对象、函数对象）都有一个__proto__ 属性，函数对象都有一个prototype属性，指向函数的原型对象 123456789101112131415161718192021var obj = &#123;&#125;;var fn = function()&#123;&#125;;console.log(obj.__proto__); // &#123;constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, …&#125;console.log(obj.prototype); // undefined console.log(fn.__proto__); // ƒ () &#123; [native code] &#125;console.log(fn.prototype); // &#123;constructor: ƒ&#125;// 其中 prototype 就是原型对象，当然原型对象也是一个普通对象，它的作用主要是用来实现继承的，举个栗子： var Animal = function()&#123; this.name = &#x27;Tom&#x27;;&#125;Animal.prototype.say = function()&#123; console.log(&#x27;I am &#x27; + this.name)&#125;var cat = new Animal();var dog = new Animal();cat.say(); // I am Tomdog.say(); // I am Tom 这里原型继承的问题，暂且按下不表（皮这一下，很开心~~） 原型链上文说到，每一个对象都有一个__proto__ 属性，那么这个属性究竟有什么用呢？先来看几个例子 123456789var Animal = function()&#123; this.name = &#x27;Tom&#x27;;&#125;var cat = new Animal();console.log(cat.__proto__ === Animal.prototype); // trueconsole.log(Animal.prototype.__proto__ === Object.prototype); // trueconsole.log(Object.prototype.__proto__ === null); // true 从这个例子中可以看出 __proto__ 属性指向构造函数的原型对象prototype，而prototype也是一个普通对象，也有__proto__属性，继续指向其构造函数，直到指向null，这样就形成了一个原型指向的链条，专业术语称之为原型链。至于为什么最终是null，如果非要解释的话，引用道德经中的一句话：有，是万物之所始；无，是万物之所母。此外，Function、Object作为js的内置函数对象，需要清楚一点，他们都是 new Function创建的 console.log(Function.constructor === Object.constructor); // true new 的实现过程通过new 一个构造函数得到一个对象，看一下内部实现过程，有助于帮助理解原型链指向 1. 声明一个对象 var obj = &#123;&#125;; 2. obj.\\_\\_proto__ = 构造函数.prototype; 3. 改变this指针，通过call、apply让this指向第一步创建的obj； 4. 返回对象obj; 12345678910111213141516171819202122function Animal(name)&#123; this.name = name;&#125;Animal.prototype.say = function()&#123; console.log(&#x27;I am &#x27; + this.name)&#125;function myNew() &#123; var obj = &#123;&#125;; // 是指还是new，不要纠结，只是模拟new的过程 var Constructor = [].shift.call(arguments); // 构造函数 Animal //constructor属性是在Animal.prototype对象中用来记录它指向的 构造函数 的属性 console.log(Constructor.prototype); // &#123;say: ƒ, constructor: ƒ&#125; say:ƒ() constructor:ƒ Animal(name) obj.__proto__ = Constructor.prototype; // 让obj.__proto__ 指向 Animal.prototype Constructor.apply(obj,arguments); // 让this指向obj return obj;&#125;var cat= myNew(Animal,&#x27;Tom&#x27;);console.log(cat.name); // Tomcat.say(); // I am Tomconsole.log(cat.constructor); // ƒ Animal(name)&#123; this.name = name; &#125; 大招如果以上内容还是不太明白，我自己做了张注解图（线条有点多而杂，见谅~~），以及代码案例帮助理解 12345678910111213141516171819202122// 几个概念： // 普通对象是new Object而来的，所以 它的构造函数就是Object// 函数对象是new Function而来的，所以 它的构造函数就是Function，Function、Object是new Function而来的// 对象的__proto__ 指向构造函数的prototypefunction Animal()&#123;&#125;var cat = new Animal();cat.constructor == Animal; // truecat.__proto__ === Animal.prototype; // trueAnimal.constructor === Function; // trueAnimal.prototype.__proto__ === Object.prototype; // true 注：prototype是对象Animal.__proto__ === Function.prototype; // trueObject.constructor === Function; // trueObject.__proto__ === Function.prototype; // trueObject.prototype.__proto__ === null; // trueFunction.constructor === Function; // trueFunction.__proto__ === Function.prototype; // trueFunction.prototype.__proto__ === Object.prototype; // true","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"},{"name":"原型","slug":"原型","permalink":"http://example.com/tags/%E5%8E%9F%E5%9E%8B/"},{"name":"new的过程","slug":"new的过程","permalink":"http://example.com/tags/new%E7%9A%84%E8%BF%87%E7%A8%8B/"}]},{"title":"hexo command","slug":"hello-world","date":"2017-07-24T02:09:31.000Z","updated":"2017-07-24T02:09:31.000Z","comments":true,"path":"2017/07/24/hello-world/","permalink":"http://example.com/2017/07/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"开博缘由","slug":"begin","date":"2017-04-29T09:02:38.000Z","updated":"2017-04-29T09:02:38.000Z","comments":true,"path":"2017/04/29/begin/","permalink":"http://example.com/2017/04/29/begin/","excerpt":"","text":"缘起佛曰：一切皆有缘法，缘起缘灭缘自在 情深情浅不由人，总觉得少这么一个起因内心有愧~~对于任何一个有追求(装X)的前端攻城狮来说，拥有一个博客是追求(装X)路上的一把利刃，正所谓念念不忘必有回响，历经千辛万苦，算是给自己搭建了一个属于自己的小窝。当然，如果开博不是为了装X，那将变得毫无意义！搭建这个博客的主要原因是想把自己学习道路上get到的技能做一个梳理，好记性不如烂笔头么！其次是把自己踩得那些坑分享给更多的人，可能您要说就我的这点经验是在没有借鉴的价值。NO NO NO 且听我慢慢道来。往往看一些大神的帖子会有一种感觉就是规避掉了一些你关注的点，当然这个不是说人家考虑的不到位，而是由于我们的技术栈存在差异，可能人家在做第一步的时候就已经为后面做好了一些铺垫，规避掉了一些问题，而并没有体现到教程当中，这样对于初学者来可能就会遇到一些莫名奇妙的问题。好吧！我承认是自己强行解释了一波，来掩盖我要装的本质！ 与hexo结缘要感谢一位许姓小伙伴的极力推荐，看了整个搭建过程的文档之后就按耐不住内心的冲动，义无反顾的qrq送了一血！然后就有了… (不要想歪啊 ~~) 缘灭如若梦起缘生，梦逝缘灭，我愿一梦不起 是不是已心动不已，赶快移步到使用GitHub + hexo搭建个人博客 行动起来吧！","categories":[{"name":"心情物语","slug":"心情物语","permalink":"http://example.com/categories/%E5%BF%83%E6%83%85%E7%89%A9%E8%AF%AD/"}],"tags":[{"name":"心情物语","slug":"心情物语","permalink":"http://example.com/tags/%E5%BF%83%E6%83%85%E7%89%A9%E8%AF%AD/"}]},{"title":"使用GitHub + hexo搭建个人博客","slug":"create-hexo-blog","date":"2017-04-03T20:04:06.000Z","updated":"2017-04-03T20:04:06.000Z","comments":true,"path":"2017/04/04/create-hexo-blog/","permalink":"http://example.com/2017/04/04/create-hexo-blog/","excerpt":"","text":"本文环境 git 2.18 node v10.16.0 安装hexo1npm install -g hexo-cli github上创建仓库仓库名：username.github.io 仓库名必须为user + .github.io，这个名字也是将来博客的访问地址 博客的创建初始化1hexo init xuyz-blog 会生成一个名为xuyz-blog的文件夹，就是将来博客的配置及存放博文的地方 基础配置打开xuyz-blog&#x2F;_config.yml文件进行基础配置，以下只举几个关键的配置 123456789101112131415# Sitetitle: xuyz-blog # 博客名字subtitle: &#x27;鲜衣怒马少年时，一日看尽长安花&#x27; # 小标题可以写自己喜欢的话description: &#x27;光景不待人，须臾发成丝&#x27; # 博客描述keywords: xuyangzhouauthor: xuyangzhou # 作者名字language: zh-CN # 语言url: / # 自己购买的域名网址（没有可不写）theme: landscape # 主题的名字deploy: type: git # 使用git发布 repo: https://github.com/xuyangzhou/xuyangzhou.github.io.git # 刚刚创建的仓库地址 本地预览12hexo serverhexo s # 简写 打开localhost:4000 即可看到我们的博客界面了 发布1234hexo cleanhexo generate # hexo g 简写hexo deploy # hexo d 简写# hexo d -g === hexo g &amp; hexo d 这里如果出错，找不到repository，需要安装hexo-deployer-git插件，再执行hexo d命令 1npm install hexo-deployer-git --save 打开xuyangzhou.github.io（就是你创建的仓库名）即可看到 至此，博客已经搭建工作已大功告成了，我们已经拥有了自己的一个小窝了，但是我们还要发表博文，修改页面样式，添加一些诸如搜索、评论、浏览统计等等功能，预知后事如何，且听下文分解！ 写博客新建博文1hexo new &#x27;文件名&#x27; # 会在source/_posts创建一个文件名.md文件 编辑博文1234567---title: new // 博客标题date: 2017-04-04 04:04:06 // 创建时间tags: hexo // 标签categories: hexo // 分类--- 这里写正文（上面的---是必要的） 插入图片外网图片1![图片描述](http://www.baidu.com/1.jpg) 本地图片使用hexo-asset-image插件1npm install hexo-asset-image --save 修改xuyz-blog&#x2F;_config.yml中的post_asset_folder为true 1post_asset_folder: false 之后再使用 hexo new ‘new’ 创建新博文的时候，会在source&#x2F;_posts里面创建.md文件的同时生成一个相同的名字的文件夹，把该文章中需要使用的图片放在该文件夹下即可 1![图片描述](new/new.jpg) 在source下新建images文件夹（推荐）使用hexo-asset-image个人认为不利用图片复用，直接根目录的source下新建存放本地图片的文件夹简便有效 1![图片描述(可以不写)](/images/new.jpg) 更换主题主题这东西嘛，萝卜青菜，各有所爱，没有最好，只有合适，具体请移步hexo主题选取一款适合自己的吧！ 以next为例，下载对应主题，修改_config.yml中的theme为next即可！ 12cd xuyz-blog文件下git clone https://github.com/iissnan/hexo-theme-next themes/next 更多关于next主题下的配置问题请移步next使用文档","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]}],"categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"},{"name":"外文翻译","slug":"外文翻译","permalink":"http://example.com/categories/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/"},{"name":"vuex","slug":"vuex","permalink":"http://example.com/categories/vuex/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"},{"name":"心情物语","slug":"心情物语","permalink":"http://example.com/categories/%E5%BF%83%E6%83%85%E7%89%A9%E8%AF%AD/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"},{"name":"动画","slug":"动画","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB/"},{"name":"typescript","slug":"typescript","permalink":"http://example.com/tags/typescript/"},{"name":"reduce","slug":"reduce","permalink":"http://example.com/tags/reduce/"},{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"},{"name":"set","slug":"set","permalink":"http://example.com/tags/set/"},{"name":"map","slug":"map","permalink":"http://example.com/tags/map/"},{"name":"vuex","slug":"vuex","permalink":"http://example.com/tags/vuex/"},{"name":"vuex 源码","slug":"vuex-源码","permalink":"http://example.com/tags/vuex-%E6%BA%90%E7%A0%81/"},{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"},{"name":"外文翻译","slug":"外文翻译","permalink":"http://example.com/tags/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/"},{"name":"Volar","slug":"Volar","permalink":"http://example.com/tags/Volar/"},{"name":"数组方法","slug":"数组方法","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"name":"virtual-dom","slug":"virtual-dom","permalink":"http://example.com/tags/virtual-dom/"},{"name":"闭包","slug":"闭包","permalink":"http://example.com/tags/%E9%97%AD%E5%8C%85/"},{"name":"原型","slug":"原型","permalink":"http://example.com/tags/%E5%8E%9F%E5%9E%8B/"},{"name":"new的过程","slug":"new的过程","permalink":"http://example.com/tags/new%E7%9A%84%E8%BF%87%E7%A8%8B/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"心情物语","slug":"心情物语","permalink":"http://example.com/tags/%E5%BF%83%E6%83%85%E7%89%A9%E8%AF%AD/"}]}