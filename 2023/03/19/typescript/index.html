<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>[译] TypeScript 5.0 发布 | Jason</title><meta name="description" content="原文地址：Announcing TypeScript 5.0 2023.3.16 by Daniel Rosenwasser and the TypeScript Team  今天，我们很高兴地宣布 TypeScript 5.0 的发布！ 此版本带来了许多新功能，同时旨在使 TypeScript 更小、更简单、更快。我们已经实施了新的装饰器标准，添加了更好地支持 Node 和 bundlers"><meta property="og:type" content="article"><meta property="og:title" content="[译] TypeScript 5.0 发布"><meta property="og:url" content="http://example.com/2023/03/19/typescript/index.html"><meta property="og:site_name" content="Jason"><meta property="og:description" content="原文地址：Announcing TypeScript 5.0 2023.3.16 by Daniel Rosenwasser and the TypeScript Team  今天，我们很高兴地宣布 TypeScript 5.0 的发布！ 此版本带来了许多新功能，同时旨在使 TypeScript 更小、更简单、更快。我们已经实施了新的装饰器标准，添加了更好地支持 Node 和 bundlers"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f46be8a37aea48dbbb6e2f5e2163f435~tplv-k3u1fbpfcp-watermark.image"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73208158996a434d98515e52316ecd17~tplv-k3u1fbpfcp-zoom-1.image"><meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ac8162940ec44d796be80db5e65c423~tplv-k3u1fbpfcp-zoom-1.image"><meta property="article:published_time" content="2023-03-19T04:00:00.000Z"><meta property="article:modified_time" content="2023-03-19T04:00:00.000Z"><meta property="article:author" content="Jason xu"><meta property="article:tag" content="外文翻译"><meta property="article:tag" content="typescript"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f46be8a37aea48dbbb6e2f5e2163f435~tplv-k3u1fbpfcp-watermark.image"><link rel="canonical" href="http://example.com/2023/03/19/typescript/index.html"><link rel="alternate" href="/atom.xml" title="Jason" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 7.1.1"></head><body class="main-center theme-purple" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/xuyangzhou" target="_blank"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">Jason</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md">鲜衣怒马少年时，一日看尽长安花</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> xi&#39;an, China</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="搜索"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav menu-highlight"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">首页</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">归档</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">分类</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">标签</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/xuyangzhou" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="https://www.jianshu.com/u/162eaf8819d3" target="_blank" title="简书" data-toggle="tooltip" data-placement="top"><i class="icon icon-简书"></i></a></li><li><a href="https://juejin.cn/user/2471357871046333" target="_blank" title="Juejin" data-toggle="tooltip" data-placement="top"><i class="icon icon-juejin"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">公告</h3><div class="widget-body"><div id="board"><div class="content"><p>光景不待人，须臾发成丝</p></div></div></div></div><div class="widget"><h3 class="widget-title">分类</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/vuex/">vuex</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/">外文翻译</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BF%83%E6%83%85%E7%89%A9%E8%AF%AD/">心情物语</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a><span class="category-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签</h3><div class="widget-body"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6/" rel="tag">ES6</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Volar/" rel="tag">Volar</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/" rel="tag">map</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/new%E7%9A%84%E8%BF%87%E7%A8%8B/" rel="tag">new的过程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reduce/" rel="tag">reduce</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/set/" rel="tag">set</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typescript/" rel="tag">typescript</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtual-dom/" rel="tag">virtual-dom</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vuex/" rel="tag">vuex</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vuex-%E6%BA%90%E7%A0%81/" rel="tag">vuex 源码</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E7%94%BB/" rel="tag">动画</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%9E%8B/" rel="tag">原型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/" rel="tag">外文翻译</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%83%E6%83%85%E7%89%A9%E8%AF%AD/" rel="tag">心情物语</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/" rel="tag">数组方法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%97%AD%E5%8C%85/" rel="tag">闭包</a><span class="tag-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签云</h3><div class="widget-body tagcloud"><a href="/tags/ES6/" style="font-size:13px">ES6</a> <a href="/tags/Volar/" style="font-size:13px">Volar</a> <a href="/tags/hexo/" style="font-size:13.25px">hexo</a> <a href="/tags/js/" style="font-size:14px">js</a> <a href="/tags/map/" style="font-size:13px">map</a> <a href="/tags/new%E7%9A%84%E8%BF%87%E7%A8%8B/" style="font-size:13px">new的过程</a> <a href="/tags/reduce/" style="font-size:13px">reduce</a> <a href="/tags/set/" style="font-size:13px">set</a> <a href="/tags/typescript/" style="font-size:13.25px">typescript</a> <a href="/tags/virtual-dom/" style="font-size:13px">virtual-dom</a> <a href="/tags/vue/" style="font-size:13.25px">vue</a> <a href="/tags/vuex/" style="font-size:13.25px">vuex</a> <a href="/tags/vuex-%E6%BA%90%E7%A0%81/" style="font-size:13.5px">vuex 源码</a> <a href="/tags/%E5%8A%A8%E7%94%BB/" style="font-size:13px">动画</a> <a href="/tags/%E5%8E%9F%E5%9E%8B/" style="font-size:13px">原型</a> <a href="/tags/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/" style="font-size:13.75px">外文翻译</a> <a href="/tags/%E5%BF%83%E6%83%85%E7%89%A9%E8%AF%AD/" style="font-size:13px">心情物语</a> <a href="/tags/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/" style="font-size:13px">数组方法</a> <a href="/tags/%E9%97%AD%E5%8C%85/" style="font-size:13px">闭包</a></div></div><div class="widget"><h3 class="widget-title">归档</h3><div class="widget-body"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">2</span></li></ul></div></div><div class="widget"><h3 class="widget-title">最新文章</h3><div class="widget-body"><ul class="recent-post-list list-unstyled no-thumbnail"><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/js/">js</a></p><p class="item-title"><a href="/2023/05/08/js10/" class="title">10个让你爱不释手的一行Javascript代码</a></p><p class="item-date"><time datetime="2023-05-08T03:01:42.000Z" itemprop="datePublished">2023-05-08</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/js/">js</a></p><p class="item-title"><a href="/2023/05/07/js-pithy/" class="title">10个JavaScript简洁编码技巧</a></p><p class="item-date"><time datetime="2023-05-07T03:01:42.000Z" itemprop="datePublished">2023-05-07</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/">外文翻译</a></p><p class="item-title"><a href="/2023/05/06/animatingTheUnanimatable/" class="title">[译] 动画无法动画化的元素</a></p><p class="item-date"><time datetime="2023-05-06T03:01:42.000Z" itemprop="datePublished">2023-05-06</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/js/">js</a></p><p class="item-title"><a href="/2023/05/04/typescript-eg/" class="title">10个超级实用的typescript使用技巧</a></p><p class="item-date"><time datetime="2023-05-04T04:00:00.000Z" itemprop="datePublished">2023-05-04</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/js/">js</a></p><p class="item-title"><a href="/2023/04/20/javascript/" class="title">[译] ECMAScript 2023有哪些新特性</a></p><p class="item-date"><time datetime="2023-04-20T03:01:42.000Z" itemprop="datePublished">2023-04-20</time></p></div></li></ul></div></div></div></aside><aside class="sidebar sidebar-toc collapse in" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><nav id="toc" class="article-toc"><h3 class="toc-title">文章目录</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA-Beta-%E5%92%8C-RC-%E4%BB%A5%E6%9D%A5%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B0%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">自 Beta 和 RC 以来有什么新功能？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">装饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%AE%9E%E9%AA%8C%E6%80%A7%E9%81%97%E7%95%99%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">2.1.</span> <span class="toc-text">与实验性遗留装饰器的差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E7%B1%BB%E5%9E%8B%E8%89%AF%E5%A5%BD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">编写类型良好的装饰器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const-%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">const 泛型参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extends-%E6%94%AF%E6%8C%81%E5%A4%9A%E4%B8%AA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">extends 支持多个配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E6%9E%9A%E4%B8%BE%E9%83%BD%E6%98%AF%E8%81%94%E5%90%88%E6%9E%9A%E4%B8%BE"><span class="toc-number">5.</span> <span class="toc-text">所有枚举都是联合枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#moduleResolution-%E6%96%B0%E5%A2%9E-bundler-%E6%94%AF%E6%8C%81"><span class="toc-number">6.</span> <span class="toc-text">--moduleResolution 新增 bundler 支持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%A3%E6%9E%90%E6%A0%87%E5%BF%97"><span class="toc-number">7.</span> <span class="toc-text">自定义解析标志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#allowImportingTsExtensions"><span class="toc-number">7.1.</span> <span class="toc-text">allowImportingTsExtensions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#resolvePackageJsonExports"><span class="toc-number">7.2.</span> <span class="toc-text">resolvePackageJsonExports</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#resolvePackageJsonImports"><span class="toc-number">7.3.</span> <span class="toc-text">resolvePackageJsonImports</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#allowArbitraryExtensions"><span class="toc-number">7.4.</span> <span class="toc-text">allowArbitraryExtensions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#customConditions"><span class="toc-number">7.5.</span> <span class="toc-text">customConditions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#verbatimModuleSyntax"><span class="toc-number">8.</span> <span class="toc-text">--verbatimModuleSyntax</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%AF%E6%8C%81-export-type"><span class="toc-number">9.</span> <span class="toc-text">支持 export type *</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSDoc-%E6%94%AF%E6%8C%81-satisfies"><span class="toc-number">10.</span> <span class="toc-text">JSDoc 支持 @satisfies</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSDoc-%E6%94%AF%E6%8C%81-overload"><span class="toc-number">11.</span> <span class="toc-text">JSDoc 支持 @overload</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8tsc-build-%E6%97%B6%E5%8F%AF%E4%BB%A5%E4%BC%A0%E5%85%A5%E7%9A%84%E6%96%B0%E6%8C%87%E4%BB%A4"><span class="toc-number">12.</span> <span class="toc-text">在tsc --build 时可以传入的新指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99%E7%9A%84%E5%AF%BC%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">13.</span> <span class="toc-text">编辑器中不区分大小写的导入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch-case-%E8%AF%AD%E6%B3%95%E8%A1%A5%E8%B6%B3"><span class="toc-number">14.</span> <span class="toc-text">switch&#x2F;case 语法补足</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9F%E5%BA%A6%E3%80%81%E5%86%85%E5%AD%98%E5%92%8C%E5%8C%85%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96"><span class="toc-number">15.</span> <span class="toc-text">速度、内存和包大小优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%A4%A7%E6%9B%B4%E6%94%B9%E5%92%8C%E5%BC%83%E7%94%A8"><span class="toc-number">16.</span> <span class="toc-text">重大更改和弃用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E8%A6%81%E6%B1%82"><span class="toc-number">16.1.</span> <span class="toc-text">运行时要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lib-d-ts%E5%8F%98%E5%8C%96"><span class="toc-number">16.2.</span> <span class="toc-text">lib.d.ts变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E9%87%8D%E5%A4%A7%E5%8F%98%E6%9B%B4"><span class="toc-number">16.3.</span> <span class="toc-text">API 重大变更</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%AD%E7%A6%81%E6%AD%A2%E7%9A%84%E9%9A%90%E5%BC%8F%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">16.4.</span> <span class="toc-text">关系运算符中禁止的隐式强制转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%A4%A7%E4%BF%AE"><span class="toc-number">16.5.</span> <span class="toc-text">枚举大修</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%9B%B4%E5%87%86%E7%A1%AE%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5-experimentalDecorators"><span class="toc-number">16.6.</span> <span class="toc-text">对构造函数中的参数装饰器进行更准确的类型检查--experimentalDecorators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%83%E7%94%A8%E5%92%8C%E9%BB%98%E8%AE%A4%E6%9B%B4%E6%94%B9"><span class="toc-number">16.7.</span> <span class="toc-text">弃用和默认更改</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E4%B8%80%E6%AD%A5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">17.</span> <span class="toc-text">下一步是什么？</span></a></li></ol></nav></div></aside><main class="main" role="main"><div class="content"><article id="post-typescript" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">[译] TypeScript 5.0 发布</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/2023/03/19/typescript/" class="article-date"><time datetime="2023-03-19T04:00:00.000Z" itemprop="datePublished">2023-03-19</time> </a></span><span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/">外文翻译</a> </span><span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link-link" href="/tags/typescript/" rel="tag">typescript</a>, <a class="article-tag-link-link" href="/tags/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/" rel="tag">外文翻译</a> </span><span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden="true"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span> </span></span><span class="post-comment"><i class="icon icon-comment"></i> <a href="/2023/03/19/typescript/#comments" class="article-comment-link">评论</a></span> <span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 11.1k(字)</span> <span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 46(分)</span></div></div><div class="article-entry marked-body" itemprop="articleBody"><blockquote><p><em>原文地址：</em><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/">Announcing TypeScript 5.0</a></p><p>2023.3.16 by Daniel Rosenwasser and the TypeScript Team</p></blockquote><p>今天，我们很高兴地宣布 TypeScript 5.0 的发布！</p><p>此版本带来了许多新功能，同时旨在使 TypeScript 更小、更简单、更快。我们已经实施了新的装饰器标准，添加了更好地支持 Node 和 bundlers 中的 ESM 项目的功能，为库作者提供了控制泛型推理的新方法，扩展了我们的 JSDoc 功能，简化了配置，并进行了许多其他改进。</p><p>如果您还不熟悉 TypeScript，它是一种基于 JavaScript 的语言，通过添加类型语法来进行类型检查。类型检查可以帮助发现许多常见错误，从错别字到逻辑错误。将类型引入 JavaScript 还使我们能够构建出色的工具，因为类型可以在您喜欢的编辑器中支持代码补全、直接定义和重构等功能。事实上，如果您使用过 Visual Studio 或 VS Code 等编辑器，TypeScript 已经提供了 JavaScript 体验！您可以在 <a target="_blank" rel="noopener" href="https://typescriptlang.org/">https://typescriptlang.org</a> 上了解这门语言。</p><p>但是，如果您已经熟悉 TypeScript，也不用担心！5.0 不是破坏性版本，你所知道的一切仍然适用。虽然 TypeScript 5.0 包括正确性更改和一些不常用选项的弃用，但我们相信大多数开发人员都会有与以前版本类似的升级体验。</p><p>要开始使用 TypeScript 5.0，您可以通过 <a target="_blank" rel="noopener" href="https://www.nuget.org/packages/Microsoft.TypeScript.MSBuild">NuGet</a>获取它，或者使用 npm 和下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D typescript</span><br></pre></td></tr></table></figure><p>你也可以按照指示在 <a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/typescript/typescript-compiling#_using-the-workspace-version-of-typescript">Visual Studio Code</a> 中使用新版本的 TypeScript 的说明进行操作。</p><p>这是 TypeScript 5.0 中新功能的快速列表！</p><ul><li><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#decorators">装饰器</a></li><li><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#const-type-parameters"><code>const</code> 泛型参数</a></li><li><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#supporting-multiple-configuration-files-in-extends"><code>extends</code> 支持多个配置文件</a></li><li><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#all-enums-are-union-enums">所有的枚举都是联合枚举</a></li><li><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#moduleresolution-bundler"><code>--moduleResolution 配置新增 bundler 支持</code></a></li><li><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#resolution-customization-flags">自定义解析标志</a></li><li><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#verbatimmodulesyntax"><code>--verbatimModuleSyntax</code></a></li><li><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#support-for-export-type">支持 <code>export type *</code></a></li><li><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#satisfies-support-in-jsdoc">JSDoc 支持 <code>@satisfies</code></a></li><li><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#overload-support-in-jsdoc">JSDoc 支持 <code>@overload</code></a></li><li><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#passing-emit-specific-flags-under-build">运行 tsc <code>--build</code> 可以传入的新指令</a></li><li><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#case-insensitive-import-sorting-in-editors">编辑器中不区分大小写的导入排序</a></li><li><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#exhaustive-switch-case-completions"><code>switch</code>&#x2F;<code>case</code> 语法补足</a></li><li><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#speed-memory-and-package-size-optimizations">速度、内存和包大小优化</a></li><li><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#breaking-changes-and-deprecations">重大更改和弃用</a></li><li><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#whats-next">下一步是什么？</a></li></ul><h2 id="自-Beta-和-RC-以来有什么新功能？"><a href="#自-Beta-和-RC-以来有什么新功能？" class="headerlink" title="自 Beta 和 RC 以来有什么新功能？"></a>自 Beta 和 RC 以来有什么新功能？</h2><p>自 <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/">beta 版</a>发布以来， TypeScript 5.0 有几个显著的变化。</p><p>自 TypeScript 5.0 Beta 以来，一个新区别是 TypeScript 允许将<a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#decorators">装饰器</a>放置在 <code>export</code> 和 <code>export default</code> 之前或之后。这一变化反映了 TC39（ECMAScript&#x2F;JavaScript 的标准机构）内部的讨论和共识。</p><p>另一个是<a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#moduleresolution-bundler">新的 <code>bundler</code> 模块解析选项</a>只能在 <code>--module</code> 选项设置为 <code>esnext</code> 时使用。这样做是为了确保在输入文件中写入的 <code>import</code> 语句不会在捆绑器解析它们之前转换为 <code>require</code> 调用，无论捆绑器或加载器是否遵从 TypeScript 的 <code>module</code> 选项。我们还在这些发布说明中提供了一些上下文，建议大多数库作者坚持使用 <code>node16</code> or <code>nodenext</code>。</p><p>虽然 TypeScript 5.0 Beta 附带了此功能，但我们没有记录我们在编辑器场景中支持不<a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#case-insensitive-import-sorting-in-editors">区分大小写的导入排序</a>的工作。这部分是因为用于自定义的 UX 仍在讨论中，但默认情况下，TypeScript 现在应该可以更好地与您的其他工具一起使用。</p><p><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-rc/">自我们的 RC 以来</a>，我们最显著的变化是 TypeScript 5.0 现在在 <code>package.json</code> 中指定了 Node.js 的最低版本为 <code>12.20</code>。 我们还发布了<a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/typescripts-migration-to-modules/">一篇关于 TypeScript 5.0 向 modules 迁移的文章</a>，并提供了链接。</p><p>自 TypeScript 5.0 Beta 和 RC 发布以来，<a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#speed-memory-and-package-size-optimizations">速度基准和包大小增量</a>的具体数字也进行了调整，尽管噪音一直是运行过程中的一个因素。为了清晰起见，还对一些基准的名称进行了调整，包大小的改进也被移至单独的图表中。</p><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器是即将推出的 ECMAScript 功能，它允许我们以可重用的方式自定义类及其成员。</p><p>让我们思考以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    greet() &#123;</span><br><span class="line">        console.log(`Hello, my name is $&#123;this.name&#125;.`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">const p = new Person(&quot;Ron&quot;);</span><br><span class="line">p.greet();</span><br></pre></td></tr></table></figure><p><code>greet</code> 这里很简单，但让我们想象它更复杂——也许它执行一些异步逻辑，它是递归的，它有副作用等等。不管你想象的是哪种场景，假设你抛出了一些 <code>console.log</code> 调用来帮助调试 <code>greet</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    greet() &#123;</span><br><span class="line">        console.log(&quot;LOG: Entering method.&quot;);</span><br><span class="line">​</span><br><span class="line">        console.log(`Hello, my name is $&#123;this.name&#125;.`);</span><br><span class="line">​</span><br><span class="line">        console.log(&quot;LOG: Exiting method.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种模式相当普遍。如果有一种方法我们可以为每种方法做到这一点，那就太好了！</p><p>这就是装饰器的用武之地。我们可以编写一个 <code>loggedMethod</code> 的函数，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function loggedMethod(originalMethod: any, _context: any) &#123;</span><br><span class="line">​</span><br><span class="line">    function replacementMethod(this: any, ...args: any[]) &#123;</span><br><span class="line">        console.log(&quot;LOG: Entering method.&quot;)</span><br><span class="line">        const result = originalMethod.call(this, ...args);</span><br><span class="line">        console.log(&quot;LOG: Exiting method.&quot;)</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    return replacementMethod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“这些 <code>any</code> 都是怎么回事？这是什么，<code>any</code>Script！？”</p><p>请耐心等待——我们暂时保持简单，以便我们可以专注于此函数在做什么。请注意，<code>loggedMethod</code> 接收原始方法 ( <code>originalMethod</code>) 并返回一个函数</p><ol><li>输出“Entering…”日志</li><li><code>this</code> 将其所有参数传递给原始方法</li><li>输出一条“Exiting…”日志，并且</li><li>返回原始方法返回的任何内容。</li></ol><p>现在我们可以使用 <code>loggedMethod</code> 来装饰方法 <code>greet</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    @loggedMethod</span><br><span class="line">    greet() &#123;</span><br><span class="line">        console.log(`Hello, my name is $&#123;this.name&#125;.`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">const p = new Person(&quot;Ron&quot;);</span><br><span class="line">p.greet();</span><br><span class="line">​</span><br><span class="line">// Output:</span><br><span class="line">//</span><br><span class="line">//   LOG: Entering method.</span><br><span class="line">//   Hello, my name is Ron.</span><br><span class="line">//   LOG: Exiting method.</span><br></pre></td></tr></table></figure><p>我们只是在 <code>greet</code> 上面使用了 <code>loggedMethod</code> 作为装饰器 ——注意我们把它写成了 <code>@loggedMethod</code>。当我们这样做时，它会被 target 方法和 context 对象调用。因为 <code>loggedMethod</code> 返回了一个新函数，该函数替换了<code>greet</code>.</p><p>我们还没有提到它，而是 <code>loggedMethod</code> 用第二个参数定义的。它被称为“上下文对象”，它有一些关于如何声明修饰方法的有用信息——比如它是 <code>#private</code> 成员还是静态成员，或者方法的名称是什么。让我们重写 <code>loggedMethod</code> 以利用它并打印出被装饰的方法的名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function loggedMethod(originalMethod: any, context: ClassMethodDecoratorContext) &#123;</span><br><span class="line">    const methodName = String(context.name);</span><br><span class="line">​</span><br><span class="line">    function replacementMethod(this: any, ...args: any[]) &#123;</span><br><span class="line">        console.log(`LOG: Entering method &#x27;$&#123;methodName&#125;&#x27;.`)</span><br><span class="line">        const result = originalMethod.call(this, ...args);</span><br><span class="line">        console.log(`LOG: Exiting method &#x27;$&#123;methodName&#125;&#x27;.`)</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    return replacementMethod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在使用 context 参数——它是 <code>loggedMethod</code> 中第一个具有比 <code>any</code> 和 <code>any[]</code> 更严格的参数类型。TypeScript 提供了一个名为 <code>ClassMethodDecoratorContext</code> 的类型，他对方法装饰器所接收的上下文对象进行建模。</p><p>除了元数据之外，方法的上下文对象还有一个有用的函数，称为 <code>addInitializer</code>。 这是一种挂钩到构造函数开头的方法（如果我们使用<code>static</code>，则挂钩到类本身的初始化）。</p><p>例如——在 JavaScript 中，通常会编写类似以下模式的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">​</span><br><span class="line">        this.greet = this.greet.bind(this);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    greet() &#123;</span><br><span class="line">        console.log(`Hello, my name is $&#123;this.name&#125;.`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，<code>greet</code> 可以声明为初始化为箭头函数的属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    greet = () =&gt; &#123;</span><br><span class="line">        console.log(`Hello, my name is $&#123;this.name&#125;.`);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写此代码是为了确保在 <code>greet</code> 作为独立函数调用或作为回调传递 <code>this</code> 时不会重新绑定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const greet = new Person(&quot;Ron&quot;).greet;</span><br><span class="line">​</span><br><span class="line">// We don&#x27;t want this to fail!</span><br><span class="line">greet();</span><br></pre></td></tr></table></figure><p>我们可以编写一个装饰器，使用 <code>addInitializer</code> 在构造函数中调用 <code>bind</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function bound(originalMethod: any, context: ClassMethodDecoratorContext) &#123;</span><br><span class="line">    const methodName = context.name;</span><br><span class="line">    if (context.private) &#123;</span><br><span class="line">        throw new Error(`&#x27;bound&#x27; cannot decorate private properties like $&#123;methodName as string&#125;.`);</span><br><span class="line">    &#125;</span><br><span class="line">    context.addInitializer(function () &#123;</span><br><span class="line">        this[methodName] = this[methodName].bind(this);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bound</code> 不返回任何东西——所以当它装饰一个方法时，它会保留原来的方法。相反，它将在任何其他字段初始化之前添加逻辑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    @bound</span><br><span class="line">    @loggedMethod</span><br><span class="line">    greet() &#123;</span><br><span class="line">        console.log(`Hello, my name is $&#123;this.name&#125;.`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">const p = new Person(&quot;Ron&quot;);</span><br><span class="line">const greet = p.greet;</span><br><span class="line">​</span><br><span class="line">// Works!</span><br><span class="line">greet();</span><br></pre></td></tr></table></figure><p>请注意，我们堆叠了两个装饰器—— <code>@bound</code> 和 <code>@loggedMethod</code>。这些装饰以“相反的顺序”运行。即 <code>@loggedMethod</code> 装饰原始方法 <code>greet</code>，<code>@bound</code> 装饰 <code>@loggedMethod</code> 的结果 。在此示例中，这并不重要——但如果您的装饰器有副作用或期望特定顺序，则可能会发生这种情况。</p><p>同样值得注意的是：根据你喜欢代码风格，可以将这些装饰器放在同一行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@bound @loggedMethod greet() &#123;</span><br><span class="line">   console.log(`Hello, my name is $&#123;this.name&#125;.`);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能不太明显的是，我们甚至可以创建<em>返回</em>装饰器函数的函数。这使得定制最终的装饰器成为可能。如果我们愿意，我们可以让 <code>loggedMethod</code> 返回一个装饰器并自定义它记录消息的方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function loggedMethod(headMessage = &quot;LOG:&quot;) &#123;</span><br><span class="line">    return function actualDecorator(originalMethod: any, context: ClassMethodDecoratorContext) &#123;</span><br><span class="line">        const methodName = String(context.name);</span><br><span class="line">​</span><br><span class="line">        function replacementMethod(this: any, ...args: any[]) &#123;</span><br><span class="line">            console.log(`$&#123;headMessage&#125; Entering method &#x27;$&#123;methodName&#125;&#x27;.`)</span><br><span class="line">            const result = originalMethod.call(this, ...args);</span><br><span class="line">            console.log(`$&#123;headMessage&#125; Exiting method &#x27;$&#123;methodName&#125;&#x27;.`)</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        return replacementMethod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们这样做，我们必须在使用 <code>loggedMethod</code> 作为装饰器之前调用它。然后我们可以传入任何字符串作为输出到控制台的日志的前缀。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    @loggedMethod(&quot;&quot;)</span><br><span class="line">    greet() &#123;</span><br><span class="line">        console.log(`Hello, my name is $&#123;this.name&#125;.`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">const p = new Person(&quot;Ron&quot;);</span><br><span class="line">p.greet();</span><br><span class="line">​</span><br><span class="line">// Output:</span><br><span class="line">//</span><br><span class="line">//    Entering method &#x27;greet&#x27;.</span><br><span class="line">//   Hello, my name is Ron.</span><br><span class="line">//    Exiting method &#x27;greet&#x27;.</span><br></pre></td></tr></table></figure><p>装饰器不仅仅可以用在方法上！它们可用于属性&#x2F;字段、getter、setter 和自动访问器。甚至类本身也可以为子类化和注册之类的事情进行装饰。</p><p>要深入了解有关装饰器的更多信息，您可以阅读 <a target="_blank" rel="noopener" href="https://2ality.com/2022/10/javascript-decorators.html">Axel Rauschmayer 的详尽摘要</a>。</p><p>有关涉及的更改的更多信息，您可以<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/50820">查看原始 pull request</a>。</p><h3 id="与实验性遗留装饰器的差异"><a href="#与实验性遗留装饰器的差异" class="headerlink" title="与实验性遗留装饰器的差异"></a>与实验性遗留装饰器的差异</h3><p>如果您已经使用 TypeScript 一段时间，您可能会意识到它多年来一直支持“实验性”装饰器。虽然这些实验性装饰器非常有用，但它们模拟了一个更旧版本的装饰器提案，并且始终需要一个名为 <code>--experimentalDecorators</code>。 任何在没有此标志的情况下尝试在 TypeScript 中使用装饰器都会提示错误消息。</p><p><code>--experimentalDecorators</code> 在可预见的未来将继续存在；然而，如果没有这个标志，装饰器现在将成为所有新代码的有效语法。在之外<code>--experimentalDecorators</code>，它们将以不同方式进行类型检查和释放。类型检查规则和 emit 完全不同，虽然<em>可以</em>编写装饰器来支持旧的和新的装饰器行为，但任何现有的装饰器函数都不太可能这样做。</p><p>这个新的装饰器提案与 <code>--emitDecoratorMetadata</code> 不兼容，它不允许装饰参数。未来的 ECMAScript 提案可能会帮助弥合这一差距。</p><p>最后一点：除了允许将装饰器放在 <code>export</code> 关键字之前，装饰器提案现在还提供了在 <code>export</code> 或 <code>export default</code> 之后放置装饰器的选项。唯一的例外是不允许混合使用这两种样式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//  allowed</span><br><span class="line">@register export default class Foo &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">//  also allowed</span><br><span class="line">export default @register class Bar &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">//  error - before *and* after is not allowed</span><br><span class="line">@before export @after class Bar &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写类型良好的装饰器"><a href="#编写类型良好的装饰器" class="headerlink" title="编写类型良好的装饰器"></a>编写类型良好的装饰器</h3><p>上面的 <code>loggedMethod</code> 和 <code>bound</code> 装饰器示例有意简单化并省略了很多关于类型的细节。</p><p>键入装饰器可能相当复杂。例如，上面的类型正确的版本 <code>loggedMethod</code> 可能看起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function loggedMethod&lt;This, Args extends any[], Return&gt;(</span><br><span class="line">    target: (this: This, ...args: Args) =&gt; Return,</span><br><span class="line">    context: ClassMethodDecoratorContext&lt;This, (this: This, ...args: Args) =&gt; Return&gt;</span><br><span class="line">) &#123;</span><br><span class="line">    const methodName = String(context.name);</span><br><span class="line">​</span><br><span class="line">    function replacementMethod(this: This, ...args: Args): Return &#123;</span><br><span class="line">        console.log(`LOG: Entering method &#x27;$&#123;methodName&#125;&#x27;.`)</span><br><span class="line">        const result = target.call(this, ...args);</span><br><span class="line">        console.log(`LOG: Exiting method &#x27;$&#123;methodName&#125;&#x27;.`)</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    return replacementMethod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们必须使用类型参数 <code>This</code>、<code>Args</code> 和 <code>Return</code> 分别定义 <code>this</code> 的类型、参数和原始方法的返回类型。</p><p>装饰器函数定义的具体复杂程度取决于您要保证的内容。请记住，您的装饰器将被使用的次数多于它们被编写的次数，因此类型良好的版本通常更可取——但显然需要与可读性进行权衡，因此请尽量保持简单。</p><p>将来会提供更多关于编写装饰器的文档——但<a target="_blank" rel="noopener" href="https://2ality.com/2022/10/javascript-decorators.html">这篇文章</a>应该有大量关于装饰器机制的细节。</p><h2 id="const-泛型参数"><a href="#const-泛型参数" class="headerlink" title="const 泛型参数"></a><code>const</code> 泛型参数</h2><p>在推断对象的类型时，TypeScript 通常会选择一种通用的类型。例如，在本例中，<code>names</code> 的推断类型是 <code>string[]</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type HasNames = &#123; readonly names: string[] &#125;;</span><br><span class="line">function getNamesExactly&lt;T extends HasNames&gt;(arg: T): T[&quot;names&quot;] &#123;</span><br><span class="line">    return arg.names;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">// Inferred type: string[]</span><br><span class="line">const names = getNamesExactly(&#123; names: [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;]&#125;);</span><br></pre></td></tr></table></figure><p>通常这样做的目的是使突变成为可能。</p><p>但是，根据 <code>getNamesExactly</code> 的具体功能和用途，通常需要更具体的类型。</p><p>到目前为止，API 作者通常不得不建在某些地方添加 <code>as const</code> 以实现所需的推理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// The type we wanted:</span><br><span class="line">//    readonly [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;]</span><br><span class="line">// The type we got:</span><br><span class="line">//    string[]</span><br><span class="line">const names1 = getNamesExactly(&#123; names: [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;]&#125;);</span><br><span class="line">​</span><br><span class="line">// Correctly gets what we wanted:</span><br><span class="line">//    readonly [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;]</span><br><span class="line">const names2 = getNamesExactly(&#123; names: [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;]&#125; as const);</span><br></pre></td></tr></table></figure><p>这可能很麻烦且容易忘记。在 TypeScript 5.0 中，您现在可以将 <code>const</code> 修饰符添加到类型参数声明中，以使<code>const</code>-like 推理成为默认值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type HasNames = &#123; names: readonly string[] &#125;;</span><br><span class="line">function getNamesExactly&lt;const T extends HasNames&gt;(arg: T): T[&quot;names&quot;] &#123;</span><br><span class="line">//                       ^^^^^</span><br><span class="line">    return arg.names;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">// Inferred type: readonly [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;]</span><br><span class="line">// Note: Didn&#x27;t need to write &#x27;as const&#x27; here</span><br><span class="line">const names = getNamesExactly(&#123; names: [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;] &#125;);</span><br></pre></td></tr></table></figure><p>请注意，<code>const</code> 修饰符不<em>拒绝</em>可变值，也不需要不可变约束。使用可变类型约束可能会产生令人惊讶的结果。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">declare function fnBad&lt;const T extends string[]&gt;(args: T): void;</span><br><span class="line">​</span><br><span class="line">// &#x27;T&#x27; is still &#x27;string[]&#x27; since &#x27;readonly [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#x27; is not assignable to &#x27;string[]&#x27;</span><br><span class="line">fnBad([&quot;a&quot;, &quot;b&quot; ,&quot;c&quot;]);</span><br></pre></td></tr></table></figure><p>在这里，推断的候选项 <code>T</code> 是 <code>readonly [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code>，并且 <code>readonly</code> 不能在需要可变数组的地方使用数组。在这种情况下，推理回退到约束条件，数组被视为 <code>string[]</code>，并且调用仍然成功进行。</p><p>此函数的更好定义应该使用 <code>readonly string[]</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">declare function fnGood&lt;const T extends readonly string[]&gt;(args: T): void;</span><br><span class="line">​</span><br><span class="line">// T is readonly [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fnGood([&quot;a&quot;, &quot;b&quot; ,&quot;c&quot;]);</span><br></pre></td></tr></table></figure><p>同样，请记住修饰符 <code>const</code> 仅影响在调用中编写的对象、数组和原始表达式的推断，因此不会（或不能）修改的参数不会看到 <code>as const</code> 任何行为变化:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">declare function fnGood&lt;const T extends readonly string[]&gt;(args: T): void;</span><br><span class="line">const arr = [&quot;a&quot;, &quot;b&quot; ,&quot;c&quot;];</span><br><span class="line">​</span><br><span class="line">// &#x27;T&#x27; is still &#x27;string[]&#x27;-- the &#x27;const&#x27; modifier has no effect here</span><br><span class="line">fnGood(arr);</span><br></pre></td></tr></table></figure><p>有关更多详细信息，<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/51865">请参阅拉取请求</a>和（<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/30680">第一个</a>和<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/41114">第二个</a>）激励问题。</p><h2 id="extends-支持多个配置文件"><a href="#extends-支持多个配置文件" class="headerlink" title="extends 支持多个配置文件"></a><code>extends</code> 支持多个配置文件</h2><p><code>tsconfig.json</code> 管理多个项目时，拥有一个其他文件可以扩展的“基本”配置文件会很有帮助。这就是为什么 TypeScript 支持 <code>extends</code>从 <code>compilerOptions</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// packages/front-end/src/tsconfig.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;extends&quot;: &quot;../../../tsconfig.base.json&quot;,</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;outDir&quot;: &quot;../lib&quot;,</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，在某些情况下，您可能希望从多个配置文件进行扩展。例如，假设使用<a target="_blank" rel="noopener" href="https://github.com/tsconfig/bases">发送到 npm 的 TypeScript 基本配置文件</a>。如果您希望所有项目也使用 npm 包中的选项 <code>@tsconfig/strictest</code>，那么有一个简单的解决方案：扩展 <code>tsconfig.base.json</code> 自<code>@tsconfig/strictest</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// tsconfig.base.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;extends&quot;: &quot;@tsconfig/strictest/tsconfig.json&quot;,</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这在一定程度上起作用。<em>如果</em>您有任何项目<em>不想</em>使用 <code>@tsconfig/strictest</code>，他们必须手动禁用这些选项，或者创建一个短度的 <code>tsconfig.base.json</code> 版本，该版本不扩展 <code>@tsconfig/strictest</code></p><p>为了在此处提供更多灵活性，Typescript 5.0 现在允许该 <code>extends</code> 字段采用多个条目。例如，在这个配置文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;extends&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;],</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写这个有点像 <code>c</code> 直接扩展，其中 <code>c</code> extends <code>b</code> 和 <code>b</code> extends <code>a</code>。如果任何字段“冲突”，则后一个条目获胜。</p><p>所以在下面的例子中， 和 <code>strictNullChecks</code> 都 <code>noImplicitAny</code>在最终的 <code>tsconfig.json</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// tsconfig1.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;strictNullChecks&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">// tsconfig2.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;noImplicitAny&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">// tsconfig.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;extends&quot;: [&quot;./tsconfig1.json&quot;, &quot;./tsconfig2.json&quot;],</span><br><span class="line">    &quot;files&quot;: [&quot;./index.ts&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再举一个例子，我们可以用下面的方式重写我们原来的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// packages/front-end/src/tsconfig.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;extends&quot;: [&quot;@tsconfig/strictest/tsconfig.json&quot;, &quot;../../../tsconfig.base.json&quot;],</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;outDir&quot;: &quot;../lib&quot;,</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有关更多详细信息，<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/50403">请阅读有关原始拉取请求的更多信息</a>。</p><h2 id="所有枚举都是联合枚举"><a href="#所有枚举都是联合枚举" class="headerlink" title="所有枚举都是联合枚举"></a>所有枚举都是联合枚举</h2><p>当 TypeScript 最初引入枚举时，它们只不过是一组具有相同类型的数字常量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum E &#123;</span><br><span class="line">    Foo = 10,</span><br><span class="line">    Bar = 20,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>E.Foo</code> 和 <code>E.Bar</code> 的唯一特别之处在于它们可以赋值给除 <code>E</code> 类型之外的任何类型。除此之外，他们几乎只是 <code>number</code>s。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function takeValue(e: E) &#123;&#125;</span><br><span class="line">​</span><br><span class="line">takeValue(E.Foo); // works</span><br><span class="line">takeValue(123); // error!</span><br></pre></td></tr></table></figure><p>直到 TypeScript 2.0 引入了枚举文字类型，枚举才变得更加特殊。枚举文字类型为每个枚举成员提供了自己的类型，并将枚举本身变成了每个成员类型的<em>联合</em>。它们还允许我们仅引用枚举类型的一个子集，并缩小这些类型的范围。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Color is like a union of Red | Orange | Yellow | Green | Blue | Violet</span><br><span class="line">enum Color &#123;</span><br><span class="line">    Red, Orange, Yellow, Green, Blue, /* Indigo */, Violet</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">// Each enum member has its own type that we can refer to!</span><br><span class="line">type PrimaryColor = Color.Red | Color.Green | Color.Blue;</span><br><span class="line">​</span><br><span class="line">function isPrimaryColor(c: Color): c is PrimaryColor &#123;</span><br><span class="line">    // Narrowing literal types can catch bugs.</span><br><span class="line">    // TypeScript will error here because</span><br><span class="line">    // we&#x27;ll end up comparing &#x27;Color.Red&#x27; to &#x27;Color.Green&#x27;.</span><br><span class="line">    // We meant to use ||, but accidentally wrote &amp;&amp;.</span><br><span class="line">    return c === Color.Red &amp;&amp; c === Color.Green &amp;&amp; c === Color.Blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为每个枚举成员赋予其自己的类型的一个问题是，这些类型在某些部分与成员的实际值相关联。在某些情况下，无法计算该值——例如，枚举成员可以通过函数调用进行初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum E &#123;</span><br><span class="line">    Blah = Math.random()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当 TypeScript 遇到这些问题时，它都会悄悄退出并使用旧的枚举策略。这意味着放弃联合和文字类型的所有优势。</p><p>TypeScript 5.0 通过为每个计算成员创建唯一类型，设法将所有枚举变成联合枚举。这意味着现在可以缩小所有枚举的范围，并将其成员也作为类型引用。</p><p>有关此更改的更多详细信息，您可以<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/50528">阅读 GitHub 上的详细信息</a>。</p><h2 id="moduleResolution-新增-bundler-支持"><a href="#moduleResolution-新增-bundler-支持" class="headerlink" title="--moduleResolution 新增 bundler 支持"></a><code>--moduleResolution 新增 bundler 支持</code></h2><p>TypeScript 4.7 在 <code>--module</code> 和 <code>--moduleResolution</code> 设置中引入了 <code>node16</code> 和 <code>nodenext</code> 选项。这些选项的目的是更好地模拟 Node.js 中 ECMAScript 模块的精确查找规则；然而，这种模式有很多限制，其他工具并没有真正强制执行。</p><p>例如，在 Node.js 的 ECMAScript 模块中，任何相对导入都需要包含文件扩展名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// entry.mjs</span><br><span class="line">import * as utils from &quot;./utils&quot;;     //  wrong - we need to include the file extension.</span><br><span class="line">​</span><br><span class="line">import * as utils from &quot;./utils.mjs&quot;; //  works</span><br></pre></td></tr></table></figure><p>在 Node.js 和浏览器中这样做有一定的原因——它使文件查找更快，并且更适合原始文件服务器。但是对于许多使用捆绑器等工具的开发人员来说，<code>node16</code>&#x2F;<code>nodenext</code>设置很麻烦，因为捆绑器没有这些限制中的大部分。在某些方面，<code>node</code>解析模式对任何使用捆绑器的人来说都更好。</p><p>但在某些方面，原有的 <code>node</code> 解决模式已经落伍了。大多数现代捆绑器在 Node.js 中使用 ECMAScript 模块和 CommonJS 查找规则的融合。例如，无扩展名的导入就像在 CommonJS 中一样工作得很好，但是在查看包的 <a target="_blank" rel="noopener" href="https://nodejs.org/api/packages.html#nested-conditions"><code>export</code>条件</a>时，他们会更喜欢 ECMAScript 文件中的 <code>import</code> 条件。</p><p>为了模拟打包器的工作方式，TypeScript 现在引入了一种新策略：<code>--moduleResolution bundler</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;target&quot;: &quot;esnext&quot;,</span><br><span class="line">        &quot;moduleResolution&quot;: &quot;bundler&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您正在使用像 Vite、esbuild、swc、Webpack、Parcel 和其他实施混合查找策略的现代捆绑器，那么新选项 <code>bundler</code> 应该非常适合您。</p><p>另一方面，如果您正在编写一个打算在 npm 上发布的库，则使用该 <code>bundler</code> 选项可以隐藏兼容性问题，这些问题可能会出现在您<em>不</em>使用捆绑器的用户身上。因此，在这些情况下，使用 <code>node16</code> 或 <code>nodenext</code> 解决方案可能是更好的途径。</p><p>要了解更多信息 <code>--moduleResolution bundler</code>，<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/51669">请查看实施拉取请求</a>。</p><h2 id="自定义解析标志"><a href="#自定义解析标志" class="headerlink" title="自定义解析标志"></a>自定义解析标志</h2><p>JavaScript 工具现在可以模拟“混合”解析规则，就像 <code>bundler</code> 我们上面描述的模式一样。由于工具的支持可能略有不同，TypeScript 5.0 提供了启用或禁用一些功能的方法，这些功能可能适用于您的配置，也可能不适用于您的配置。</p><h3 id="allowImportingTsExtensions"><a href="#allowImportingTsExtensions" class="headerlink" title="allowImportingTsExtensions"></a><code>allowImportingTsExtensions</code></h3><p><code>--allowImportingTsExtensions</code> 允许使用特定于 TypeScript 的扩展名（如<code>.ts</code>、<code>.mts</code>或<code>.tsx</code>）。</p><p>此标志仅在 <code>--noEmit</code> 或 <code>--emitDeclarationOnly</code> 启用时才被允许，因为这些导入路径在运行时无法在 JavaScript 输出文件中解析。这里的期望是您的解析器（例如您的捆绑器、运行时或其他一些工具）将使这些 <code>.ts</code> 文件之间的导入工作。</p><h3 id="resolvePackageJsonExports"><a href="#resolvePackageJsonExports" class="headerlink" title="resolvePackageJsonExports"></a><code>resolvePackageJsonExports</code></h3><p><code>--resolvePackageJsonExports</code> 强制 TypeScript 解析 <a target="_blank" rel="noopener" href="https://nodejs.org/api/packages.html#exports"><code>package.json</code>的 <code>exports</code> 字段</a>，如果曾经从 <code>node_modules</code> 中的读取过json文件。</p><p>当配置项 <code>--modulerresolve</code> 为 <code>node16</code>、<code>nodenext</code> 和 <code>bundler</code> 时，该选项默认为true。</p><h3 id="resolvePackageJsonImports"><a href="#resolvePackageJsonImports" class="headerlink" title="resolvePackageJsonImports"></a><code>resolvePackageJsonImports</code></h3><p><code>--resolvePackageJsonImports</code> 强制 TypeScript 在从其祖先目录包含 package.json 的文件执行以 # 开头的查找时查询 package.json 文件的导入字段。</p><p>当配置项 <code>--modulerresolve</code> 为 <code>node16</code>、<code>nodenext</code> 和 <code>bundler</code> 时，该选项默认为true。</p><h3 id="allowArbitraryExtensions"><a href="#allowArbitraryExtensions" class="headerlink" title="allowArbitraryExtensions"></a><code>allowArbitraryExtensions</code></h3><p>在 TypeScript 5.0 中，当导入路径以不是已知 JavaScript 或 TypeScript 文件扩展名的扩展名结尾时，编译器将以 <code>&#123;file basename&#125;.d.&#123;extension&#125;.ts</code>。 例如，如果您在捆绑项目中使用 CSS 加载器，您可能希望为这些样式表编写（或生成）声明文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* app.css */</span><br><span class="line">.cookie-banner &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br><span class="line">// app.d.css.ts</span><br><span class="line">declare const css: &#123;</span><br><span class="line">  cookieBanner: string;</span><br><span class="line">&#125;;</span><br><span class="line">export default css;</span><br><span class="line">// App.tsx</span><br><span class="line">import styles from &quot;./app.css&quot;;</span><br><span class="line">​</span><br><span class="line">styles.cookieBanner; // string</span><br></pre></td></tr></table></figure><p>默认情况下，此导入会引发错误，让您知道 TypeScript 不理解此文件类型，并且您的运行时可能不支持导入它。但是，如果您已配置运行时或捆绑程序来处理它，则可以使用新的 <code>--allowArbitraryExtensions</code> 编译器选项来抑制错误。</p><p>请注意，从历史上看，通过添加名为 <code>app.css.d.ts</code> 的声明文件而不是 <code>app.d.css.ts</code> ，通常可以达到类似的效果 ——然而，这只是通过 Node 对 CommonJS 的 <code>require</code> 解析规则起作用。严格来说，前者被解释为一个名为<code>app.css.js</code> 的 JavaScript 文件的声明文件 。因为相对文件导入需要在 Node 的 ESM 支持中包含扩展名，所以 TypeScript 会在我们的示例中 <code>--moduleResolution node16</code> 在或 <code>nodenext</code> 下的 ESM 文件中出错 。</p><p>有关更多信息，请阅读<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/50133">此功能的提案</a>及其<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/51435">相应的拉取请求</a>。</p><h3 id="customConditions"><a href="#customConditions" class="headerlink" title="customConditions"></a><code>customConditions</code></h3><p><code>--customConditions</code> 接收一个附加条件列表，当 TypeScript 从 <code>package.json</code>的 <a target="_blank" rel="noopener" href="https://nodejs.org/api/packages.html#exports"><code>exports</code></a> 或 <a target="_blank" rel="noopener" href="https://nodejs.org/api/packages.html#imports"><code>imports</code></a> 字段解析时，这些条件将添加到解析器默认使用的任何现有条件中。</p><p>例如，当在 <code>tsconfig.json</code> 中设置此字段时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;target&quot;: &quot;es2022&quot;,</span><br><span class="line">        &quot;moduleResolution&quot;: &quot;bundler&quot;,</span><br><span class="line">        &quot;customConditions&quot;: [&quot;my-condition&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何时候在 <code>package.json</code> 中引用 <code>exports</code> 或 <code>imports</code> 字段时，TypeScript 都会考虑调用 <code>my-condition</code> 的条件。</p><p>因此，当从具有以下内容的包中导入时 <code>package.json</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">    &quot;exports&quot;: &#123;</span><br><span class="line">        &quot;.&quot;: &#123;</span><br><span class="line">            &quot;my-condition&quot;: &quot;./foo.mjs&quot;,</span><br><span class="line">            &quot;node&quot;: &quot;./bar.mjs&quot;,</span><br><span class="line">            &quot;import&quot;: &quot;./baz.mjs&quot;,</span><br><span class="line">            &quot;require&quot;: &quot;./biz.mjs&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TypeScript 将尝试查找与 <code>foo.mjs</code> 对应的文件。</p><p>该字段仅在 <code>--moduleResolution</code> 的 node16、nodenext 和 bundler 选项下有效</p><h2 id="verbatimModuleSyntax"><a href="#verbatimModuleSyntax" class="headerlink" title="--verbatimModuleSyntax"></a><code>--verbatimModuleSyntax</code></h2><p>默认情况下，TypeScript 会做一些叫做 <em>import elision</em> 的事情。基本上，如果你写类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Car &#125; from &quot;./car&quot;;</span><br><span class="line">​</span><br><span class="line">export function drive(car: Car) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TypeScript 检测到您只对类型使用导入，所以输出结果会将此导入代码删除。您的输出 JavaScript 可能看起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export function drive(car) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大多数时候这很好，因为如果 <code>Car</code> 不是从 <code>./car</code> 导出的值，我们将收到运行时错误。</p><p>但它确实为某些边缘情况增加了一层复杂性。例如，请注意没有像这样的语句 <code>import &quot;./car&quot;;</code>——导入被完全删除。这实际上对有无副作用的模块产生影响。</p><p>TypeScript 针对 JavaScript 的 emit 策略还有另外几层复杂性——导入省略并不总是由导入的使用方式驱动——它通常还会参考值的声明方式。所以并不总是很清楚是否像下面这样的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export &#123; Car &#125; from &quot;./car&quot;;</span><br></pre></td></tr></table></figure><p>应该保留或丢弃。如果 <code>Car</code> 用 <code>class</code> 之类的东西声明，那么它可以保存在生成的 JavaScript 文件中。但如果 <code>Car</code> 仅声明为 <code>type</code> 别名或 <code>interface</code>，则 JavaScript 文件 <code>Car</code> 根本不应导出。</p><p>虽然 TypeScript 可能能够根据来自跨文件的信息做出这些发出决定，但并非每个编译器都可以。</p><p>imports 和 exports 的修饰符 <code>type</code> 对这些情况有点帮助。我们可以明确指出导入或导出是否仅用于类型分析，并且可以通过使用修饰符将其完全删除到 JavaScript 文件中 <code>type</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// This statement can be dropped entirely in JS output</span><br><span class="line">import type * as car from &quot;./car&quot;;</span><br><span class="line">​</span><br><span class="line">// The named import/export &#x27;Car&#x27; can be dropped in JS output</span><br><span class="line">import &#123; type Car &#125; from &quot;./car&quot;;</span><br><span class="line">export &#123; type Car &#125; from &quot;./car&quot;;</span><br></pre></td></tr></table></figure><p><code>type</code> 修饰符本身并不是很有用——默认情况下，模块省略仍然会删除导入，并且没有什么强制您区分 <code>type</code> 普通导入和导出。所以 TypeScript 有标志 <code>--importsNotUsedAsValues</code> 来确保你使用 <code>type</code> 修饰符，<code>--preserveValueImports</code>以防止<em>某些</em>模块省略行为，并 <code>--isolatedModules</code> 确保你的 TypeScript 代码适用于不同的编译器。不幸的是，很难理解这 3 个标志的细节，并且仍然存在一些具有意外行为的边缘情况。</p><p><code>--verbatimModuleSyntax</code>TypeScript 5.0 引入了一个名为简化情况的新选项。规则要简单得多——任何没有 <code>type</code> 修饰符的导入或导出都会被保留。任何使用 <code>type</code> 修饰符的东西都会被完全丢弃。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Erased away entirely.</span><br><span class="line">import type &#123; A &#125; from &quot;a&quot;;</span><br><span class="line">​</span><br><span class="line">// Rewritten to &#x27;import &#123; b &#125; from &quot;bcd&quot;;&#x27;</span><br><span class="line">import &#123; b, type c, type d &#125; from &quot;bcd&quot;;</span><br><span class="line">​</span><br><span class="line">// Rewritten to &#x27;import &#123;&#125; from &quot;xyz&quot;;&#x27;</span><br><span class="line">import &#123; type xyz &#125; from &quot;xyz&quot;;</span><br></pre></td></tr></table></figure><p>有了这个新选项，所见即所得。</p><p>不过，当涉及到模块互操作时，这确实有一些影响。在此标志下，当您的设置或文件扩展名暗示不同的模块系统时，ECMAScript <code>import</code>s 和 <code>export</code>s 不会被重写为 <code>require</code> 调用。相反，你会得到一个错误。如果您需要发出使用 <code>require</code> 和 <code>module.exports</code> 的代码，则必须使用早于 ES2015 的 TypeScript 模块语法：</p><table><thead><tr><th>输入TypeScript</th><th>输出 JavaScript</th></tr></thead><tbody><tr><td><code>import foo = require(&quot;foo&quot;);</code></td><td><code>const foo = require(&quot;foo&quot;);</code></td></tr><tr><td><code>function foo() &#123;&#125; function bar() &#123;&#125; function baz() &#123;&#125; export = &#123; foo, bar, baz &#125;;</code></td><td><code>function foo() &#123;&#125; function bar() &#123;&#125; function baz() &#123;&#125; module.exports = &#123; foo, bar, baz &#125;;</code></td></tr></tbody></table><p>虽然这是一个限制，但它确实有助于使一些问题更加明显。例如，忘记在 <a target="_blank" rel="noopener" href="https://nodejs.org/api/packages.html#type"><code>package.json</code> 中设置 type 字段</a> 是很常见的。<code>--module node16</code>。因此，开发人员会在没有意识到的情况下开始编写 CommonJS 模块而不是 ES 模块，从而提供令人惊讶的查找规则和 JavaScript 输出。这个新标志确保您有意使用您正在使用的文件类型，因为语法是有意不同的。</p><p>因为 <code>--verbatimModuleSyntax</code> 提供了比 <code>--importsNotUsedAsValues</code> 和 <code>--preserveValueImports</code> 更一致的故事，所以这两个现有的标志已被弃用。</p><p>有关更多详细信息，请阅读<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/52203">原始拉取请求</a>及其<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/51479">提案问题</a>。</p><h2 id="支持-export-type"><a href="#支持-export-type" class="headerlink" title="支持 export type *"></a>支持 <code>export type *</code></h2><p>当 TypeScript 3.8 引入纯类型导入时，新语法不允许用于 <code>export * from &quot;module&quot;</code> 或 <code>export * as ns from &quot;module&quot;</code> 重新导出。TypeScript 5.0 添加了对这两种形式的支持：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// models/vehicles.ts</span><br><span class="line">export class Spaceship &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">// models/index.ts</span><br><span class="line">export type * as vehicles from &quot;./vehicles&quot;;</span><br><span class="line">​</span><br><span class="line">// main.ts</span><br><span class="line">import &#123; vehicles &#125; from &quot;./models&quot;;</span><br><span class="line">​</span><br><span class="line">function takeASpaceship(s: vehicles.Spaceship) &#123;</span><br><span class="line">  //  ok - `vehicles` only used in a type position</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">function makeASpaceship() &#123;</span><br><span class="line">  return new vehicles.Spaceship();</span><br><span class="line">  //         ^^^^^^^^</span><br><span class="line">  // &#x27;vehicles&#x27; cannot be used as a value because it was exported using &#x27;export type&#x27;.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/52217">在此处阅读有关实施的更多信息</a>。</p><h2 id="JSDoc-支持-satisfies"><a href="#JSDoc-支持-satisfies" class="headerlink" title="JSDoc 支持 @satisfies"></a>JSDoc 支持 <code>@satisfies</code></h2><p>TypeScript 4.9 引入了 <code>satisfies</code> 运算符。它确保表达式的类型兼容，而不影响类型本身。例如，让我们看下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">interface CompilerOptions &#123;</span><br><span class="line">    strict?: boolean;</span><br><span class="line">    outDir?: string;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">interface ConfigSettings &#123;</span><br><span class="line">    compilerOptions?: CompilerOptions;</span><br><span class="line">    extends?: string | string[];</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">let myConfigSettings = &#123;</span><br><span class="line">    compilerOptions: &#123;</span><br><span class="line">        strict: true,</span><br><span class="line">        outDir: &quot;../lib&quot;,</span><br><span class="line">        // ...</span><br><span class="line">    &#125;,</span><br><span class="line">​</span><br><span class="line">    extends: [</span><br><span class="line">        &quot;@tsconfig/strictest/tsconfig.json&quot;,</span><br><span class="line">        &quot;../../../tsconfig.base.json&quot;</span><br><span class="line">    ],</span><br><span class="line">​</span><br><span class="line">&#125; satisfies ConfigSettings;</span><br></pre></td></tr></table></figure><p>在这里，TypeScript 知道它 <code>myConfigSettings.extends</code> 是用数组声明的——因为在 <code>satisfies</code> 验证我们对象的类型时，它并没有直接将其更改为 <code>ConfigSettings</code> 并丢失信息。所以如果我们想映射过来 <code>extends</code>，那很好。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">declare function resolveConfig(configPath: string): CompilerOptions;</span><br><span class="line">​</span><br><span class="line">let inheritedConfigs = myConfigSettings.extends.map(resolveConfig);</span><br></pre></td></tr></table></figure><p>这对 TypeScript 用户很有帮助，但是很多人使用 TypeScript 来使用 JSDoc 注释对他们的 JavaScript 代码进行类型检查。这就是为什么 TypeScript 5.0 支持一个名为 JSDoc 的新标签，<code>@satisfies</code>它做的事情完全一样。</p><p><code>/** @satisfies */</code> 可以捕获类型不匹配：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// @ts-check</span><br><span class="line">​</span><br><span class="line">/**</span><br><span class="line"> * @typedef CompilerOptions</span><br><span class="line"> * @prop &#123;boolean&#125; [strict]</span><br><span class="line"> * @prop &#123;string&#125; [outDir]</span><br><span class="line"> */</span><br><span class="line">​</span><br><span class="line">/**</span><br><span class="line"> * @satisfies &#123;CompilerOptions&#125;</span><br><span class="line"> */</span><br><span class="line">let myCompilerOptions = &#123;</span><br><span class="line">    outdir: &quot;../lib&quot;,</span><br><span class="line">//  ~~~~~~ oops! we meant outDir</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但它会保留我们表达式的原始类型，允许我们稍后在代码中更精确地使用我们的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// @ts-check</span><br><span class="line">​</span><br><span class="line">/**</span><br><span class="line"> * @typedef CompilerOptions</span><br><span class="line"> * @prop &#123;boolean&#125; [strict]</span><br><span class="line"> * @prop &#123;string&#125; [outDir]</span><br><span class="line"> */</span><br><span class="line">​</span><br><span class="line">/**</span><br><span class="line"> * @typedef ConfigSettings</span><br><span class="line"> * @prop &#123;CompilerOptions&#125; [compilerOptions]</span><br><span class="line"> * @prop &#123;string | string[]&#125; [extends]</span><br><span class="line"> */</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">/**</span><br><span class="line"> * @satisfies &#123;ConfigSettings&#125;</span><br><span class="line"> */</span><br><span class="line">let myConfigSettings = &#123;</span><br><span class="line">    compilerOptions: &#123;</span><br><span class="line">        strict: true,</span><br><span class="line">        outDir: &quot;../lib&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    extends: [</span><br><span class="line">        &quot;@tsconfig/strictest/tsconfig.json&quot;,</span><br><span class="line">        &quot;../../../tsconfig.base.json&quot;</span><br><span class="line">    ],</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">let inheritedConfigs = myConfigSettings.extends.map(resolveConfig);</span><br></pre></td></tr></table></figure><p><code>/** @satisfies */</code>也可以在任何带括号的表达式上内联使用。我们可以 <code>myConfigSettings</code>这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let myConfigSettings = /** @satisfies &#123;ConfigSettings&#125; */ (&#123;</span><br><span class="line">    compilerOptions: &#123;</span><br><span class="line">        strict: true,</span><br><span class="line">        outDir: &quot;../lib&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    extends: [</span><br><span class="line">        &quot;@tsconfig/strictest/tsconfig.json&quot;,</span><br><span class="line">        &quot;../../../tsconfig.base.json&quot;</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>为什么？好吧，当您更深入地了解其他一些代码（例如函数调用）时，它通常更有意义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compileCode(/** @satisfies &#123;ConfigSettings&#125; */ (&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/51753">此功能由</a><a target="_blank" rel="noopener" href="https://github.com/a-tarasyuk">Oleksandr Tarasiuk</a>提供！</p><h2 id="JSDoc-支持-overload"><a href="#JSDoc-支持-overload" class="headerlink" title="JSDoc 支持 @overload"></a>JSDoc 支持 <code>@overload</code></h2><p>在 TypeScript 中，您可以为函数指定重载。重载为我们提供了一种方式，可以用不同的参数调用一个函数，并可能返回不同的结果。他们可以限制调用者实际使用我们函数的方式，并优化他们将返回的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Our overloads:</span><br><span class="line">function printValue(str: string): void;</span><br><span class="line">function printValue(num: number, maxFractionDigits?: number): void;</span><br><span class="line">​</span><br><span class="line">// Our implementation:</span><br><span class="line">function printValue(value: string | number, maximumFractionDigits?: number) &#123;</span><br><span class="line">    if (typeof value === &quot;number&quot;) &#123;</span><br><span class="line">        const formatter = Intl.NumberFormat(&quot;en-US&quot;, &#123;</span><br><span class="line">            maximumFractionDigits,</span><br><span class="line">        &#125;);</span><br><span class="line">        value = formatter.format(value);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们说过 <code>printValue</code> 将 <code>string</code>或 <code>number</code> 作为其第一个参数。如果它需要一个 <code>number</code>，它可以使用第二个参数来确定我们可以打印多少个小数位。</p><p>TypeScript 5.0 现在允许 JSDoc 使用新标签声明重载 <code>@overload</code>。每个带有标记的 JSDoc 注释都 <code>@overload</code> 被视为以下函数声明的不同重载。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// @ts-check</span><br><span class="line">​</span><br><span class="line">/**</span><br><span class="line"> * @overload</span><br><span class="line"> * @param &#123;string&#125; value</span><br><span class="line"> * @return &#123;void&#125;</span><br><span class="line"> */</span><br><span class="line">​</span><br><span class="line">/**</span><br><span class="line"> * @overload</span><br><span class="line"> * @param &#123;number&#125; value</span><br><span class="line"> * @param &#123;number&#125; [maximumFractionDigits]</span><br><span class="line"> * @return &#123;void&#125;</span><br><span class="line"> */</span><br><span class="line">​</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;string | number&#125; value</span><br><span class="line"> * @param &#123;number&#125; [maximumFractionDigits]</span><br><span class="line"> */</span><br><span class="line">function printValue(value, maximumFractionDigits) &#123;</span><br><span class="line">    if (typeof value === &quot;number&quot;) &#123;</span><br><span class="line">        const formatter = Intl.NumberFormat(&quot;en-US&quot;, &#123;</span><br><span class="line">            maximumFractionDigits,</span><br><span class="line">        &#125;);</span><br><span class="line">        value = formatter.format(value);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，无论我们是在 TypeScript 还是 JavaScript 文件中编写，TypeScript 都可以让我们知道我们是否错误地调用了我们的函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// all allowed</span><br><span class="line">printValue(&quot;hello!&quot;);</span><br><span class="line">printValue(123.45);</span><br><span class="line">printValue(123.45, 2);</span><br><span class="line">​</span><br><span class="line">printValue(&quot;hello!&quot;, 123); // error!</span><br></pre></td></tr></table></figure><p>这个新标签的<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/51234">实现</a>要归功于<a target="_blank" rel="noopener" href="https://github.com/apendua">Tomasz Lenarcik</a>。</p><h2 id="在tsc-build-时可以传入的新指令"><a href="#在tsc-build-时可以传入的新指令" class="headerlink" title="在tsc --build 时可以传入的新指令"></a>在tsc <code>--build</code> 时可以传入的新指令</h2><p>TypeScript 现在允许在 <code>--build</code> 模式下传递以下指令</p><ul><li><code>--declaration</code></li><li><code>--emitDeclarationOnly</code></li><li><code>--declarationMap</code></li><li><code>--sourceMap</code></li><li><code>--inlineSourceMap</code></li></ul><p>这使得自定义构建的某些部分变得更加容易，您可能有不同的开发和生产构建。</p><p>例如，库的开发构建可能不需要生成声明文件，但生产构建需要。项目可以将声明发射配置为默认关闭，只需使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --build -p ./my-project-dir</span><br></pre></td></tr></table></figure><p>一旦在内循环中完成迭代，“生产”构建就可以传递指令 <code>--declaration</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --build -p ./my-project-dir --declaration</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/51241">有关此更改的更多信息，请参见此处</a>。</p><h2 id="编辑器中不区分大小写的导入排序"><a href="#编辑器中不区分大小写的导入排序" class="headerlink" title="编辑器中不区分大小写的导入排序"></a>编辑器中不区分大小写的导入排序</h2><p>在 Visual Studio 和 VS Code 等编辑器中，TypeScript 支持组织和排序导入和导出的体验。但是，对于列表何时“排序”，通常会有不同的解释。</p><p>例如，下面的导入列表是否排序？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">    Toggle,</span><br><span class="line">    freeze,</span><br><span class="line">    toBoolean,</span><br><span class="line">&#125; from &quot;./utils&quot;;</span><br></pre></td></tr></table></figure><p>答案可能令人惊讶地是“视情况而定”。如果我们<em>不</em>关心区分大小写，那么这个列表显然没有排序。这封信 <code>f</code> 出现在 <code>t</code> 和之前 <code>T</code>。</p><p>但在大多数编程语言中，排序默认是比较字符串的字节值。JavaScript 比较字符串的方式意味着 <code>&quot;Toggle&quot;</code> 总是在前面 <code>&quot;freeze&quot;</code> ，因为根据 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ASCII">ASCII 字符编码</a>，大写字母在小写字母之前。所以从这个角度来看，导入列表是排序的。</p><p>TypeScript 之前考虑对导入列表进行排序，因为它正在进行基本的区分大小写的排序。<em>对于喜欢不区分</em>大小写排序的开发人员，或者使用像 ESLint 这样默认需要不区分大小写排序的工具的开发人员来说，这可能是一个令人沮丧的地方。</p><p>TypeScript 现在默认检测区分大小写。这意味着 TypeScript 和 ESLint 等工具通常不会就如何最好地对导入进行排序而相互“争吵”。</p><p>我们的团队也一直在试验<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/52115">进一步的排序策略，您可以在此处阅读有关内容</a>。这些选项最终可能由编辑器配置。目前，它们仍然不稳定且处于试验阶段，您现在可以通过使用 <code>typescript.unstable</code> JSON 选项中的条目在 VS Code 中选择加入它们。以下是您可以尝试的所有选项（设置为默认值）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;typescript.unstable&quot;: &#123;</span><br><span class="line">        // Should sorting be case-sensitive? Can be:</span><br><span class="line">        // - true</span><br><span class="line">        // - false</span><br><span class="line">        // - &quot;auto&quot; (auto-detect)</span><br><span class="line">        &quot;organizeImportsIgnoreCase&quot;: &quot;auto&quot;,</span><br><span class="line">​</span><br><span class="line">        // Should sorting be &quot;ordinal&quot; and use code points or consider Unicode rules? Can be:</span><br><span class="line">        // - &quot;ordinal&quot;</span><br><span class="line">        // - &quot;unicode&quot;</span><br><span class="line">        &quot;organizeImportsCollation&quot;: &quot;ordinal&quot;,</span><br><span class="line">​</span><br><span class="line">        // Under `&quot;organizeImportsCollation&quot;: &quot;unicode&quot;`,</span><br><span class="line">        // what is the current locale? Can be:</span><br><span class="line">        // - [any other locale code]</span><br><span class="line">        // - &quot;auto&quot; (use the editor&#x27;s locale)</span><br><span class="line">        &quot;organizeImportsLocale&quot;: &quot;en&quot;,</span><br><span class="line">​</span><br><span class="line">        // Under `&quot;organizeImportsCollation&quot;: &quot;unicode&quot;`,</span><br><span class="line">        // should upper-case letters or lower-case letters come first? Can be:</span><br><span class="line">        // - false (locale-specific)</span><br><span class="line">        // - &quot;upper&quot;</span><br><span class="line">        // - &quot;lower&quot;</span><br><span class="line">        &quot;organizeImportsCaseFirst&quot;: false,</span><br><span class="line">​</span><br><span class="line">        // Under `&quot;organizeImportsCollation&quot;: &quot;unicode&quot;`,</span><br><span class="line">        // do runs of numbers get compared numerically (i.e. &quot;a1&quot; &lt; &quot;a2&quot; &lt; &quot;a100&quot;)? Can be:</span><br><span class="line">        // - true</span><br><span class="line">        // - false</span><br><span class="line">        &quot;organizeImportsNumericCollation&quot;: true,</span><br><span class="line">​</span><br><span class="line">        // Under `&quot;organizeImportsCollation&quot;: &quot;unicode&quot;`,</span><br><span class="line">        // do letters with accent marks/diacritics get sorted distinctly</span><br><span class="line">        // from their &quot;base&quot; letter (i.e. is é different from e)? Can be</span><br><span class="line">        // - true</span><br><span class="line">        // - false</span><br><span class="line">        &quot;organizeImportsAccentCollation&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;javascript.unstable&quot;: &#123;</span><br><span class="line">        // same options valid here...</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以阅读<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/51733">有关自动检测和指定不区分大小写的原始工作</a>的更多详细信息，然后是<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/52115">更广泛的选项集</a>。</p><h2 id="switch-case-语法补足"><a href="#switch-case-语法补足" class="headerlink" title="switch&#x2F;case 语法补足"></a><code>switch</code>&#x2F;<code>case</code> 语法补足</h2><p>在编写 <code>switch</code> 语句时，TypeScript 现在会检测被检查的值何时具有文字类型。如果是这样，它将提供一个完成每个未发现的脚手架 <code>case</code>。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f46be8a37aea48dbbb6e2f5e2163f435~tplv-k3u1fbpfcp-watermark.image" alt="exhaustiveCaseCompletions-5.0-stable-1.gif"></p><p>您可以<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/50996">在 GitHub 上查看实施细节</a>。</p><h2 id="速度、内存和包大小优化"><a href="#速度、内存和包大小优化" class="headerlink" title="速度、内存和包大小优化"></a>速度、内存和包大小优化</h2><p>TypeScript 5.0 在我们的代码结构、数据结构和算法实现中包含许多强大的变化。这些都意味着你的整个体验应该更快——不仅仅是运行 TypeScript，甚至安装它。</p><p>以下是我们相对于 TypeScript 4.9 在速度和大小方面取得的一些有趣的胜利。</p><table><thead><tr><th>设想</th><th>时间或大小相对于 TS 4.9</th></tr></thead><tbody><tr><td>material-ui 构建时间</td><td>90%</td></tr><tr><td>TypeScript 编译器启动时间</td><td>89%</td></tr><tr><td>编剧建造时间</td><td>88%</td></tr><tr><td>TypeScript Compiler 自建时间</td><td>87%</td></tr><tr><td>Outlook Web 构建时间</td><td>82%</td></tr><tr><td>VS 代码构建时间</td><td>80%</td></tr><tr><td>打字稿 npm 包大小</td><td>59%</td></tr></tbody></table><p><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/03/speed-5.0-stable-2.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73208158996a434d98515e52316ecd17~tplv-k3u1fbpfcp-zoom-1.image" alt="TypeScript 5.0 相对于 TypeScript 4.9 的构建/运行时间图表：material-ui docs 构建时间：90%； 编剧建造时间：88%； tsc 启动时间：87%； tsc 构建时间：87%； Outlook Web 构建时间：82%； VS 代码构建时间：80%"></a></p><p><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/03/size-5.0-stable-1.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ac8162940ec44d796be80db5e65c423~tplv-k3u1fbpfcp-zoom-1.image" alt="TypeScript 4.9 和 5.0 之间的 npm 包大小图表。 4.9 包大小为 63.8 MB，5.0 包大小为 37.4 MB。"></a></p><p>如何？有一些显着的改进，我们希望在未来提供更多细节。但我们不会让您等待那篇博文。</p><p>首先，我们最近将 TypeScript 从命名空间迁移到模块，使我们能够利用现代构建工具来执行范围提升等优化。使用此工具、重新审视我们的打包策略并删除一些已弃用的代码，已将 TypeScript 4.9 的 63.8 MB 包大小减少了约 26.4 MB。它还通过直接函数调用为我们带来了显着的加速。我们在这里整理了<a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/typescripts-migration-to-modules/">一份关于我们迁移到模块的详细文章</a>。</p><p>TypeScript 还为编译器中的内部对象类型增加了更多的统一性，并且还精简了存储在其中一些对象类型上的数据。这减少了多态操作，同时平衡了因使我们的对象形状更统一而增加的内存使用量。</p><p>在将信息序列化为字符串时，我们还执行了一些缓存。类型显示可能作为错误报告、声明发出、代码完成等的一部分发生，最终可能会相当昂贵。TypeScript 现在缓存了一些常用的机制以在这些操作中重用。</p><p>我们做出的另一个改进解析器的显着变化是利用 <code>var</code> 偶尔回避使用 <code>let</code> 和 <code>const</code> 跨闭包的成本。这提高了我们的一些解析性能。</p><p>总的来说，我们预计大多数代码库应该会看到 TypeScript 5.0 的速度提升，并且始终能够重现 10% 到 20% 之间的胜利。当然，这将取决于硬件和代码库特性，但我们鼓励您今天就在您的代码库上尝试一下！</p><p>有关详细信息，请参阅我们的一些显着优化：</p><ul><li><a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/51387">迁移到模块</a></li><li><a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/51682"><code>Node</code> 单体化</a></li><li><a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/51880"><code>Symbol</code> 单体化</a></li><li><a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/52170"><code>Identifier</code> 缩小尺寸</a></li><li><a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/52382"><code>Printer</code> 缓存</a></li><li><a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/52924">限制使用 <code>var</code></a></li></ul><h2 id="重大更改和弃用"><a href="#重大更改和弃用" class="headerlink" title="重大更改和弃用"></a>重大更改和弃用</h2><h3 id="运行时要求"><a href="#运行时要求" class="headerlink" title="运行时要求"></a>运行时要求</h3><p>TypeScript 现在以 ECMAScript 2018 为目标。TypeScript 包还设置了最低预期引擎 12.20。对于 Node 用户，这意味着 TypeScript 5.0 的最低版本要求至少为 Node.js 12.20 及更高版本。</p><h3 id="lib-d-ts变化"><a href="#lib-d-ts变化" class="headerlink" title="lib.d.ts变化"></a><code>lib.d.ts</code>变化</h3><p>更改 DOM 类型的生成方式可能会对现有代码产生影响。值得注意的是，某些属性已从 <code>number</code> 数字文字类型转换为数字文字类型，并且用于剪切、复制和粘贴事件处理的属性和方法已跨界面移动。</p><h3 id="API-重大变更"><a href="#API-重大变更" class="headerlink" title="API 重大变更"></a>API 重大变更</h3><p>在 TypeScript 5.0 中，<a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/typescripts-migration-to-modules/">我们转向了模块</a>，删除了一些不必要的接口，并进行了一些正确性改进。有关更改内容的更多详细信息，请参阅我们的<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/wiki/API-Breaking-Changes">API 重大更改</a>页面。</p><h3 id="关系运算符中禁止的隐式强制转换"><a href="#关系运算符中禁止的隐式强制转换" class="headerlink" title="关系运算符中禁止的隐式强制转换"></a>关系运算符中禁止的隐式强制转换</h3><p>如果您编写的代码可能会导致隐式的字符串到数字强制转换，则 TypeScript 中的某些操作会警告您：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function func(ns: number | string) &#123;</span><br><span class="line">  return ns * 4; // Error, possible implicit coercion</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 5.0 中，这也将应用于关系运算符<code>&gt;</code>、<code>&lt;</code>、<code>&lt;=</code>和<code>&gt;=</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function func(ns: number | string) &#123;</span><br><span class="line">  return ns &gt; 4; // Now also an error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要，要允许这样做，您可以显式地将操作数强制为<code>number</code>using <code>+</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function func(ns: number | string) &#123;</span><br><span class="line">  return +ns &gt; 4; // OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/52048">正确性改进由</a> <a target="_blank" rel="noopener" href="https://github.com/Andarist">Mateusz Burzyński</a> 提供。</p><h3 id="枚举大修"><a href="#枚举大修" class="headerlink" title="枚举大修"></a>枚举大修</h3><p><code>enum</code> 自从它的第一个版本以来，TypeScript 就一直存在一些关于 s 的奇怪之处。在 5.0 中，我们正在清理其中的一些问题，并减少理解 <code>enum</code> 您可以声明的各种 s 所需的概念数。</p><p>作为其中的一部分，您可能会看到两个主要的新错误。首先是将域外文字分配给类型 <code>enum</code> 现在会像人们预期的那样出错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum SomeEvenDigit &#123;</span><br><span class="line">    Zero = 0,</span><br><span class="line">    Two = 2,</span><br><span class="line">    Four = 4</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">// Now correctly an error</span><br><span class="line">let m: SomeEvenDigit = 1;</span><br></pre></td></tr></table></figure><p>另一个是用混合数字和间接字符串枚举引用声明值的枚举会错误地创建一个全数字 <code>enum</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum Letters &#123;</span><br><span class="line">    A = &quot;a&quot;</span><br><span class="line">&#125;</span><br><span class="line">enum Numbers &#123;</span><br><span class="line">    one = 1,</span><br><span class="line">    two = Letters.A</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">// Now correctly an error</span><br><span class="line">const t: number = Numbers.two;</span><br></pre></td></tr></table></figure><p>您可以<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/50528">在相关更改中查看更多详细信息</a>。</p><h3 id="对构造函数中的参数装饰器进行更准确的类型检查-experimentalDecorators"><a href="#对构造函数中的参数装饰器进行更准确的类型检查-experimentalDecorators" class="headerlink" title="对构造函数中的参数装饰器进行更准确的类型检查--experimentalDecorators"></a>对构造函数中的参数装饰器进行更准确的类型检查<code>--experimentalDecorators</code></h3><p>TypeScript 5.0 使 <code>--experimentalDecorators</code>。这一点变得明显的一个地方是在构造函数参数上使用装饰器时。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export declare const inject:</span><br><span class="line">  (entity: any) =&gt;</span><br><span class="line">    (target: object, key: string | symbol, index?: number) =&gt; void;</span><br><span class="line">​</span><br><span class="line">export class Foo &#123;&#125;</span><br><span class="line">​</span><br><span class="line">export class C &#123;</span><br><span class="line">    constructor(@inject(Foo) private x: any) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此调用将失败，因为<code>key</code>需要一个 <code>string | symbol</code>，但构造函数参数收到一个键 <code>undefined</code>。<code>key</code> 正确的解决方法是更改 within 的类型 <code>inject</code>。如果您使用的是无法升级的库，一个合理的解决方法是包装 <code>inject</code> 一个类型更安全的装饰器函数，并在<code>key</code>.</p><p>更多详情，<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/52435">请参阅本期</a>。</p><h3 id="弃用和默认更改"><a href="#弃用和默认更改" class="headerlink" title="弃用和默认更改"></a>弃用和默认更改</h3><p>在 TypeScript 5.0 中，我们弃用了以下设置和设置值：</p><ul><li><code>--target: ES3</code></li><li><code>--out</code></li><li><code>--noImplicitUseStrict</code></li><li><code>--keyofStringsOnly</code></li><li><code>--suppressExcessPropertyErrors</code></li><li><code>--suppressImplicitAnyIndexErrors</code></li><li><code>--noStrictGenericChecks</code></li><li><code>--charset</code></li><li><code>--importsNotUsedAsValues</code></li><li><code>--preserveValueImports</code></li><li><code>prepend</code>在项目参考中</li></ul><p>在 TypeScript 5.5 之前，这些配置将继续被允许，届时它们将被完全删除，但是，如果您正在使用这些设置，您将收到警告。在 TypeScript 5.0 以及未来版本 5.1、5.2、5.3 和 5.4 中，您可以指定 <code>&quot;ignoreDeprecations&quot;: &quot;5.0&quot;</code> 屏蔽这些警告提示。我们还将很快发布一个 4.9 补丁，以允许指定 <code>ignoreDeprecations</code> 以允许更平滑的升级。除了弃用之外，我们还更改了一些设置以更好地改进 TypeScript 中的跨平台行为。</p><p><code>--newLine</code>，它控制 JavaScript 文件中发出的行尾，如果未指定，过去常常根据当前操作系统进行推断。我们认为构建应该尽可能具有确定性，并且 Windows 记事本现在支持换行符行结尾，因此新的默认设置是 <code>LF</code>。 旧的特定于操作系统的推理行为不再可用。</p><p><code>--forceConsistentCasingInFileNames</code>, 这确保了项目中对同一文件名的所有引用都在大小写中达成一致，现在默认为 <code>true</code>。 这有助于捕获在不区分大小写的文件系统上编写的代码的差异问题。</p><p>您可以留下反馈并查看<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/51909">有关 5.0 弃用跟踪问题的更多信息</a></p><h2 id="下一步是什么？"><a href="#下一步是什么？" class="headerlink" title="下一步是什么？"></a>下一步是什么？</h2><p>不要操之过急，TypeScript 5.1 已经在开发中了，<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/53031">我们所有的计划都已经在 GitHub 上了</a>。如果你跃跃欲试，我们鼓励你尝试 <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/nightly-builds.html">TypeScript 的每日构建版本</a>或针对 <a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-typescript-next">VS Code 的 JavaScript 和 TypeScript Nightly 扩展</a>！</p><p>当然，如果您选择只享受 TypeScript 的新稳定版，我们也不会感到受伤。我们希望 TypeScript 5.0 让每个人的编码更快、更有趣。</p><p>Happy Hacking!</p><p>– Daniel Rosenwasser 和 TypeScript 团队</p></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="http://example.com/2023/03/19/typescript/" title="[译] TypeScript 5.0 发布" target="_blank" rel="external">http://example.com/2023/03/19/typescript/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="https://github.com/xuyangzhou" target="_blank" class="img-burn thumb-sm visible-lg"><img src="/images/avatar.jpg" class="img-rounded w-full" alt=""></a></div><div class="media-body"><h3 class="media-heading"><a href="https://github.com/xuyangzhou" target="_blank"><span class="text-dark">Jason</span><small class="ml-1x">鲜衣怒马少年时，一日看尽长安花</small></a></h3><div>个人简介。</div></div></figure></div></div></div></article><section id="comments"><div id="vcomments"></div></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/2023/04/06/volar/" title="[译] Volar: 一个新的开始"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a></li><li class="next"><a href="/2023/03/01/review2022/" title="[译] 尤雨溪：Vue 2022 回顾及 2023 展望"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li><li class="toggle-toc"><a class="toggle-btn" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button"><span>[&nbsp;</span><span>文章目录</span> <i class="text-collapsed icon icon-anchor"></i> <i class="text-in icon icon-close"></i> <span>]</span></a></li></ul><div class="bar-right"><div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div></div></div></nav></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/xuyangzhou" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="https://www.jianshu.com/u/162eaf8819d3" target="_blank" title="简书" data-toggle="tooltip" data-placement="top"><i class="icon icon-简书"></i></a></li><li><a href="https://juejin.cn/user/2471357871046333" target="_blank" title="Juejin" data-toggle="tooltip" data-placement="top"><i class="icon icon-juejin"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul><div class="copyright"><div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine"></script><script type="text/javascript">var GUEST=["nick","mail","link"],meta=(meta="nick,mail,link").split(",").filter(function(e){return-1<GUEST.indexOf(e)});new Valine({el:"#vcomments",verify:!1,notify:!1,appId:"",appKey:"",placeholder:"Just go go",avatar:"mm",meta:meta,pageSize:"10",visitor:!1})</script></body></html>